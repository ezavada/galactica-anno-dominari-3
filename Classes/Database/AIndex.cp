// =============================================================================// AIndex.cp                    	 ©1995-96, Sacred Tree Software, inc.// // AIndex.cp contains methods needed for an abstract class of index file objects// for a database management system. It's a mix-in class intended to be mixed with// a LStream subclass. Its function is to maintain an index of Key values related// to Record IDs.//// depends upon UMemoryMgr.h, and UException.h// UMemoryMgr are is OS Dependant// only OS dependancy in this file is use of handles in ShiftItems()//// General Purpose Access Methods://	RecIDT		FindKey(void* inKeyData);//							returns the record id of the first matching key entry//	RecIDT		FindNthKeyOccurance(void* inKeyData, long inWhich);//							returns the record id of the Nth matching key entry//	void		AddKey(RecIDT inRecID, void* inKeyData, Boolean inUnique = key_NonUnique);//							adds an entry for the specified rec ID, if inUnique = key_Unique//							it confirms that there are no other keys with this value//	void		UpdateKey(RecIDT inRecID, void* inKeyData);//							change the key stored in the index for the specified record//	void		DeleteKey(RecIDT inRecID, void* inKeyData);//							remove the key entry from the index//// Other Useful Methods://	Boolean		SetBatchMode(Boolean inBatchMode)//							prevents resorting of index during batch operations//	Int32		GetEntryCount() const//							returns the number of valid entries in the index//	Boolean		FetchEntryAt(UInt32 inAtIndex, KeyEntryT &outEntry)//							returns the Nth index entry//// version 1.5.0//// created:   7/28/96, ERZ//// =============================================================================#include <LStream.h>#include <UMemoryMgr.h>#include <UException.h>#include "handle.h"#include "UDatabaseKey.h"#include "AIndex.h"#define kCompResultLessThan		-1#define kCompResultEqual     	0#define kCompResultGreaterThan	1#define kAllocBlockSize		256				// number of index entries to allocate at once#pragma options align=mac68ktypedef struct IndexHeaderT {	Bool8	fileOpen;	Int8	keyEntrySize;	Uint32	itemCount;	Uint32	allocatedSlots;	UInt32	firstItemPos;	Uint32	numValidEntries;} IndexHeaderT;#pragma options align=resetAIndex::AIndex(UDatabaseKey *inKey) {	mItemCount = 0;	mAllocatedSlots = 0;	mFirstItemPos = sizeof(IndexHeaderT);	mNumValidEntries = 0;	mBatchMode = false;	mIndexOpen = false;	itsStream = (LStream*)NULL;	itsKey = inKey;	mKeyEntrySize = itsKey->GetKeySize() + sizeof(RecIDT);}AIndex::~AIndex() {}#pragma mark-UInt32AIndex::GetEntryCount() const {	return mNumValidEntries;}BooleanAIndex::FetchEntryAt(UInt32 inAtIndex, KeyEntryT &outEntry) {	if (inAtIndex <= mItemCount) {		PeekEntry(inAtIndex, outEntry);		return true;	} else		return false;}UInt32AIndex::FetchEntry(KeyEntryT &ioEntry) {	UInt32 entryPos;	Boolean itemFound;	itemFound = BinarySearch(ioEntry, entryPos);	if (!itemFound)		entryPos = dbPos_NotFound;	return entryPos;}RecIDTAIndex::FindKey(void* inRawKeyData, UInt32 inRawSize) {	Assert_(itsKey != nil);	KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];	RecIDT foundID = kInvalidRecID;	entry->recID = kInvalidRecID;	itsKey->MakeKey(inRawKeyData, &entry->keyData, inRawSize);	if (dbPos_NotFound != FetchEntry(*entry) )		foundID = entry->recID;	delete entry;	return foundID;}RecIDTAIndex::FindNthKeyOccurance(void* inRawKeyData, long inWhich, UInt32 inRawSize) {	Assert_(itsKey != nil);	KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];	RecIDT foundID = kInvalidRecID;	entry->recID = kInvalidRecID;	itsKey->MakeKey(inRawKeyData, &entry->keyData, inRawSize);	UInt32 entryPos = FetchEntry(*entry);	if (entryPos != dbPos_NotFound) {		if (FetchEntryAt(entryPos + inWhich - 1, *entry)) {	// check at our offset from the first			if (itsKey->CompareToKey(inRawKeyData, inRawSize, entry->keyData) == kCompResultEqual)				foundID = entry->recID;		}	}	delete entry;	// dump the key entry buffer	return foundID;}voidAIndex::AddKey(RecIDT inRecID, void* inRawKeyData, UInt32 inRawSize, Boolean inUnique) {	Assert_(itsKey != nil);	KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];	entry->recID = kInvalidRecID;	itsKey->MakeKey(inRawKeyData, &entry->keyData, inRawSize);	// make raw data into standard key	UInt32 entryPos;				// add space in the index for a new entry	Boolean found =	BinarySearch(*entry, entryPos);	if (found) {		if (inUnique)			Throw_( dbDuplicateKey );		itsKey->MakeKey(inRawKeyData, &entry->keyData, inRawSize);	// BinarySearch() overwrote it	}	UInt32 newSpacePos = AddSpace();					// add space in the index for a new entry	ShiftItems(entryPos, newSpacePos - 1, entryPos + 1);	// make room at insertion position	mNumValidEntries++;				// we added a valid entry	entry->recID = inRecID;	PokeEntry(entryPos, *entry);	// write the entry	delete entry;	if (!mBatchMode)		WriteHeader();				// update the header while we're at it}voidAIndex::DeleteKey(RecIDT inRecID, void* inRawKeyData, UInt32 inRawSize) {	Assert_(itsKey != nil);	KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];	entry->recID = inRecID;	itsKey->MakeKey(inRawKeyData, &entry->keyData, inRawSize);	// convert raw data into a key of standard size	UInt32 entryPos = FetchEntry(*entry);	delete entry;	if (entryPos == dbPos_NotFound)		Throw_( dbItemNotFound );	ShiftItems(entryPos + 1, index_Last, entryPos);	// get rid of deleted index entry	mNumValidEntries--;				// we removed a valid index entry	mItemCount--;	if (!mBatchMode)		WriteHeader();				// update the header while we're at it}voidAIndex::UpdateKey(RecIDT inRecID, void* inOldRawKeyData, UInt32 inOldRawSize, 									void* inNewRawKeyData, UInt32 inNewRawSize) {	Assert_(itsKey != nil);	KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];	entry->recID = inRecID;										// find out where it was	itsKey->MakeKey(inOldRawKeyData, &entry->keyData, inOldRawSize);	UInt32 oldEntryPos = FetchEntry(*entry);	if (oldEntryPos == dbPos_NotFound) {		delete entry;		Throw_( dbItemNotFound );	}	entry->recID = kInvalidRecID;								// now see where it belongs	itsKey->MakeKey(inNewRawKeyData, &entry->keyData, inNewRawSize);	UInt32 newEntryPos;	BinarySearch(*entry, newEntryPos);	if (newEntryPos < oldEntryPos)		ShiftItems(newEntryPos, oldEntryPos - 1, newEntryPos + 1);	// shift items toward end	else if (newEntryPos > oldEntryPos) {		ShiftItems(oldEntryPos + 1, newEntryPos - 1, oldEntryPos);	// shift items toward front		newEntryPos -= 1;	}	entry->recID = inRecID;	PokeEntry(newEntryPos, *entry);								// write the entry	delete entry;}BooleanAIndex::SetBatchMode(Boolean inBatchMode) {	Boolean oldBatch = mBatchMode;	mBatchMode = inBatchMode;	if (!mBatchMode)		WriteHeader();	// write the header now that we are done with batch mode	return oldBatch;}// if ioEntry.recID != kInvalidRecID, the search will only return found if the ID number matches.// returns true if item found, ioEntry contains the found item, outEntryPos is where it was found// returns false if not found, outEntryPos = location where it would be inserted, ioEntry unchangedBooleanAIndex::BinarySearch(KeyEntryT &ioEntry, Uint32 &outEntryPos) {	Boolean itemFound = false;	if (0 == mItemCount)		outEntryPos = 1;	else {		RecIDT checkID = ioEntry.recID;		int compResult;		KeyEntryT* entry = (KeyEntryT*) new char[mKeyEntrySize];		UInt32 foundIndex = 0;		UInt32 currentIndex;		UInt32 lowBound = 1;		UInt32 highBound = mItemCount;		do {			currentIndex = (lowBound + highBound) >> 1;	// get the item index			PeekEntry(currentIndex, *entry);			// load the item			compResult = itsKey->CompareKeys(&entry->keyData[0], &ioEntry.keyData[0]);			if (compResult == kCompResultEqual) {				foundIndex = currentIndex;		// last position we found one at				if (checkID != kInvalidRecID) {		// looking for a unique recID/key combination?					if (entry->recID == checkID) {	// yes, and we found it during the						checkID = kInvalidRecID;	// binary seach by pure luck, so we don't						break;						// need to do a linear seach for it later					}				}				highBound = currentIndex - 1;			} else if (compResult < 0)				lowBound = currentIndex + 1;			else				highBound = currentIndex - 1;		} while (lowBound <= highBound);	// we need to keep going till we find the _first_ one		if (compResult < 0)			currentIndex += 1;		if (foundIndex == 0)			outEntryPos = currentIndex;		else {			if (checkID != kInvalidRecID) {			// even though we found an item with the 				foundIndex += 1;					// same key, if checkID is non-zero it means				while (foundIndex <= mItemCount) {	// we have to keep looking because we need 					PeekEntry(foundIndex, *entry);	// an ID match in addition to the Key match.					if (entry->recID == checkID)						break;						// now we really found it					foundIndex += 1;					}				if (foundIndex > mItemCount) {		// we ran out of items while looking for it					outEntryPos = currentIndex;		// insert position will be first key match					return false;					// we didn't find it after all				}			}			itemFound = true;			outEntryPos = foundIndex;			// move found item data into ioEntry			PeekEntry(foundIndex, ioEntry);		// we had to reload it anyway		}		delete entry;	}	return itemFound;}Uint32 AIndex::AddSpace() {	mItemCount++;	Int32 newSlots = (mItemCount/kAllocBlockSize + 1) * kAllocBlockSize; // allocate in blocks	if (mAllocatedSlots < newSlots) {		//# allocated slots changed?		Uint32 fileSize = mFirstItemPos + newSlots * mKeyEntrySize;		itsStream->SetLength(fileSize);		// expand file		mAllocatedSlots = newSlots;			// write new # slots in disk file header		if (!mBatchMode)			WriteHeader();	}	return mItemCount;}void AIndex::ShiftItems(Uint32 inStartPos, Uint32 inEndPos, Uint32 inDestPos) {	if (inEndPos == index_Last)		inEndPos = mItemCount;	long bytesToMove = (inEndPos - inStartPos + 1) * mKeyEntrySize;		//calc bytes to move	long bytesMoved = 0;	long bytesRemaining;	Uint32 srcFilePos;	Uint32 dstFilePos;	long buffSize = (bytesToMove > 65536) ? 65536 : bytesToMove;	temp_buffer(void, buffer, buffSize);	// allocate a temp buffer of type void* named buffer	// move the data 	while (bytesMoved < bytesToMove) {		bytesRemaining = bytesToMove - bytesMoved;		if (buffSize > bytesRemaining)			 buffSize = bytesRemaining;		srcFilePos = mFirstItemPos + (inStartPos - 1) * mKeyEntrySize;		dstFilePos = mFirstItemPos + (inDestPos - 1) * mKeyEntrySize;		if (inStartPos > inDestPos) {		// handle possible overlap while shifting toward front			  srcFilePos += bytesMoved;			  dstFilePos += bytesMoved;		}		else {	// handle possible overlap while shifting towards back			srcFilePos += bytesRemaining - buffSize;			dstFilePos += bytesRemaining - buffSize;		}		itsStream->SetMarker(srcFilePos , streamFrom_Start);		itsStream->ReadBlock(buffer, buffSize );		itsStream->SetMarker(dstFilePos, streamFrom_Start);		itsStream->WriteBlock(buffer, buffSize );		bytesMoved += buffSize;	}}Boolean AIndex::ReadHeader() {	IndexHeaderT tempHeader;	itsStream->SetMarker(0, streamFrom_Start);	itsStream->ReadBlock(&tempHeader, sizeof(IndexHeaderT) );	mKeyEntrySize = tempHeader.keyEntrySize;	mItemCount = tempHeader.itemCount;	mAllocatedSlots = tempHeader.allocatedSlots;	mFirstItemPos = tempHeader.firstItemPos;	mNumValidEntries = tempHeader.numValidEntries;	return (tempHeader.fileOpen);}void AIndex::WriteHeader(Boolean inFileOpen) {	IndexHeaderT tempHeader;	tempHeader.fileOpen = inFileOpen;	tempHeader.keyEntrySize = mKeyEntrySize;	tempHeader.itemCount = mItemCount;	tempHeader.allocatedSlots = mAllocatedSlots;	tempHeader.firstItemPos = mFirstItemPos;	tempHeader.numValidEntries = mNumValidEntries;	itsStream->SetMarker(0, streamFrom_Start);	itsStream->WriteBlock(&tempHeader, sizeof(IndexHeaderT) );}voidAIndex::PeekEntry(Uint32 inAtIndex, KeyEntryT &outEntry) {	Uint32 filePos = mFirstItemPos + (inAtIndex - 1) * mKeyEntrySize;	itsStream->SetMarker( filePos, streamFrom_Start);	itsStream->ReadBlock(&outEntry, mKeyEntrySize );}voidAIndex::PokeEntry(Uint32 inAtIndex, const KeyEntryT &inEntry) {	if (index_Last == inAtIndex)		inAtIndex = mItemCount;	Uint32 filePos = mFirstItemPos + (inAtIndex - 1) * mKeyEntrySize;	itsStream->SetMarker( filePos, streamFrom_Start);	itsStream->WriteBlock(&inEntry, mKeyEntrySize );}BooleanAIndex::Open() {	Boolean result;	if (!mIndexOpen && HeaderExists())		result = ReadHeader();	else		result = false;	WriteHeader(kFileIsOpen);	//this should mark stream as open	mIndexOpen = true;	return result;}voidAIndex::Close() {	mBatchMode = false;	if (mIndexOpen)		WriteHeader(kFileIsClosed);	mIndexOpen = false;}