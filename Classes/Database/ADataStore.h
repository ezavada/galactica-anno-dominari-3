// =============================================================================// ADataStore.h                         й1995-98, Sacred Tree Software, inc.// // Abstract class for database files.//// version 1.5.5//// created:   6/16/95, ERZ// modified:  7/13/95, ERZ	Changed pure virtual methods to match C++ standard// modified:  7/14/95, ERZ	Moved override of FetchItemAt() to subclasses// modified:  7/24/95, ERZ	Moved all Index related references to AMasterIndexable// modified:  8/14/95, ERZ	Made inherited from LStream// modified: 11/18/95, ERZ	Added input paramater to GetNewRecordID()// modified:  1/30/96, ERZ	CW 8 updates, added MacOS Handle based methods// modified:  4/10/96, ERZ	made FetchItemAt() non const, Added SetTypeAndVersion() method// modified:   5/3/96, ERZ	Added IsFixedSize() virtual method// modified:  7/24/96, ERZ	v1.5, platform independant handles, CRecord calls// modified:  8/14/96, ERZ	Thread support// modified: 12/27/96, ERZ	added FetchItemHeaderAt(IndexT, void*) as non-virtual method// modified:  9/26/98, ERZ	v1.5.3, Added RecordExists(RecIDT) virtual method// modified:   4/3/99, ERZ  v1.5.4, Added GetLastRecordID() method// modified:  5/27/02, ERZ  v1.5.5, converted to bool instead of MacOS Boolean, removed class typedefs//// =============================================================================#ifndef ADATASTORE_H_INCLUDED#define ADATASTORE_H_INCLUDED#include "DatabaseTypes.h"#include <LComparator.h>#include <LStream.h>#if DB_THREAD_SUPPORT  #include "StSafeMutex.h"#endif#if DB_V15  #include "handle.h"  #include "CRecord.h"#endif#define kRepairProblems true#define kCheckOnly      falseclass ADataStore {	//: public LIteratedList.hpublic:	  #if DB_V15		ADataStore(SInt16 inStrcResID);	  #else		ADataStore();	  #endif		virtual ~ADataStore();		virtual bool		Open();	virtual void		Close();		virtual bool        CheckDatabaseIntegrity(bool inRepairProblems);		virtual void        Backup(const char* appendToFilename);		virtual bool		IsFixedSize() {return false;}	virtual bool		IsReadOnly() const = 0;	virtual void		SetDefaultComparator(LComparator *inComparator, bool inOwnsIt = false);	virtual bool		SetBatchMode(bool inBatchMode);	void				SetTypeAndVersion(OSType inType, UInt32 inVersion);	OSType				GetType() {return mStreamType;}	UInt32				GetVersion() {return mStreamVersion;}	RecIDT				GetLastRecordID() {return mLastRecID;}// data access methods	virtual RecIDT		GetNewRecordID(DatabaseRec *inRecP = (DatabaseRec*)nil);	virtual UInt32		GetRecordCount() const = 0;	virtual void		ReadRecord(DatabaseRec *ioRecP) = 0;	virtual bool		FindRecord(DatabaseRec *ioRecP, LComparator *inComparator = (LComparator*)nil) = 0;	virtual RecIDT		AddRecord(DatabaseRec *inRecP) = 0;	virtual void		UpdateRecord(DatabaseRec *inRecP) = 0;	virtual void		DeleteRecord(RecIDT inRecID) = 0;	virtual SInt32		GetRecordSize(RecIDT inRecID = 0) = 0;	virtual bool		RecordExists(RecIDT inRecID) = 0;		bool				FetchItemHeaderAt(IndexT inAtIndex, DatabaseRec *outItemHeader);	virtual bool		FetchItemAt(IndexT, void *, UInt32 &) {return false;}	// inAtIndex, outItem, ioItemSize#if DB_V15// record structure calls	virtual void		SetStructure(UStructure* inStructure);	UStructure*			GetStructure() {return mStructure;}// CRecord hi level access calls	CRecord*	MakeNewEmptyRecord();			// creates a CRecord object of proper Structure	CRecord*	ReadRecord(RecIDT inRecID);	RecIDT		AddRecord(CRecord* inRecP);		// adds only	void		UpdateRecord(CRecord* inRecP);	// updates only, must already exist	RecIDT		WriteRecord(CRecord* inRecP);	// updates, or adds if doesn't already exist	RecIDT		FindRecord(CRecord* inRecP, LComparator *inComparator = (LComparator*)nil);	void		DeleteRecord(CRecord* &inRecP);	// deletes the record and the object too// new platform independant calls (handle based access methods)	handle		ReadRecordHandle(RecIDT inRecID);	RecIDT		AddRecord(handle inRecH, RecIDT inNewRecID = 0);	void		UpdateRecord(RecIDT inRecID, handle inRecH);#elif ( PLATFORM_MACOS || PLATFORM_MACOSX || DB_WIN32_USING_QTML )// еее MacOS dependant calls (handle based access methods)	Handle		ReadRecord(RecIDT inRecID);	RecIDT		AddRecord(Handle inRecH, RecIDT inNewRecID = 0);	void		UpdateRecord(RecIDT inRecID, Handle inRecH);#endif	// ver 1.5protected:	virtual UInt32		AddNewEmptySlot(SInt32 inSize) = 0;	virtual bool		ReadHeader();	virtual void		WriteHeader(bool inFileOpen = true);	virtual bool		HeaderExists();	LComparator		*itsDefaultComparator;	LStream			*itsStream;	bool			mBatchMode;	bool			mFileOpen;	bool			mOwnsComparator;	RecIDT			mLastRecID;	OSType			mStreamType;	UInt32			mStreamVersion;#if DB_V15	UStructure*		mStructure;	SInt16			mStrcResID;	protected:	virtual UStructure*	MakeStructureObject(StrcResPtr inStrcRecP);	virtual CRecord*	MakeRecordObject(DatabaseRec* inData);#endif	// ver 1.5#if DB_THREAD_SUPPORTprotected:	LMutexSemaphore*	mChangeID;	LMutexSemaphore*	mAccessHeader;	LMutexSemaphore*	mChangeInfo;	// use these in subclasses when you are reading or writing	LMutexSemaphore*	mAccessData;	// see GetNewRecordID() for an example#endif};#endif // ADATASTORE_H_INCLUDED