// =============================================================================// AMasterIndex.h                      й1995-2002, Sacred Tree Software, inc.// // MasterIndex contains routines and objects needed for master index// file objects for a database management system. Abstract Class.//// version 1.5.8//// created:   7/19/95, ERZ// modified:  7/27/95, ERZ	made friend of class AMasterIndexable// modified:  1/30/96, ERZ	CW8 mods, Added use of CDeleteList class, so the master index //								is now permanently sorted and contains only valid entries// modified:   2/2/96, ERZ  Removed unused methods and fields, now does auto-detect of //								fixed vs. variable sized Indexables.// modified:  4/10/96, ERZ	Added SetTypeAndVersion() method// modified:  8/14/96, ERZ	Thread support// modified: 12/27/96, ERZ	Added caching of last entry found// modified:  2/21/98, ERZ	v1.5.3, fixed write to Read Only files bug// modified:  9/30/98, ERZ	v1.5.4, added check for out-of-sequence ids in AddRecord calls// modified:  5/27/02, ERZ  v1.5.8, converted to bool from MacOS Boolean, removed class typedefs//// =============================================================================#ifndef AMASTER_INDEX_H_INCLUDED#define AMASTER_INDEX_H_INCLUDED#include <LStream.h>#include "DatabaseTypes.h"#include "CDeleteList.h"#define kSlotSizeSlop	16L			// extra bytes allowed in slot in matching sizes#define kSlotSizeExtra	16L			// extra bytes in new var len recs to allow for growthtypedef struct IndexEntryT {	SInt32	recID;	SInt32	recPos;	SInt32	recSize;} IndexEntryT, *IndexEntryPtr, **IndexEntryHnd, **IndexEntryHdl;class AMasterIndexable;class AMasterIndex {friend class AMasterIndexable;public:              AMasterIndex();              virtual ~AMasterIndex();			void		SetTypeAndVersion(OSType inType, UInt32 inVersion);	OSType		GetType() {return mStreamType;}	UInt32		GetVersion() {return mStreamVersion;}	bool		SetBatchMode(bool inBatchMode);	void		UseIndexable(AMasterIndexable *inIndexable);	RecIDT      GetHighestUsedRecID() {return mHighestRecID;}	void        SetHighestUsedRecID(RecIDT inHighestRecID) { mHighestRecID = inHighestRecID; }// general purpose data access methods	UInt32		FindEntry(RecIDT inRecID, SInt32 *outRecSize = (SInt32*)NULL);	UInt32		AddEntry(RecIDT inRecID, SInt32 inRecSize = 0);	UInt32		UpdateEntry(RecIDT inRecID, SInt32 inNewRecSize);	UInt32		DeleteEntry(RecIDT inRecID);// special purpose access methods	UInt32		GetEntryCount() const;	bool		FetchEntryAt(UInt32 inAtIndex, IndexEntryT &outEntry);	UInt32		FetchEntry(RecIDT inRecID, IndexEntryT &outEntry);// methods used for database validation only	bool        FindFirstSlotFromDatabasePos(SInt32 inStartPos, SInt32 &outFoundSlotPos);	bool        CheckDeletedSlot(SInt32 inSlotPos, SInt32 inSlotSize = 0);	CDeleteList* GetDeleteList() {return itsDeleteList;}		virtual bool		Open();	virtual void		Close();protected:	void		SetIndexable(AMasterIndexable *inIndexable) {itsIndexable = inIndexable;}	bool		BinarySearch(RecIDT inRecID, IndexEntryT &outEntry, UInt32 &outEntryPos);	void		ShiftItems(UInt32 inStartPos, UInt32 inEndPos, UInt32 inDestPos);		UInt32		AddSpace();	void		PeekEntry(UInt32 inAtIndex, IndexEntryT &outEntry);	void		PokeEntry(UInt32 inAtIndex, const IndexEntryT &inEntry);		bool 	    ReadHeader();	virtual void WriteHeader(bool inIndexOpen = true);	bool		HeaderExists()	{return (itsStream->GetLength() > 8);}		AMasterIndexable 	*itsIndexable;	LStream 			*itsStream;	CDeleteList			*itsDeleteList;		SInt32		mItemSize;	SInt32		mItemCount;	SInt32		mAllocatedSlots;	SInt32		mFirstItemPos;	SInt32		mNumValidEntries;	IndexEntryT	mCachedEntry;		// еее this caching can introduce concurrency issues in	UInt32		mCachedEntryPos;	// multiuser mode, ERZ 2/21/98 еее	bool 	    mBatchMode;	bool		mIndexOpen;	bool		mTrackRecSize;	bool		mReadOnly;		// v1.5.3 addition, to fix write to read-only files bug	OSType		mStreamType;	UInt32		mStreamVersion;	RecIDT		mHighestRecID;		// v1.5.4 addition, to check for out-of-sequence adds#if DB_THREAD_SUPPORT	LMutexSemaphore*	mAccessHeader;	LMutexSemaphore*	mChangeInfo;	LMutexSemaphore*	mAccessData;#endif};#endif // AMASTER_INDEX_H_INCLUDED