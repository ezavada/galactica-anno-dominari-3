// =============================================================================// CRecordList.cp						©1995 - 97, Sacred Tree Software, inc.// // CRecordList is a subclass of LArray designed for managing sets of database// records referenced by unique ID numbers//// version 1.5.2//// created:   7/27/95, ERZ// modified:  7/29/96, ERZ	v1.5, added Union(), Intersection(), and CRecord//								based access methods// modified:  8/14/96, ERZ	added Difference(), fixed bug in Union & Intersection//								that limited list to 32,767 records// modified:  1/20/97, ERZ	normal Comparators no longer deleted// =============================================================================#include "CRecordList.h"#if _MacOS	#include "LAnimateCursor.h"		// ••• debugging	LAnimateCursor gCursor(130, 4);#endif#if !DB_V15	#pragma error CRecordList requires Database v1.5 extensions#endiflong	gLoadRecCache_Hits		= 0;long	gLoadRecCache_Misses	= 0;long	gFindNthCache_Hits		= 0;long	gFindNthCache_Misses	= 0;// =========================== LOAD REC COMPARATOR ==========================// the ULoadRecComparator is NOT a normal Comparator. It contains data fields// that are used to cache records and thus prevent certain obvious reloads.// One of its member variables is a reference to a normal Comparator, which does// the work of comparing the records' data after the Load Rec Comparator has// loaded them in.typedef class ULoadRecComparator : public LComparator {public:		ULoadRecComparator(ADataStore *inDataStore, LComparator *inSubComparator);		~ULoadRecComparator();	void				SetSubComparator(LComparator *inSubComparator);	LComparator*		GetSubComparator() {return itsSubComparator;}	virtual Int32		Compare(const void* inItemOne, const void* inItemTwo,								Uint32 inSizeOne, Uint32 inSizeTwo) const;	virtual	Int32		CompareToKey(const void* inItem, Uint32 inSize, const void* inKey) const;private:	ADataStore*		itsDataStore;	LComparator*	itsSubComparator;	CRecord*		itsCachedRecords[2];	RecIDT			itsCachedRecordIDs[2];} ULoadRecComparator, *ULoadRecComparatorPtr;ULoadRecComparator::ULoadRecComparator(ADataStore *inDataStore, LComparator *inSubComparator) {		Assert_(inDataStore != nil);	itsDataStore = inDataStore;	itsSubComparator = inSubComparator;	itsCachedRecords[0] = (CRecord*)nil;	itsCachedRecords[1] = (CRecord*)nil;	itsCachedRecordIDs[0] = 0;	itsCachedRecordIDs[1] = 0;}ULoadRecComparator::~ULoadRecComparator() {//	delete itsSubComparator; we don't delete the subComparator because we will instanciate only//	a single copy of it durinbg the lifetime of the program.	delete itsCachedRecords[0];	// delete whatever we left in the cache	delete itsCachedRecords[1];}#pragma mark-voidULoadRecComparator::SetSubComparator(LComparator *inSubComparator) {//	delete itsSubComparator;	// no longer deleting subcomparators, because we will have only// one instantiation of each	itsSubComparator = inSubComparator;}Int32ULoadRecComparator::Compare(const void* inItemOne, const void* inItemTwo, 							Uint32 inSizeOne, Uint32 inSizeTwo) const {	Assert_(itsSubComparator != nil);	Int32 result;	CRecord* rec0;	CRecord* rec1;	if (inSizeOne == sizeof(CRecord)) {				// was the record passed directly in?		rec0 = new CRecord((CRecord*)inItemOne);	} else {										// record was passed by RecID, load it		RecIDT recID0 = *((RecIDT*)inItemOne);			if (recID0 == itsCachedRecordIDs[0]) {		// we hold the last two records in the cache			rec0 = itsCachedRecords[0];				// because this will usually be called repeatedly			gLoadRecCache_Hits++;		} else {									// with the same ID in one the two items			gLoadRecCache_Misses++;			delete itsCachedRecords[0];			((ULoadRecComparator*)this)->itsCachedRecordIDs[0] = recID0;	// bypass const declaration			rec0 = itsDataStore->ReadRecord(recID0);			((ULoadRecComparator*)this)->itsCachedRecords[0] = rec0;		// bypass const		}	}	if (inSizeTwo == sizeof(CRecord)) {		rec1 = new CRecord((CRecord*)inItemTwo);	} else {		RecIDT recID1 = *((RecIDT*)inItemTwo);		if (recID1 == itsCachedRecordIDs[1]) {			rec1 = itsCachedRecords[1];			gLoadRecCache_Hits++;		} else {			gLoadRecCache_Misses++;			delete itsCachedRecords[1];			((ULoadRecComparator*)this)->itsCachedRecordIDs[1] = recID1;	// bypass const			rec1 = itsDataStore->ReadRecord(recID1);			((ULoadRecComparator*)this)->itsCachedRecords[1] = rec1;		// bypass const		}	}	result = itsSubComparator->Compare(rec0, rec1, sizeof(CRecord), sizeof(CRecord));  // call requested comparator  #if _MacOS// ••• debugging	gCursor.Set();  #endif			return (result);}Int32ULoadRecComparator::CompareToKey(const void* inItem, Uint32, const void* inKey) const {	// inSize	Assert_(itsSubComparator != nil);	Int32 result;	RecIDT recID = *((RecIDT*)inItem);	CRecord* rec = itsDataStore->ReadRecord(recID);	result = itsSubComparator->CompareToKey(rec, sizeof(CRecord), inKey);  // call requested comparator	delete rec;	// dispose of the memory the record occupied, but don't delete from Database	return (result);}#pragma mark-// =========================== RECORD LIST ==========================handleGetArrayItemsHandleCopy(LArray *inArray);handleGetArrayItemsHandleCopy(LArray *inArray) {	handle h;	h.copy(inArray->GetItemsHandle());	return h;}#pragma mark-CRecordList::CRecordList(ADataStore* inDataStore) : LArray(sizeof(RecIDT), (LComparator*)nil , true) {	InitRecordList(inDataStore);}CRecordList::CRecordList(ADataStore* inDataStore, CRecordList *inRecordList) : LArray(sizeof(RecIDT), GetArrayItemsHandleCopy(inRecordList), (LComparator*)nil, true, true) {	// copy constructor	InitRecordList(inDataStore);}// construct from block of recIDs. The CRecordList takes ownership of the handle, so don't dispose// it. And don't pass it a resource handle unless you've called DetachResource() on it first.CRecordList::CRecordList(ADataStore* inDataStore, handle inRecIDList, Boolean inRecIDListIsSorted): LArray(sizeof(RecIDT), inRecIDList, (LComparator*)nil, inRecIDListIsSorted, true) {	// copy constructor	InitRecordList(inDataStore);}CRecordList::~CRecordList() {	mComparator = itsLongComparator;	if (itsRecComparator)		delete itsRecComparator;}voidCRecordList::InitRecordList(ADataStore* inDataStore) {	mOwnsComparator = false;	Assert_(inDataStore != nil);	itsDataStore = inDataStore;	itsRecComparator = (ULoadRecComparator*)nil;	itsLongComparator = (LLongComparator*) mComparator;	cache_N = 0;			// initialize private cache for FindNthMatch()	cache_Comparator = (LComparator*)nil;	cache_Pos = 0;}#pragma mark-voidCRecordList::DoForEach(URecordAction &inRecordAction) {	Assert_(itsDataStore != nil);	inRecordAction.SetDataStore(itsDataStore);	RecIDT currID;	CRecord* rec;	for (int i = 1; i <= mItemCount; i++) {			// for each item in list		PeekItem(i, &currID);						// get rec id from list entry		Boolean loadData = inRecordAction.WantsRecordData();		if (loadData) {								// load the data if requested			rec = itsDataStore->ReadRecord(currID);			inRecordAction.SetRecord(rec);		}		if ( inRecordAction.DoRecordAction(currID) )	// do the action, and if they changed it,			itsDataStore->UpdateRecord(rec);			// update it in the database		if (loadData)			delete rec;	}}voidCRecordList::AddRecordToList(RecIDT inRecID) {	if (itsRecComparator)	// if the user has established a sort order by setting a comparator,		mComparator = itsRecComparator;		// make sure we add the id in that order.	InsertItemsAt(1, index_Last, &inRecID);}ArrayIndexTCRecordList::FetchIndexOfID(RecIDT inRecID) const {	Boolean wasSorted = mIsSorted;		// if there is a user defined sort order, we need to tell	if (itsRecComparator)				// LArray that we aren't sorted, because we are just going		((CRecordList*)this)->mIsSorted = false;		// to be looking for an ID using an LLongComparator.	((CRecordList*)this)->mComparator = itsLongComparator;	ArrayIndexT result = FetchIndexOf(&inRecID);	((CRecordList*)this)->mIsSorted = wasSorted;	if (itsRecComparator)		((CRecordList*)this)->mComparator = itsRecComparator;	return result;}CRecord*CRecordList::FetchRecordAt(ArrayIndexT inAtIndex) const {	RecIDT recID;	FetchItemAt(inAtIndex, &recID);	return itsDataStore->ReadRecord(recID);}CRecord*CRecordList::FindNthMatch(long n, CRecord* inRecord, const LComparator *inComparator) {	Boolean wasSorted = mIsSorted;	Boolean useDirectIndex = true;	Boolean startAtCached = false;	CRecord* resultRec = (CRecord*)nil;	ArrayIndexT	foundPos = 0;	RecIDT foundID = kInvalidRecID;	long givenN = n;	ULoadRecComparator tempComparator(itsDataStore, (LComparator*)inComparator);	if (inComparator == nil) {		if (itsRecComparator != nil) {			mComparator = itsRecComparator;			// use user's sort comparator			inComparator = itsRecComparator->GetSubComparator();		} else			Throw_( dbNoComparator );				// cannot search without a record comparator	} else {		mComparator = &tempComparator;				// use the comparator that was passed in		mIsSorted = false;							// but this means we don't have sorted order	}	if (!mIsSorted)		useDirectIndex = false;						// items are not in sorted order.	// the cache keeps track of what comparator was used so we can make sure we are using the	// info from an equivalent search. If the desired record is not found based on the cached item,	// don't just assume it's not there. Instead, do a standard search for the item, ignoring the	// cache. That way we don't run any risk of false negatives in our searches. Overkill? :-)	gFindNthCache_Misses++;	if (cache_N && cache_Pos && (cache_Comparator == inComparator) ) {	// can we use the cache?		if (cache_N == n) {			// cached item should be the one we want			foundPos = cache_Pos;		} else if (useDirectIndex) {	// cached item, not the one we want, but items are sorted…			foundPos = cache_Pos + (n - cache_N);	// …so calculate offset from the cached item		} else {	// don't even have sorted position. This is where the cache may help the most,			if (cache_N < n) {				// but only if an earlier item has already been found.				foundPos = cache_Pos;		// start the search from the cached position				n -= cache_N;				// we've already found cache_N items				startAtCached = true;				gFindNthCache_Misses--;				gFindNthCache_Hits++;			}		}		if (foundPos && !startAtCached) {			FetchItemAt(foundPos, &foundID);		// get the Nth item by just looking ahead			if (foundID != kInvalidRecID) {			// make sure there was such an item				if ( mComparator->Compare(&foundID, inRecord, sizeof(RecIDT), sizeof(CRecord)) == 0 ) {	  					resultRec = itsDataStore->ReadRecord(foundID);	// Nth Item matches					cache_Pos = foundPos;					cache_N = givenN;					gFindNthCache_Misses--;					gFindNthCache_Hits++;					return resultRec;				}			}		}	}	// item wasn't available via the cache, try a full search	if (useDirectIndex) {							// find where that record is located…		foundPos = NonUniqueBinarySearch(inRecord, sizeof(CRecord));		if (foundPos != index_Bad) {				// …using the current comparator			foundID = kInvalidRecID;				// we have a properly sorted list, so we can			FetchItemAt(foundPos + n - 1, &foundID);// get the Nth item by just looking ahead			if (foundID != kInvalidRecID) {			// make sure there was such an item				if (n>1) {							// we found the 1st item, but make sure the					if ( mComparator->Compare(&foundID, inRecord, sizeof(RecIDT), sizeof(CRecord)) == 0 )	  						resultRec = itsDataStore->ReadRecord(foundID);	// Nth Item matches				} else					resultRec = itsDataStore->ReadRecord(foundID);	// looking for 1st item, got it			}		}	} else {										// have to do it the hard way, we can't depend 		RecIDT* itemPtr = (RecIDT*)*mItemsH;		// on the sorted order, so we need to do a		if (!startAtCached)							// linear search for the Nth item, starting			foundPos = 0;							// from the begining of the array (or from the		else										// cached position in some cases)			itemPtr += cache_Pos;					// Will probably be slower than a binary search		Lock();		while (++foundPos <= mItemCount) {		  #if _MacOS		  	gCursor.Set();		  #endif			if (mComparator->Compare(inRecord, itemPtr, sizeof(CRecord), sizeof(RecIDT)) == 0) {				if (--n == 0)					break;			}			itemPtr++;	// get next array element		}		Unlock();		if (foundPos <= mItemCount)			resultRec = itsDataStore->ReadRecord(*itemPtr);	// found the requested item	}	if (itsRecComparator != nil)		mComparator = itsRecComparator;	mIsSorted = wasSorted;	if (resultRec) {			// cache the found item when successful		cache_Pos = foundPos;		cache_N = givenN;		cache_Comparator = (LComparator*)inComparator;	}	return resultRec;}// we overrode this method to allow Sorts of the list to operate more transparently// the problem was that since the list contained only id#s, any comparator that wanted// to sort on a different value couldn't without reading in the record, which would mean// the comparator would have to know what DataStore the record came from. This seemed like// way to much work for a comparator object, and would have prevented the creation of a// more generic comparator: there would have to be a special one just for use in a CRecordList// and any others would work differently.//// The solution was to use a ULoadRecComparator. The CRecordList intercepts attempts to// change the comparator, and instead makes the given comparator the "sub-comparator"// of the ULoadRecComparator. The ULoadRecComparator's job is to read in the record and then// pass a CRecord object to the user-specified Comparator.// NOTE: once you've set a comparator, adding items to the array will be much// 	slower because the array will have to load in various records to do comparisions//	when trying to decide where to put the new item. One way to work around this is//	if you have to add a bunch of new items after setting a comparator, you should//	call SetKeepSorted(false) to disactivate sorting while making changes, then//	call SetKeepSorted(true) when you are all done to resort everything.//// The Comparator passed in is NOT owned by the CRecordList. This is different than the standard// behavior of LArray. Since the CRecordList does not own the Comparator, it will not try to delete// it when the list is deleted. You should allocate your comparators once when first used and// leave them allocated through the entire life of the program. Since Comparators are frequently// used, this avoids the overhead of repeated news and deletes on an object that contains no data,// but only methods.//// Passing in a NIL Comparator will resort the list by RecID, making it possible to do optimal// union, intersection, and difference operations. Resorting by RecID is very fast.voidCRecordList::SetComparator(LComparator *inComparator) {	if (inComparator == nil) {		delete itsRecComparator;		itsRecComparator = (ULoadRecComparator*)nil;	} else if (itsRecComparator == nil)			itsRecComparator = new ULoadRecComparator(itsDataStore, inComparator);	else		itsRecComparator->SetSubComparator(inComparator);	if (itsRecComparator)		mComparator = itsRecComparator;	else		mComparator = itsLongComparator;	mOwnsComparator = false;	if (mItemCount > 1)			//	With more than one item, Array is no		mIsSorted = false;		//	longer sorted when Comparator changes	if (mKeepSorted)		Sort();}// You should always try to do your Union operations BEFORE you assign// a Comparator, otherwise the union will be slower because it will have to// do linear searches rather than binary searches.// Assigning a NIL comparator will also give you an optimal Union operation,// but you will lose the sorted order given by the previous comparator// returns false if result is an empty setBooleanCRecordList::Union(const CRecordList *inRecordList) {	Boolean wasSorted = mIsSorted;	if (itsRecComparator)		mIsSorted = false;				// user has set a sort order other than by RecID	SetKeepSorted(false);				// we don't want any sorting going on during this process	mComparator = itsLongComparator;	RecIDT currID;	long realItemCount;	long originalItemCount = mItemCount;	ArrayIndexT foundPos;	inRecordList->Lock();	long count = inRecordList->GetCount();	for (long i = 1; i <= count; i++) {				// for each item in list		inRecordList->PeekItem(i, &currID);			// get rec id from list entry		realItemCount = mItemCount;		mItemCount = originalItemCount;		// don't want FetchIndexOf to look at the new items		foundPos = FetchIndexOf(&currID);		mItemCount = realItemCount;			// now restore the real item count		if (foundPos == index_Bad)			InsertItemsAt(1, index_Last, &currID);	// add the item that we didn't have	}	inRecordList->Unlock();	if (itsRecComparator)		mComparator = itsRecComparator;	SetKeepSorted(wasSorted);	// restore keep sorted state	return (mItemCount <= 0);}// You should always try to do your Intersection operations BEFORE you assign// a Comparator to the inRecordList, otherwise the intersection will be slower // because it will have to do linear searches rather than binary searches.// Assigning a NIL comparator will also give you an optimal Intersection operation,// but you will lose the sorted order given by the previous comparator// returns false if result is an empty setBooleanCRecordList::Intersection(const CRecordList *inRecordList) {	RecIDT currID;	long count = mItemCount;	long index = 1;	for (long i = 1; i <= count; i++) {				// for each item in list		PeekItem(index, &currID);					// get rec id from list entry		if (inRecordList->FetchIndexOfID(currID) == index_Bad)			RemoveItemsAt(1, index);	// remove the item that the other list didn't have		else 			index += 1;					// go on to the next item	}	return (mItemCount <= 0);}// Removes all records that are in inRecordList from the CRecordList// returns false if result is an empty set// You should always try to do your Difference operations BEFORE you assign// a Comparator, otherwise the difference will be slower because it will have to// do linear searches rather than binary searches. Assigning a NIL comparator// will also give you an optimal Difference operation, but you will lose the// sorted order given by the previous comparatorBooleanCRecordList::Difference(const CRecordList *inRecordList) {	mComparator = itsLongComparator;	RecIDT currID;	inRecordList->Lock();	long count = inRecordList->GetCount();	for (long i = 1; i <= count; i++) {				// for each item in list		inRecordList->PeekItem(i, &currID);			// get rec id from list entry		Remove(&currID);	}	if (itsRecComparator)		mComparator = itsRecComparator;	inRecordList->Unlock();	return (mItemCount <= 0);}// ---------------------------------------------------------------------------//		• NonUniqueBinarySearch// ---------------------------------------------------------------------------//	Return the index of the specified item using a binary search//	differs from LArray::BinarySearch() by assuming the items are not unique and//	always finding the first one (by sort order) in the list////	Assumes that the Array is sortedArrayIndexTCRecordList::NonUniqueBinarySearch(const void *inItem, Uint32 inItemSize) const {	ArrayIndexT		left = 1, right = mItemCount, current = 1, foundIndex = 0;	Int32			comparison = 0;	Lock();	while (left <= right) {		current = (left + right) / 2;		comparison = mComparator->Compare(GetItemPtr(current), inItem,										  GrabItemSize(current), inItemSize);		if (comparison == 0) {			foundIndex = current;			right = current - 1;		} else if (comparison > 0) {			right = current - 1;		} else {			left = current + 1;		}	}	Unlock();	if (foundIndex == 0) {		foundIndex = index_Bad;	}	return foundIndex;}