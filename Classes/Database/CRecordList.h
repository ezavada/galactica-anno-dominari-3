// =============================================================================// CRecordList.h								й1995, Sacred Tree Software, inc.// // CRecordList is a subclass of LArray designed for managing sets of database// records referenced by unique ID numbers//// version 1.5.0//// created:   7/27/95, ERZ// modified:  7/29/96, ERZ	v1.5, added Union() and Intersection() and CRecord//								based access methods//// =============================================================================#pragma once#include <LArray.h>#include <LComparator.h>#include "DatabaseTypes.h"#include "CRecord.h"#include "ADataStore.h"#define recList_DontLoadData	false#define recList_LoadData		trueclass ULoadRecComparator;class CRecordList;#if _MacOS	class LAnimateCursor;	// еее debugging	extern LAnimateCursor gCursor;#endif// ============================ URecordAction ===================================// defines an abstract base class for classes that do something to a record// USAGE: override the DoRecordAction method to do something with a record in the list//	if you set inWantsData to be true in your constuctor, the itsRecord member variable //	will have a CRecord object for that record already loaded when DoRecordAction() is //	called. The itsDataStore member variable will contain a reference to the DataStore//	to which the record with inRecID belongs.// DO NOT: return true from DoRecordAction if mWantsData was set to false. Do not return//	true if you deleted the record from the datastore. Do not delete the itsRecord member//	variable. Do not change the record ID unless you REALLY know what you're doing.typedef class URecordAction {public:	virtual Boolean	DoRecordAction(RecIDT inRecID) = 0; // override to perform the action														// return true if you changed record														// and want it written back to the datastore	void			SetRecord(CRecord* inRecord) {itsRecord = inRecord;}	void			SetDataStore(ADataStore* inDataStore) {itsDataStore = inDataStore;}	Boolean			WantsRecordData() {return mWantsData;}protected:	URecordAction(Boolean inWantsData) {mWantsData = inWantsData;}	// want the data autoloaded?	CRecord*	itsRecord;	ADataStore*	itsDataStore;	Boolean		mWantsData;} URecordAction, *URecordActionPtr;// defines a class to that deletes a record from a datastoretypedef class URecDeleteAction : public URecordAction {public:	URecDeleteAction() : URecordAction(false) {}	// don't need data preloaded to delete a rec		virtual Boolean	DoRecordAction(RecIDT inRecID) {										itsDataStore->DeleteRecord(inRecID);										return false; 									}} URecDeleteAction;// ============================ CRecordList ===================================typedef class CRecordList : public LArray {public:		CRecordList(ADataStore* inDataStore);		CRecordList(ADataStore* inDataStore, CRecordList *inRecordList);	// copy constructor		CRecordList(ADataStore* inDataStore, handle inRecIDList, Boolean inRecIDListIsSorted = false);	    						// construct from block of recIDs, the CRecordList    						// takes ownership of the handle, don't dispose it    						// and don't pass it a resource handle unless you've    						// called DetachResource on it first		~CRecordList();	void		DoForEach(URecordAction &inRecordAction);	void		AddRecordToList(RecIDT inRecID);	void		RemoveRecordFromList(RecIDT inRecID) {Remove(&inRecID);}	ArrayIndexT	FetchIndexOfID(RecIDT inRecID) const;	Boolean		RecordIsInList(RecIDT inRecID) const {return (FetchIndexOfID(inRecID) != index_Bad);}	CRecord*	FetchRecord(RecIDT inRecID) const {return itsDataStore->ReadRecord(inRecID);}	void		AddRecordToList(CRecord* inRecord) {AddRecordToList(inRecord->GetRecordID());}	void		RemoveRecordFromList(CRecord* inRecord) {RemoveRecordFromList(inRecord->GetRecordID());}	CRecord*	FetchRecordAt(ArrayIndexT inAtIndex) const;	CRecord*	FindNthMatch(long n, CRecord* inRecord, const LComparator *inComparator = (LComparator*)nil);	CRecord*	FindMatch(CRecord* inRecord, const LComparator *inComparator = (LComparator*)nil) {								return FindNthMatch(1, inRecord, inComparator);}	virtual void	SetComparator(LComparator *inComparator);	// the LComparator you pass in									// will be passed a CRecord*, not a pointer to the record data	Boolean		Union(const CRecordList *inRecordList);	Boolean		Intersection(const CRecordList *inRecordList);	Boolean		Difference(const CRecordList *inRecordList);	void		Clear() {RemoveItemsAt(0x7fffffff, 1);}		ArrayIndexT		NonUniqueBinarySearch(const void *inItem, Uint32 inItemSize) const;protected:	ADataStore*			itsDataStore;	LLongComparator*	itsLongComparator;	ULoadRecComparator* itsRecComparator;private:	long				cache_N;			// private cache for FindNthMatch()	LComparator*		cache_Comparator;	ArrayIndexT			cache_Pos;	void	InitRecordList(ADataStore* inDataStore);	// private initialization} CRecordList, *CRecordListPtr;