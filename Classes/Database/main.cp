// =============================================================================// main.cp                               ©1995, Sacred Tree Software, inc.// // Main Code to test database file object. //// version 1.1//// created:   7/11/95, ERZ// modified:  7/25/95, ERZ	using CMasterIndexFile instead of CSortedFile//// =============================================================================#include "UStructure.h"#include "CRecord.h"#include "CRecordList.h"#include <UException.h>#include <iostream.h>#define INCLUDE_ALLvoid main (void);// Compares field 5 of two recordstypedef class UTestRecComparator : public LComparator {public:	virtual Int32		Compare(const void* inItemOne, const void* inItemTwo,								Uint32 inSizeOne, Uint32 inSizeTwo) const;} UTestRecComparator;Int32UTestRecComparator::Compare(const void* inItemOne, const void* inItemTwo, Uint32, Uint32) const {	CRecord* rec1 = (CRecord*)inItemOne;	CRecord* rec2 = (CRecord*)inItemTwo;	long data1, data2;	rec1->GetFieldData(5, &data1);	rec2->GetFieldData(5, &data2);	return (data1 - data2);}typedef class UFlagRecComparator : public LComparator {public:	virtual Int32		Compare(const void* inItemOne, const void* inItemTwo,								Uint32 inSizeOne, Uint32 inSizeTwo) const;} UFlagRecComparator;Int32UFlagRecComparator::Compare(const void* inItemOne, const void* inItemTwo, Uint32, Uint32) const {	CRecord* rec1 = (CRecord*)inItemOne;	CRecord* rec2 = (CRecord*)inItemTwo;	short data1 = rec1->FlagIsSet(1) + rec1->FlagIsSet(6);	short data2 = rec2->FlagIsSet(1) + rec2->FlagIsSet(6);	return (data1 - data2);}#if _Win32#include <windows.h>//#undef INCLUDE_ALL	// can't include all when compiling for Win32intWINAPIWinMain(    HINSTANCE,	// hInstance    HINSTANCE,	// hPrevInstance    LPSTR, 		// lpCmdLine    int 		// nShowCmd    ){    MessageBox(NULL, "Click to begin testing...", "Sacred Tree Software, inc.", MB_OK);    main();    return 0;}#endif//#include <LPreferencesFile.h>#if option(profile)#include <Profiler.h>#endif#ifdef INCLUDE_ALL	#include "TestCode.h"	#include "CMasterIndexFile.h"	#include "CDataFile.h"	#include "CVarDataFile.h"	#include "CTextDataFile.h"	#include "CIndexFile.h"	#include "UDatabaseKey.h"//	#include "CWebCatDB.h"#endif#define kNumAdds     1000#define kNumUpdates  100#define kNumReads    1000#define kNumDeletes  100	// don't make num deletes bigger than number of adds#define kNumLifecycles  100#ifdef INCLUDE_ALL#define Time_( op , cnt )                                          \    do {                                                           \       long tStart__ = TickCount();                                \       op;                                                         \       long tEnd__ = TickCount();                                  \       long tElapsed__ = tEnd__ - tStart__;                        \       cout << "Total Ticks: " << tElapsed__;                      \       cout << ", Repetitions: " << cnt;    		               \       cout << ", Ticks/Operation: " << tElapsed__ / cnt << '\n';  \    } while (false)void RunTests(ADataStore *theDataFile);voidRunTests(ADataStore *theDataFile) {	long i, startTicks, stopTicks, ticks, count, startMem, stopMem;	RecIDT theID;	startMem = FreeMem();    startTicks = TickCount();    count = kNumAdds;    theID = TestAdding(theDataFile, count);    stopTicks = TickCount();    ticks = stopTicks - startTicks;	stopMem = FreeMem();    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";    cout << "   " << count/ticks << " operations per tick.\n";    cout << "   " << (count * 60)/ticks << " operations per second.\n";    if (startMem != stopMem)    	cout << "** Lost " << startMem - stopMem << " bytes **\n";    	startMem = FreeMem();    startTicks = TickCount();    count = kNumUpdates;	TestUpdating(theDataFile, theID, count);    stopTicks = TickCount();    ticks = stopTicks - startTicks;	stopMem = FreeMem();    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";    cout << "   " << count/ticks << " operations per tick.\n";    cout << "   " << (count * 60)/ticks << " operations per second.\n";    if (startMem != stopMem)    	cout << "** Lost " << startMem - stopMem << " bytes **\n";	startMem = FreeMem();    startTicks = TickCount();    count = kNumReads;	TestReading(theDataFile, theID, count );    stopTicks = TickCount();    ticks = stopTicks - startTicks;	stopMem = FreeMem();    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";    cout << "   " << count/ticks << " operations per tick.\n";    cout << "   " << (count * 60)/ticks << " operations per second.\n";    if (startMem != stopMem)    	cout << "** Lost " << startMem - stopMem << " bytes **\n";	startMem = FreeMem();    startTicks = TickCount();    count = kNumDeletes;	TestDeleting(theDataFile, theID, count );    stopTicks = TickCount();    ticks = stopTicks - startTicks;	stopMem = FreeMem();    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";    cout << "   " << count/ticks << " operations per tick.\n";    cout << "   " << (count * 60)/ticks << " operations per second.\n";    if (startMem != stopMem)    	cout << "** Lost " << startMem - stopMem << " bytes **\n";	cout << " ========================= Testing Record Lifecycle ====================\n";    	startMem = FreeMem();    startTicks = TickCount();    count = kNumLifecycles;	for (i = 0; i < count; i++)		TestRecordLifecycle(theDataFile);    stopTicks = TickCount();    ticks = stopTicks - startTicks;	stopMem = FreeMem();    cout << "Performed " << count << " tests in " << ticks << " ticks.\n";    cout << "   " << count/ticks << " tests per tick.\n";    cout << "   " << (count * 60)/ticks << " tests per second.\n";    if (startMem != stopMem)    	cout << "** Lost " << startMem - stopMem << " bytes **\n";}#endif	// INCLUDE_ALL// ============================== MAIN CODE ========================================void main (void) {  #if DB_THREAD_SUPPORT	LThread* mainThread = (LThread*)nil;  	if (UEnvironment::HasFeature(env_HasThreadsManager))		mainThread = new UMainThread;  #endif	InitConsole();		gDebugThrow = debugAction_Alert;	gDebugSignal = debugAction_Alert;//	Assert_(false /*Testing assertions*/);	handle strcH = ::GetResource('Strc', 128);	Assert_(strcH != nil);	strcH.lock();	UStructure* aStruct = new UStructure((StrcResPtr)*strcH);	// testing structure	strcH.disposeResource();		CRecord* aRec = new CRecord(aStruct);	handle h = aRec->GetRecordData();	Int32 size = aRec->GetRecordSize();	Int32 newSize = 0;	Assert_(size == 61);			// size defined by our Strc resource	Assert_(!aRec->FlagIsSet(2));	// this is not a valid flag, so it should always return false	aRec->SetFlag(1);	Assert_(aRec->FlagIsSet(1));	// we just set this flag, so it should be set	aRec->SetFlag(2);				// try to set an non-flag field as a flag should have no effect	Assert_(!aRec->FlagIsSet(2));	// so checking the invalid flag should still return false	aRec->ClearFlag(6);	Assert_(!aRec->FlagIsSet(6));	// we just cleared this flag, so it should be false	Assert_(aRec->GetFieldMaxSize(3) == 15);	// max size of this pstr field should be 15	aRec->SetFieldData(3, "\pTesting");			// set the pstr field to read "testing"	Str255 sx;	sx[0] = aRec->GetFieldSize(3);	Assert_(sx[0] == 15);			// size of fixed length field	aRec->GetFieldData(3, &sx[1]);	newSize = aRec->GetRecordSize();	Assert_(size == newSize);	// size should not have changed for a fixed length record.	handle strH("This is a much longer test, that can be used for several purposed, including testing a fixed length field for size overrun and for seeing how a variable length field responds.", 174);//				 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789//				 0         1         2         3         4         5         6         7         8         9        10        11        12        13        14        15        16        17      	aRec->SetFieldData(3, strH);	// test fixed length overflow	aRec->SetFieldData(2, strH);	// test allocating new variable length field	handle newStrH = aRec->GetFieldData(2);	// retreive the data we just wrote	Int32 fSize = aRec->GetFieldSize(2);	Assert_(fSize == strH.size());	// make sure the field size is correct	Assert_(newStrH.size() == strH.size());	// make sure we got back all the data	newSize = aRec->GetRecordSize();	Assert_(newSize == ( size + 2 + strH.size() ));	// make sure the record was resized correctly	strH.resize(40);	aRec->SetFieldData(2, strH);	// test shrinking a variable length field	fSize = aRec->GetFieldSize(2);	Assert_(fSize == strH.size());	// make sure the field size is correct	newSize = aRec->GetRecordSize();	Assert_(newSize == ( size + 2 + strH.size() ));	// make sure the record was resized correctly	aRec->SetFieldData(2, newStrH);	// test growing a variable length field	fSize = aRec->GetFieldSize(2);	Assert_(fSize == newStrH.size());	// make sure the field size is correct	newSize = aRec->GetRecordSize();	Assert_(newSize == ( size + 2 + newStrH.size() ));	// make sure the record was resized correctly    FSSpec theFileSpec;	short theVol;	long theDirID, startMem, stopMem;	CMasterIndexFile *theIndexFile = (CMasterIndexFile*) NULL;	ADataStore *theDataFile = (ADataStore*) NULL;#if _MacOS	Boolean aliasUpdated;	Str255 s;#endif	Try_ {		long a = sizeof(IndexEntryT);		Assert_(a == 12);		a = sizeof(DatabaseRec);		Assert_(a == 12);		cout << "Enter 'd' to test CDataFile, 'v' to test CVarDataFile, \n";		cout << "'t' for CTextDataFile, 'i' to test CIndexFile, \n";	  #if DB_V15		cout << "'l' for CRecordList, \n";	  #endif		cout << "or '!' for everything.\n";		char userKey;		cin >> userKey; 		cout << '\n';		Boolean testDF = ( (userKey=='d') || (userKey=='D') || (userKey=='!') );		Boolean testVF = ( (userKey=='v') || (userKey=='V') || (userKey=='!') );		Boolean testTF = ( (userKey=='t') || (userKey=='T') ); //|| (userKey=='!') );		Boolean testIX = ( (userKey=='i') || (userKey=='I') || (userKey=='!') );	  #if DB_V15		Boolean testRL = ( (userKey=='l') || (userKey=='L') || (userKey=='!') );	  #endif				Boolean testBatch = false;		if (testDF || testVF || testIX) {			do {				cout << "Should I test the batch mode too? (y/n)\n";			} while (!cin.peek());			cin >> userKey;			cout << '\n';			testBatch = ( (userKey=='y') || (userKey=='Y') );		}				Boolean stressTest = false;		long stressTestSecs = 0;		if (testDF || testVF || testTF) {			do {				cout << "Should I do a stress test too? (y/n)\n";			} while (!cin.peek());			cin >> userKey;			cout << '\n';			stressTest = ( (userKey=='y') || (userKey=='Y') );			if (stressTest) {				cout << " Stress test for how many seconds? ";				cin >> stressTestSecs;				SetRecordSizeFactor(3);			}		}	    ::LMSetRndSeed( ::TickCount() );   // initialize the random generator		#if _MacOS				::GetVol((StringPtr) &s, &theVol);	// get the volume name		theDirID = fsRtDirID;	#endif	#if option(profile)		ProfilerInit(collectDetailed, bestTimeBase, 100, 10);#endif		if (testDF) {	// test fixed record files			// To Create a new datafile:		  #if DB_V15	// simplified open under version 1.5			theDataFile = new CDataFile(128);	// 128 is the strc res id	  			  #else					// a. Create the index		    theIndexFile = new CMasterIndexFile();					// b. Create a CDataFile, passing it the item size and newly created CMasterIndex}			theDataFile = new CDataFile(128, theIndexFile);	// here, 128 is the recSize					// c. open a new index file			::FSMakeFSSpec(theVol, theDirID, "\pTest1.idx", &theFileSpec);			theIndexFile->OpenNew(theFileSpec, 'www', fsRdWrShPerm);						// d. open a new datafile file		  #endif			::FSMakeFSSpec(theVol, theDirID, "\pTest1", &theFileSpec);			((CDataFile*)theDataFile)->OpenNew(theFileSpec, 'www', fsRdWrShPerm);							// Now you can use the Datafile however you wish		    cout << "Testing DataFile ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";					startMem = ::FreeMem();			RunTests(theDataFile);			stopMem = ::FreeMem();	    	if (startMem != stopMem)    			cout << "*** In total lost " << startMem - stopMem << " bytes ***\n";					if (testBatch) {			    cout << "\n\nTesting DataFile Batch Mode ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";			    theDataFile->SetBatchMode(kBatchModeOn);  			    				RunTests(theDataFile);							    theDataFile->SetBatchMode(kBatchModeOff);			}						if (stressTest) {		 		cout << " ========================= Stress Testing ====================\n";			 					 	// To close a datafile for later reuse:			#if _MacOS		 		AliasHandle theFileAlias = ((CDataFile*)theDataFile)->MakeAlias();	// 1. Get and save the Aliases			  #if !DB_V15		 		AliasHandle theIndexAlias = theIndexFile->MakeAlias();		 	  #endif			#endif			 				 		theDataFile->Close();						// 2. Close the files			  #if !DB_V15	// simplified close under version 1.5		 		theIndexFile->Close();		 	  #endif		 	  		 		delete theDataFile;							// 3. Free them			  #if !DB_V15	// simplified cleanup under version 1.5		 		delete theIndexFile;		 	  #endif			 					 	// To reopen a previously used datafile			 					  #if DB_V15	// simplified open under version 1.5				theDataFile = new CDataFile(128);	// 128 is the strc res id	  				  #else					// a. Create the index			    theIndexFile = new CMasterIndexFile();					// b. Create a CDataFile, passing it the item size and newly created CMasterIndex				theDataFile = new CDataFile(128, theIndexFile);					// c. open the existing index file using the saved alias				theIndexFile->OpenExisting(nil, theIndexAlias, aliasUpdated);						// d. open the existing data file using the saved alias			  #endif			  #if _MacOS				((CDataFile*)theDataFile)->OpenExisting(nil, theFileAlias, &aliasUpdated, fsRdWrShPerm);	// no Aliases under Win32			  #else				((CDataFile*)theDataFile)->OpenExisting(theFileSpec, fsRdWrShPerm);		 	  #endif		 	  				startMem = ::FreeMem();				StressTest(theDataFile, stressTestSecs);				stopMem = ::FreeMem();		    	if (startMem != stopMem)	    			cout << "*** Stress test lost " << startMem - stopMem << " bytes ***\n";	    	#if _MacOS	    		DisposeHandle((Handle)theFileAlias);			  #if !DB_V15	// simplified cleanup under version 1.5	    		DisposeHandle((Handle)theIndexAlias);	    	  #endif	    	#endif			}								 		theDataFile->Close();						// Close the files		  #if !DB_V15	// simplified close under version 1.5	 		theIndexFile->Close();	 	  #endif	 		delete theDataFile;							// Free them		  #if !DB_V15	// simplified cleanup under version 1.5	 		delete theIndexFile;	 	  #endif		}				if (testVF) { // To Create a new variable length datafile:}		  #if DB_V15	// simplified open under version 1.5			theDataFile = new CVarDataFile(128);	// 128 is the strc res id	  			  #else		    theIndexFile = new CMasterIndexFile(); // a. Create the index			theDataFile = new CVarDataFile(theIndexFile);	// b. Create a CVarDataFile, passing it the newly created CMasterIndex			::FSMakeFSSpec(theVol, theDirID, "\pTest2.idx", &theFileSpec); // c. open a new index file			theIndexFile->OpenNew(theFileSpec, 'www', fsRdWrShPerm);			  #endif			::FSMakeFSSpec(theVol, theDirID, "\pTest2", &theFileSpec);	// d. open a new datafile file			((CVarDataFile*)theDataFile)->OpenNew(theFileSpec, 'www', fsRdWrShPerm); // Now you can use the VarDatafile however you wish		    cout << "Testing VarDataFile ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";			startMem = ::FreeMem();			RunTests(theDataFile);			stopMem = ::FreeMem();	    	if (startMem != stopMem)    			cout << "*** In total lost " << startMem - stopMem << " bytes ***\n";			if (testBatch) {			    cout << "\n\nTesting VarDataFile Batch Mode ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";			    theDataFile->SetBatchMode(kBatchModeOn);  				RunTests(theDataFile);			    theDataFile->SetBatchMode(kBatchModeOff);			}			if (stressTest) {		 		cout << " ========================= Stress Testing ====================\n";// To close a datafile for later reuse:			#if _MacOS		 		AliasHandle theFileAlias = ((CVarDataFile*)theDataFile)->MakeAlias();	// 1. Get and save the Aliases			  #if !DB_V15		 		AliasHandle theIndexAlias = theIndexFile->MakeAlias();		 	  #endif		 	#endif		 		theDataFile->Close();						// 2. Close the files			  #if !DB_V15	// simplified close under version 1.5		 		theIndexFile->Close();		 	  #endif		 		delete theDataFile;						// 3. Free them			  #if !DB_V15	// simplified cleanup under version 1.5		 		delete theIndexFile;			 	// To reopen a previously used datafile		 	  #endif			  #if DB_V15	// simplified open under version 1.5				theDataFile = new CVarDataFile(128); // a. Create a CVarDataFile			  #else			    theIndexFile = new CMasterIndexFile(); // b. Create a CVarDataFile, passing it the newly created CMasterIndex				theDataFile = new CVarDataFile(theIndexFile); // c. open the existing index file using the saved alias				theIndexFile->OpenExisting(theIndexAlias, aliasUpdated, nil, fsRdWrShPerm); // d. open the existing data file using the saved alias			  #endif			  #if _MacOS				((CVarDataFile*)theDataFile)->OpenExisting(nil, theFileAlias, &aliasUpdated, fsRdWrShPerm);			  #else				((CVarDataFile*)theDataFile)->OpenExisting(theFileSpec, fsRdWrShPerm);			  #endif				startMem = ::FreeMem();				StressTest(theDataFile, stressTestSecs);				stopMem = ::FreeMem();		    	if (startMem != stopMem)	    			cout << "*** Stress test lost " << startMem - stopMem << " bytes ***\n";	    	#if _MacOS	    		DisposeHandle((Handle)theFileAlias);			  #if !DB_V15	    		DisposeHandle((Handle)theIndexAlias);		 	  #endif		 	#endif			}					 		theDataFile->Close();						// Close the files		  #if !DB_V15	// simplified close and cleanup under version 1.5	 		theIndexFile->Close();	 		delete theIndexFile;	 	  #endif	 		delete theDataFile;							// Free them		}		#if option(profile)		ProfilerDump("\pprofile info");		ProfilerTerm();#endif				if (testTF) { // test text record files		  #if DB_V15			theDataFile = new CTextDataFile(128);	// a. Create a CTextDataFile		  #else			theDataFile = new CTextDataFile();	// a. Create a CTextDataFile		  #endif			::FSMakeFSSpec(theVol, theDirID, "\pTest3", &theFileSpec);	// b. open a new datafile file			((CTextDataFile*)theDataFile)->OpenNew(theFileSpec, 'www', fsRdWrShPerm); // Now you can use the Datafile however you wish		    cout << "Testing TextDataFile ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";			startMem = ::FreeMem();			RunTests(theDataFile);			stopMem = ::FreeMem();	    	if (startMem != stopMem)     			cout << "*** In total lost " << startMem - stopMem << " bytes ***\n";			if (testBatch) {			    cout << "\n\nTesting TextDataFile Batch Mode ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";			    theDataFile->SetBatchMode(kBatchModeOn);  				RunTests(theDataFile);			    theDataFile->SetBatchMode(kBatchModeOff);			}			if (stressTest) {		 		cout << " ========================= Stress Testing ====================\n";// To close a datafile for later reuse:			  #if _MacOS		 		AliasHandle theFileAlias = ((CTextDataFile*)theDataFile)->MakeAlias();	// 1. Get and save the Alias			  #endif		 		theDataFile->Close();						// 2. Close the file		 		delete theDataFile;						// 3. Free it			  #if DB_V15				theDataFile = new CTextDataFile(128);	// c. open the existing file			  #else				theDataFile = new CTextDataFile();	// c. open the existing file			  #endif			  #if _MacOS				((CTextDataFile*)theDataFile)->OpenExisting(nil, theFileAlias, &aliasUpdated, fsRdWrShPerm);			  #else				((CTextDataFile*)theDataFile)->OpenExisting(theFileSpec, fsRdWrShPerm);			  #endif				startMem = ::FreeMem();				StressTest(theDataFile, stressTestSecs);				stopMem = ::FreeMem();		    	if (startMem != stopMem)	    			cout << "*** Stress test lost " << startMem - stopMem << " bytes ***\n";	    	  #if _MacOS	    		::DisposeHandle(Handle(theFileAlias));	    	  #endif			}					 		theDataFile->Close();						// Close the file	 		delete theDataFile;							// Free it		}				if (testIX) {			ULongDBKey theLongKey;			CIndexFile* theIndexFile = new CIndexFile(&theLongKey);			::FSMakeFSSpec(theVol, theDirID, "\pTest1.idx1", &theFileSpec);			theIndexFile->OpenNew(theFileSpec, 'www', fsRdWrShPerm);			cout << "\nTesting Index File (indexing a long field) ¥¥¥¥¥¥¥¥\n";						Boolean done = false;			while (!done) {				startMem = FreeMem();	  			  cout << " ========================= Testing AddKey() ====================\n";			    long startTicks = TickCount();			    long x[kNumAdds];			    long count = kNumAdds;				for (int i = 1; i<=count; i++) {					x[i-1] = Random();					Try_ {						theIndexFile->AddKey(i, &x[i-1]);					}					Catch_(err) {						if (err == dbDuplicateKey)							cout << "ERROR: AddKey threw a DuplicateKey exception for " << x[i-1] << " but duplicates should be allowed.\n";						else							Throw_(err);					}				}			    long stopTicks = TickCount();			    long ticks = stopTicks - startTicks;				stopMem = FreeMem();			    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";			    cout << "   " << count/ticks << " operations per tick.\n";			    cout << "   " << (count * 60)/ticks << " operations per second.\n";			    if (startMem != stopMem)			    	cout << "** Lost " << startMem - stopMem << " bytes **\n";					startMem = FreeMem();	  			  cout << " ========================= Testing FindKey() ====================\n";			    startTicks = TickCount();			    count = kNumReads;				for (int i = 1; i<=count; i++) {					int n = Random() % kNumAdds;					if (n < 0)						n = -n;					long find = x[n];					n+=1;					long xx = theIndexFile->FindKey(&find);					if (xx == kInvalidRecID)						cout << "ERROR: FindKey() couldn't find the key for record " << n << "\n";					else if (xx != n) {						if (x[xx-1] != find)	// in case there were duplicates							cout << "ERROR: FindKey() return " << (int)xx << " as the ID for record " << n << "\n";					}				}			    stopTicks = TickCount();			    ticks = stopTicks - startTicks;				stopMem = FreeMem();			    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";			    cout << "   " << count/ticks << " operations per tick.\n";			    cout << "   " << (count * 60)/ticks << " operations per second.\n";			    if (startMem != stopMem)			    	cout << "** Lost " << startMem - stopMem << " bytes **\n";					startMem = FreeMem();	  			  cout << " ========================= Testing UpdateKey() ====================\n";			    startTicks = TickCount();			    count = kNumUpdates;				for (int i = 1; i<=count; i++) {					int n = Random() % kNumAdds;					if (n < 0)						n = -n;					long x0 = x[n];					long x1 = Random();					x[n] = x1;					n += 1;					Try_{						theIndexFile->UpdateKey(n, &x0, &x1);						long xx = theIndexFile->FindKey(&x1);						if (xx == kInvalidRecID)							cout << "ERROR: FindKey() couldn't find the key for record " << n << " after updating it\n";						else if (xx != n) {							if (x[xx-1] != x1)	// in case there were duplicates								cout << "ERROR: FindKey() returned " << (int)xx << " as the ID for record " << n << "\n";						}					}					Catch_(err) {						if (err == dbItemNotFound)							cout << "ERROR: UpdateKey() could find record " << n << " with key " << (int)x1 << "\n";						else							Throw_(err);					}				}			    stopTicks = TickCount();			    ticks = stopTicks - startTicks;				stopMem = FreeMem();			    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";			    cout << "   " << count/ticks << " operations per tick.\n";			    cout << "   " << (count * 60)/ticks << " operations per second.\n";			    if (startMem != stopMem)			    	cout << "** Lost " << startMem - stopMem << " bytes **\n";					startMem = FreeMem();	  			  cout << " ========================= Testing DeleteKey() ====================\n";			    startTicks = TickCount();			    count = kNumDeletes;				for (int i = 1; i<=count; i++) {					long deletingKey = x[i-1];					theIndexFile->DeleteKey(i, &deletingKey);					long xx = theIndexFile->FindKey(&deletingKey);					if (xx != kInvalidRecID) {						if (x[xx-1] != deletingKey) // could be a duplicate							cout << "ERROR: FindKey() still found the key for record " << (int)i << " after deleting it\n";					}				}			    stopTicks = TickCount();			    ticks = stopTicks - startTicks;				stopMem = FreeMem();			    cout << "Performed " << count << " operations in " << ticks << " ticks.\n";			    cout << "   " << count/ticks << " operations per tick.\n";			    cout << "   " << (count * 60)/ticks << " operations per second.\n";			    if (startMem != stopMem)			    	cout << "** Lost " << startMem - stopMem << " bytes **\n";			    			    if (testBatch) {				    cout << "\n\nTesting IndexFile Batch Mode ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n\n";				    theIndexFile->SetBatchMode(kBatchModeOn);  				    				    testBatch = false;				} else					done = true;			}			theIndexFile->Close();			delete theIndexFile;		}			  #if DB_V15		if (testRL) {			cout << "\nTesting CRecordList ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥\n";			cout << "\nCreating a DataFile with 1000 records for the test...\n";			theDataFile = new CDataFile(128);	// 128 is the strc res id	  				::FSMakeFSSpec(theVol, theDirID, "\pTest4", &theFileSpec);			((CDataFile*)theDataFile)->OpenNew(theFileSpec, 'www', fsRdWrShPerm);			CRecordList *allRecs = new CRecordList(theDataFile);			CRecord* rec;			long data;			RecIDT recID;			long firstSearchCount = 0;			long secondSearchCount = 0;			for (int i = 1; i <= 1000; i++) {				data = Random();				rec = theDataFile->MakeNewEmptyRecord(); 				Assert_(rec->GetFieldSize(4) == sizeof(long));				Assert_(rec->GetFieldSize(5) == sizeof(long));  				rec->SetFieldData(4, &data);   				data = 1001 - i;   				rec->SetFieldData(5, &data);   				if (i%10 == 0)   					rec->SetFlag(1);	// flag every 10th record   				if (i%100 == 0)   					rec->SetFlag(6);	// and every 100th too				if ((data <= 500) && rec->FlagIsSet(1) && !rec->FlagIsSet(6))					firstSearchCount++;				if (rec->FlagIsSet(1) && rec->FlagIsSet(6))					secondSearchCount++;				recID = theDataFile->AddRecord(rec);				if (recID != i)					cout << "\nThe id for record # " << i << " was " << recID << "\n";				allRecs->AddRecordToList(rec);				delete rec;			}			cout << "Done.\nVerifying list...\n";			for (int i = 1; i <= 1000; i++) {				ArrayIndexT pos = allRecs->FetchIndexOfID(i);				if (pos != i)					cout << "\nERROR: FetchIndexOfID() returned "<< pos <<" for id " << i <<"\n";			}			CRecordList *loRecs = new CRecordList(theDataFile);			CRecordList *hiRecs = new CRecordList(theDataFile);			CRecordList *tempRecs = new CRecordList(theDataFile);						CRecordList *flagRecs = new CRecordList(theDataFile);						cout << "Done.\n\nRetrieving 1000 records and building four lists from them...\n";			for (int i = 1; i <= 1000; i++) {				rec = allRecs->FetchRecordAt(i);				Assert_(rec->GetFieldSize(4) == sizeof(long));				Assert_(rec->GetFieldSize(5) == sizeof(long));				rec->GetFieldData(5, &data);				recID = rec->GetRecordID();				if (recID != i)					cout << "ERROR: FetchRecordAt() returned record id " << recID << " for entry # " << i << "\n";				if (data != 1001 - recID)					cout << "ERROR: GetFieldData() returned " << data << "for field 5 of record "<< recID<< "\n";				if (data <= 500) 					loRecs->AddRecordToList(rec);				else					hiRecs->AddRecordToList(rec);				rec->GetFieldData(4, &data);				if ((data>0) && (data < 1000))					tempRecs->AddRecordToList(rec);				if (rec->FlagIsSet(1))					flagRecs->AddRecordToList(rec);				delete rec;			}			int loCount = loRecs->GetCount();			int hiCount = hiRecs->GetCount();			int tempCount = tempRecs->GetCount();			int flagCount = flagRecs->GetCount();			cout << "Done.\nThere are now "<<tempCount<<" recs in the temp list.";			if (loCount != 500)				cout << "ERROR: There should be 500 recs in the lo list but there are "<<loCount<<"\n";			if (hiCount != 500)				cout << "ERROR: There should be 500 recs in the hi list but there are "<<hiCount<<"\n";			if (flagCount != 100)				cout << "ERROR: There should be 100 recs in the flag list but there are "<<flagCount<<"\n";			cout << "\n\nTesting Intersection...\n";			hiRecs->Intersection(tempRecs);			hiCount = hiRecs->GetCount();			if (hiCount > loCount)				cout << "ERROR: There should be less that "<<loCount<<" recs in the hi list but there are "<<hiCount<<"\n";			cout << "Done.\nTesting Union...\n";			tempCount = hiCount + loCount;			hiRecs->Union(loRecs);			hiCount = hiRecs->GetCount();			if (hiCount != tempCount )				cout << "ERROR: There should be "<<tempCount<<" recs in the hi list but there are "<<hiCount<<"\n";			cout << "Done.\n\nTesting User Defined Sort order (this will take a minute)...\n";		#if _MacOS			::ShowCursor();		#endif			allRecs->SetComparator(new UTestRecComparator());			cout << "Sorted 1000 records....\n";			loRecs->SetComparator(new UFlagRecComparator());			cout << "Sorted 500 more records.\n\nTesting Searches...\n";			CRecord* targetRec = theDataFile->MakeNewEmptyRecord();			targetRec->SetFlag(1);			targetRec->ClearFlag(6);			CRecordList* foundRecs = new CRecordList(theDataFile);			int i = 1;			do {				rec = loRecs->FindNthMatch(i++, targetRec);	// use the sort order comparator				if (rec) {					if (rec->FlagIsSet(1) && !rec->FlagIsSet(6))						foundRecs->AddRecordToList(rec);					else						cout << "ERROR: FindNthMatch() incorrectly returned "<<rec->GetRecordID()<<" as match number "<< i<<"\n";				}			} while ( (rec != nil) && (i < 500) );			cout << "Completed first search.\n";			int foundCount = foundRecs->GetCount();			if (foundCount != firstSearchCount) {				cout << "ERROR: There should be " << firstSearchCount; 				cout << " recs in the found list but there are "<<foundCount<<"\n";			}			foundRecs->Clear();			foundCount = foundRecs->GetCount();			if (foundCount != 0)				cout << "ERROR: Clear() left "<<foundCount<<" records in the list\n";			targetRec->SetFlag(6);			i = 1;			UFlagRecComparator* flagComp = new UFlagRecComparator();			do {				rec = allRecs->FindNthMatch(i++, targetRec, flagComp);	// use a comparator that conficts with the sort order				if (rec) {					if (rec->FlagIsSet(1) && rec->FlagIsSet(6))						foundRecs->AddRecordToList(rec);					else						cout << "ERROR: FindNthMatch() incorrectly returned "<<rec->GetRecordID()<<" as match number "<< i<<"\n";				}			} while ( (rec != nil) && (i < 1000) );			cout << "Completed second search.\n";			foundCount = foundRecs->GetCount();			if (foundCount != secondSearchCount) {				cout << "ERROR: There should be " << secondSearchCount; 				cout << " recs in the found list but there are "<<foundCount<<"\n";			}			delete allRecs;			delete loRecs;			delete hiRecs;			delete tempRecs;			delete flagRecs;			delete foundRecs;			theDataFile->Close();			delete theDataFile;		}	  #endif	}	Catch_ (inErr) {	    cout << "FAILURE: An unexpected exception code " << inErr << " was caught in main()\n";	    if (inErr == -48)	    	cout << "  Most likely you have old data files on the top layer of the hard disk\n";	    else if (inErr > 30000) {	    	switch (inErr) {				case dbIndexRequired:					cout << "Object requires AMasterIndex subclass as parameter.\n";					break;				case dbIndexCorrupt:					cout << "Corruption was detected in an index.\n";					break;				case dbDataCorrupt:					cout << "Corruption was detected in the data.\n";					break;				case dbInvalidID:					cout << "Invalid Record ID.\n";					break;				case dbItemNotFound:					cout << "Item was not found.\n";					break;				case dbIndexLeftOpen:					cout << "Index left open, probably a prior crash.\n";					break;				case dbFileLeftOpen:					cout << "Data file left open, probably a prior crash.\n";					break;				case dbSizeMismatch:					cout << "Sizes do not match.\n";					break;				case dbNoSuchField:					cout << "No such field.\n";					break;				case dbInvalidView:					cout << "Invalid View ID.\n";					break;	    	} 	    }	}}