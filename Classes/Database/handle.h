// handle.h// cross platform C++ handle class// by Ed Zavada 6/14/96// version 1.0 - initial implementation// version 1.1 - added disposeResource() and releaseResource() methods, fixed some minor bugs// version 1.2 - defined BlockMove() and fixed copy_mem() for non MacOS and Win32 compilations//				 defined GetResource() macro for Win32#pragma once#define __handle__#include "os_platform.h"#ifndef __cplusplus  #error handle.h REQUIRES C++#endif#if _OtherOS  #ifndef _STRING  #include <string.h>  #endif#endif#ifndef nil  #define nil ((void *) 0)#endiftypedef class handle {protected:	unsigned short	L;			// locked while >0 (only supports 65535 locks)#if _MacOS //-------------------------------------------------------------------------------	Handle H;					// ееее MacOS Handle manipulation is here ееее	void init() 					{H = nil; L = 0;}	void alloc_mem(h_size size)		{if (H) ::SetHandleSize(H, size); 				 					 else H = ::NewHandle(size);}	void dispose_mem() 				{if (H) ::DisposeHandle(H);}	void dispose_res()				{if (H) ::ReleaseResource(H);}	void set_locks() 				{if (L) ::HLock(H); else HUnlock(H);}	char* get_ptr() const 			{return (H) ? (char*)*H : nil;}	h_size get_size() const 		{return (H) ? ::GetHandleSize(H) : 0;}	void copy_mem(char* src, char* dst, h_size size) 									{::BlockMove(src,dst,size);}	void copy_ref(handle &h) 		{H = h.H;}public:	handle(Handle h) 				{init(); H = h;}	handle(Ptr p) 					{init(); copy(p, ::GetPtrSize(p));}	void		operator=(Handle h)	{H = h;}	operator	Handle()	{return H;}	operator	Ptr()		{return *H;}#elif _Win32 //---------------------------------------------------------------------------- 	HGLOBAL H; 					// еее Win32 HANDLE manipulation is here ееее  	LPVOID	P;	void init()						{H = nil; P = nil; L = 0;}	void alloc_mem(h_size size)		{ if (H) ::GlobalReAlloc(H, GMEM_MOVEABLE, size);									 else H = ::GlobalAlloc(GMEM_MOVEABLE, size);}	void dispose_mem()				{::GlobalFree(H);}	void dispose_res()				{::FreeResource(H);}	void set_locks()				{if (L) P = ::GlobalLock(H); 									 else { GlobalUnlock(H); P = nil; } }	char* get_ptr() const 			{if (P) return (char*)P; else {									 LPVOID p = ::GlobalLock(H); //::GlobalUnlock(H); 									 return (char*)p;} }	//leave the HANDLE locked	h_size get_size() const			{return (H) ? ::GlobalSize(H) : 0;}	void copy_mem(char* src, char* dst, h_size size)									{::MoveMemory((PVOID)dst,(const void*)src, size);}	void copy_ref(handle &h)		{H = h.H; P = h.P;}public:	handle(HANDLE& h) 	{init(); H = h;}	operator HANDLE()	{return H;}#elif _OtherOS //----------------------------------------------------------------------------	char* P;					// еее use C++ new/delete operators for other platforms еее	unsigned long N;	void init() 					{P = (char*)nil; N = 0; L = 0;}	void alloc_mem(h_size size) 	{if (N!=size) {char* op = P; P = new char[size];									 h_size n = (N>size) ? size : N;									 copy_mem(op, P, n); N = size; delete op;} }	void dispose_mem() 				{delete P;}	void dispose_res()				{delete P;}	void set_locks() 				{;}	// nothing to do, ptr is always locked	char* get_ptr() const 			{return P;}	h_size get_size() const 		{return N;}	void copy_mem(char* src, char* dst, h_size size)									{memmove(dst, src, size);}	void copy_ref(handle &h)		{P = h.P; N = h.N;}#endif //--------------------------------------------------------------------------------------public:		handle()							{init();}		handle(h_size size)					{init(); if (size>0) alloc_mem(size);}		handle(handle& h) 					{init(); copy_ref(h);}		handle(void* p, h_size bytes)		{init(); copy(p, bytes);}		~handle()							{;}	// dispose_mem();} don't auto dispose block	void	operator=(handle& h)			{copy_ref(h);}	void 	operator=(void* p)				{copy(p);}	char*	operator*()	const				{return get_ptr();}//	char*	operator->() const				{return get_ptr();}	char* 	operator[](h_size index) const	{return (get_ptr()+index);}	operator char*() const					{return get_ptr();}	//typecasting#ifndef _Win32	operator void*() const					{return get_ptr();}	//typecasting#endif	int		operator==(void* p) const		{return (get_ptr()==p);}	int		operator==(handle &h)			{return (get_ptr()==h.get_ptr());}	int		operator!=(void* p) const		{return (get_ptr()!=p);}	int		operator!=(handle &h)			{return (get_ptr()!=h.get_ptr());}	int		operator>(void* p) const		{return (get_ptr()>p);}	int		operator>(handle &h)			{return (get_ptr()>h.get_ptr());}	int		operator<(void* p) const		{return (get_ptr()<p);}	int		operator<(handle &h)			{return (get_ptr()<h.get_ptr());}	int		operator>=(void* p) const		{return (get_ptr()>=p);}	int		operator>=(handle &h)			{return (get_ptr()>=h.get_ptr());}	int		operator<=(void* p) const		{return (get_ptr()<=p);}	int		operator<=(handle &h)			{return (get_ptr()<=h.get_ptr());}	void	lock() 							{L++; set_locks();}	void	unlock() 						{if (L) L--; set_locks();}	void	release() 						{L--; if (!L) dispose();}	void	dispose() 						{dispose_mem(); init();}		// these resource related methods are used if the handle is a resource	void	releaseResource()				{L--; if (!L) disposeResource();}	void	disposeResource()				{dispose_res(); init();}		// copy sets size of this handle to hold source data	void	copy(handle& h)					{h_size n = h.get_size(); alloc_mem(n);											 copy_mem(h.get_ptr(), get_ptr(), n);}	void 	copy(void* p)					{copy_mem((char*)p, get_ptr(), get_size());}	void 	copy(void* p, h_size bytes)		{alloc_mem(bytes); 											 copy_mem((char*)p, get_ptr(), bytes);}		// copyto puts as much of our data as will fit into dest	void	copyto(handle& h)				{copyto(h[0], h.get_size());}	void	copyto(void* p)					{copy_mem(get_ptr(),(char*)p,get_size());}	void	copyto(void* p, h_size bytes)	{h_size n = get_size(); if (bytes<n) n=bytes;											 copy_mem(get_ptr(), (char*)p, n);}	h_size	size() const 					{return get_size();}	void	resize(h_size size)				{alloc_mem(size);}} handle;typedef class lock_handle {	handle *H;public:	lock_handle(handle *h) {H = h; H->lock();}	// lock the handle	~lock_handle() {H->unlock();}					// unlock the handle} lock_handle;typedef class autodispose_handle {	// **** don't use this class for a resource handle ****	handle H;	// don't use a ref, cause it might go out of scope before we dopublic:	autodispose_handle(handle h) {H = h;}			// store ref to the handle	~autodispose_handle() {H.dispose();}			// dispose the handle} autodispose_handle;typedef class autodispose_resource {	handle H;	// don't use a ref, cause it might go out of scope before we dopublic:	autodispose_resource(handle h) {H = h;}				// store ref to the resource handle	~autodispose_resource() {H.disposeResource();}		// dispose the resource handle} autodispose_resource;#define temp_buffer(TYPE, NAME, SIZE) 		\		handle z_H(SIZE); 					\		autodispose_handle z_HD(z_H); 		\		z_H.lock();							\		TYPE* NAME = (TYPE*) *z_H#if _Win32	#define BlockMove(src, dst, size) 		MoveMemory((PVOID)(dst),(const void*)(src), (DWORD)(size))	#define BlockMoveData(src, dst, size) 	MoveMemory((PVOID)(dst),(const void*)(src), (DWORD)(size))#elif _OtherOS	#define BlockMove(src, dst, size)		memmove(dst, src, size)	// from <string.h>	#define BlockMoveData(src, dst, size)	memmove(dst, src, size)	// from <string.h>#endif#if _Win32HANDLE GetResource(ResType rType, short rID);inline HANDLE GetResource(ResType rType, short rID) {	char winType[5];	*((long*)winType) = *(long*)&rType;	//	make a null terminated string from the typename	winType[4] = 0;  	HRSRC resInfoH = ::FindResource(NULL, (LPCTSTR)rID, (LPCTSTR)&winType);  	return ::LoadResource(NULL, resInfoH);}#endif/*template<class X> class auto_ptr {   X* px;   auto_ptr(auto_ptr& r);   void operator=(auto_ptr&); public:   auto_ptr(X* p=0): px(p) {}   X& operator*() const    { return *px; }   X* operator->() const   { return px; }   ~auto_ptr()             { delete px; }   X* get() const          { return px; }      X* release()            { X* p = px; px = 0; return p; }   void reset(X* p=0)      { delete px; px = p; }};*/