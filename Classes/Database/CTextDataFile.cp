// =============================================================================// CTextDataFile.cp							й1995-96, Sacred Tree Software, inc.// // Class for storing variable length blocks (usually of text) in database files.// Inherites from ADataStore. Please refer to ADataStore for additional info//// Access:// Has the following methods defined for access://	 Int32		GetRecordCount();//	 Int32		GetNewRecordID();//	 void		ReadRecord(DatabaseRec);//	 Boolean	FindRecord(DatabaseRec, LComparator);//	 void		AddRecord(DatabaseRec);//	 void		UpdateRecord(DatabaseRec);//	 void		DeleteRecord(Int32);//	 Int32		GetRecordSize(Int32);// Plus can be accessed sequentially as iterated list using://	 void		AttachIterator(LListIterator *inIterator);//	 void		DetachIterator(LListIterator *inIterator);//// DatabaseRec is a structure that begins with recPos, recSize, recID, and has// other indeterminate data in recData. //// Read is different than Find because Read has the id and fills in the data,// and Find has the data and fills in the id that matches that data using the// Comparator object specified.//// CTextDataFile does not use an index file, instead, the ID is the file pos. //// the BatchMode() function allows you to turn on and off a batch mode that// defers all sorts until turned off. This allows batch additions and deletions// to take place much faster. Some examples of this would be importing records// or duplicating or deleting a set of records.//// The Read(), Update() and Delete() functions will all cause an exception if// the requested record is not found. Find() will return false if not found.//// version 1.5.1//// created:   6/29/95, ERZ// modified:  7/27/95, ERZ	Changes to inherit from ADataStore & LFileStream// modified:  1/30/96, ERZ  CW 8 mods, mostly in LComparator related stuff// modified:  3/29/96, ERZ	rewrote Initialization process, added OpenNew() & OpenExisting()// modified:  7/24/96, ERZ	ver 1.5, simplified initialization process, platform independant// modified:  8/12/96, ERZ	changed OpenExisting() param order to match ::ResolveAlias()//// =============================================================================#include <UException.h>#include <UMemoryMgr.h>#include "CTextDataFile.h"#define kAllocationBlockSize 2048		// allocate space in file in 2k blocks#define kDeletedRecID		  -1		// record id of a deleted record#pragma options align=mac68ktypedef struct TextDataFileHeaderT {	// matches header structure of other dbfiles	Int32		itemSize;				// # bytes per item slot ( always -1 )		CDataFile	Int32		itemCount;				// # items in use (number of slots used)	Int32		allocatedSlots;			// # slots allocated to file (always itemCount+1)	Int32		allocBlockSize;			// bytes to allocate at once	Int32		firstItemPos;			// file position of first item slot	Int32		numValidRecs;			// # valid records in the datafile	Int32		allocatedBytes;			// space allocated to file					CVarDataFile	Int32		bytesUsed;				// space used in file	Int32		largestRecSize;			// size of the largest record in the datafile	Int32		firstDeletedSlotPos;	// position of first deleted slot			CTextDataFile} TextDataFileHeaderT, *TextDataFileHeaderPtr, **TextDataFileHeaderHnd, **TextDataFileHeaderHdl;#pragma options align=resettypedef struct TextSegmentT {	union {		RecIDT	recID;				// negative if deleted segment		Int32	recPos;				// rec ID is also the record position		Bool32	isFirstSegment;		// 0 (false) if not the first segment of the text block 	};	Int32		nextSegmentPos;		// 0 if final segment of text block	Int32		segmentSize;		// size of data in this segment (not including header)	union {		Int32	recSize;			// allocated size of DatabaseRec* to hold data from all segments		Int32	firstSegmentPos;	// points to first segment if extra seg		RecIDT	segRecID;			// first seg position is also the recID	};	char		segmentData[];		// start of segment data (no fixed size)} TextSegmentT, *TextSegmentPtr, **TextSegmentHnd, **TextSegmentHdl;#if DB_V15CTextDataFile::CTextDataFile(Int16 inStrcResID): ADataStore(inStrcResID), LFileStream() {	mItemCount = 0;	mAllocBlockSize = kAllocationBlockSize;		// number of bytes to allocate at a time	mFirstItemPos = kDataFileHeaderSize;		// file position of first item slot	mNumValidRecs = 0;							// # valid records in the datafile	mAllocatedBytes = 0;						// space allocated to slots in file	mBytesUsed = 0;								// space used in file	mLargestRecSize = 0;						// size of the largest record in the datafile	mFirstDeletedSlotPos = 0;					// location of first deleted slot in datafile	mLastItemFetchedNum = 0;					// no buffered item from FetchItemAt()	mLastItemFetchedPos = mFirstItemPos;	itsStream = this;							// save stream ptr for ADataStore to use}void	CTextDataFile::OpenNew(FSSpec &inFileSpec, OSType inCreator, Int16 inPrivileges) {	handle h = ::GetResource('Strc', mStrcResID);	// this will find the app's 'Strc' resource	h.lock();	UStructure* theStruct = MakeStructureObject((StrcResPtr)*h);	SetStructure(theStruct);	SetSpecifier(inFileSpec);	CreateNewFile( inCreator, 'DatF' );		// create file  #if _MacOS								// in MacOS, we are going to add the Strc res to the	OpenResourceFork(fsWrPerm);				// file, so other apps can determine the structure	::UseResFile(mResourceForkRefNum);		// just making sure we put it in the correct res fork	::DetachResource(h);	::AddResource(h, 'Strc', 0, "\p");		// add it as ID 0 so it will be easy to find	::WriteResource(h);	CloseResourceFork();  #endif	// MacOS	h.disposeResource();		// use disposeResource() rather than dispose()	OpenDataFork(inPrivileges);	SetTypeAndVersion('data', 0x10000000);	// defaults for new file	ThrowIf_( Open() );			// Open() should always return false for a new file}#else // no ver 1.5CTextDataFile::CTextDataFile() : ADataStore(),  LFileStream() {	mItemCount = 0;	mAllocBlockSize = kAllocationBlockSize;		// number of bytes to allocate at a time	mFirstItemPos = kDataFileHeaderSize;		// file position of first item slot	mNumValidRecs = 0;							// # valid records in the datafile	mAllocatedBytes = 0;						// space allocated to slots in file	mBytesUsed = 0;								// space used in file	mLargestRecSize = 0;						// size of the largest record in the datafile	mFirstDeletedSlotPos = 0;					// location of first deleted slot in datafile	mLastItemFetchedNum = 0;					// no buffered item from FetchItemAt()	mLastItemFetchedPos = mFirstItemPos;	itsStream = this;							// save stream ptr for ADataStore to use}void	CTextDataFile::OpenNew(FSSpec &inFileSpec, OSType inCreator, Int16 inPrivileges) {	SetSpecifier(inFileSpec);	CreateNewDataFile( inCreator, 'DatF' );		//create file	OpenDataFork( inPrivileges );	ThrowIf_( Open() );			// Open() should always return false for a new file}#endif // no ver 1.5#if _MacOS//еее OS DEPENDENCY herevoid	CTextDataFile::OpenExisting(FSSpec *inFromFile, AliasHandle inAlias, Boolean *outAliasWasChanged,							Int16 inPrivileges) {	FSSpec theMacFileSpec;	OSErr err = ::ResolveAlias(inFromFile, inAlias, &theMacFileSpec, outAliasWasChanged);	ThrowIfOSErr_(err);	OpenExisting(theMacFileSpec, inPrivileges);}#endifvoid	CTextDataFile::OpenExisting(FSSpec &inFileSpec, Int16 inPrivileges) {	SetSpecifier(inFileSpec);#if DB_V15	// don't include unless we want 1.5 enhancements	handle h;  #if _MacOS								// in MacOS, there will be a Strc res with id 0	OpenResourceFork(fsWrPerm);				// in the resource fork of the document, so	h = ::GetResource('Strc', 0);			// look for it there first  #endif	// MacOS  	if (h == nil)		h = ::GetResource('Strc', mStrcResID);	// this will find the app's 'Strc' resource	h.lock();	UStructure* theStruct = MakeStructureObject((StrcResPtr)*h);	// define the record structure from the 	SetStructure(theStruct);  #if _MacOS		CloseResourceFork();		// MacOS, close res fork  #endif	h.disposeResource();		// use disposeResource() rather than dispose()#endif	// end 1.5 enhancements	OpenDataFork( inPrivileges );	Boolean fileWasOpen = Open();	mLastItemFetchedNum = 0;					// no buffered item from FetchItemAt()	mLastItemFetchedPos = mFirstItemPos;	if ( mItemCount < mNumValidRecs )		Throw_( dbDataCorrupt );	if ( (mAllocatedBytes < mBytesUsed) || (mAllocatedBytes < 0) )		Throw_( dbDataCorrupt );	if ( kFileIsOpen == fileWasOpen)		Throw_( dbFileLeftOpen );	//fail if file open marker set}#pragma mark-inline Uint32CTextDataFile::GetCount() const {	return mNumValidRecs;}Uint32CTextDataFile::GetRecordCount() const {	return mNumValidRecs;}// just get segment headerBoolean	CTextDataFile::FetchItemAt(IndexT inAtIndex, void *outItem) {	Uint32 itemSize = sizeof(TextSegmentT);	return FetchItemAt(inAtIndex, outItem, itemSize);}Boolean	CTextDataFile::FetchItemAt(IndexT	inAtIndex, void	*outItem, Uint32 &ioItemSize) {	Int32 recPos = mFirstItemPos;	Int32 recNum = 0;	long endPos;	Boolean found = true;	TextSegmentT segHeader;	endPos = GetLength();						// find out where the file ends	if (mLastItemFetchedNum <= inAtIndex) {		// take advantage of previous Fetch if possible		recPos = mLastItemFetchedPos;		recNum = mLastItemFetchedNum;	};	while (recNum < inAtIndex) {		if ((recPos + sizeof(TextSegmentT)) < endPos) {			// are we at the end of stream?			SetMarker(recPos, streamFrom_Start); 		// no: check segment			ReadBlock(&segHeader, sizeof(TextSegmentT));	  	}		else {								// end of stream reached: no record found			found = false;				break;							// don't look past EOF or it will generate an exception		};		if (segHeader.isFirstSegment) {					// see if the segment is start of a record			if ( segHeader.recID == recPos )			// does the id match the file position?				recNum++;								// found another first seg, inc rec count			else if (segHeader.recID != kDeletedRecID)	// make sure we are reading a segment				Throw_ ( dbDataCorrupt );				// if not we have a data corruption problem		};		if (recNum == inAtIndex)							// did we find the record?			recPos += sizeof(TextSegmentT) + segHeader.segmentSize;	// no: get next segment	};	if (found) {		DatabaseRec *recP = (DatabaseRecPtr) outItem;		recP->recID = segHeader.recID;		recP->recSize = segHeader.recSize;				// assume buffer allocated to ioItemSize		if (ioItemSize < recP->recSize)			recP->recSize = ioItemSize;					// don't overflow buffer		ioItemSize = recP->recSize;		ReadSegments(recPos, (char*)&recP->recData, recP->recSize - sizeof(DatabaseRec) );		mLastItemFetchedPos = recPos;		// save the last pos & num for next call		mLastItemFetchedNum = recNum;		// calls will usually be sequential, ie: rec# 1, rec# 2...	};	return (found);}RecIDT CTextDataFile::GetNewRecordID(DatabaseRec */*inRecP*/) {	mLastRecID = mBytesUsed + mFirstItemPos;	return (mLastRecID);}// ReadRecord( DatabaseRec* )// IN: recID = valid ID# of existing record that you want read, //	  recSize = allocated size of buffer, or 0 if you are sure your buffer is big enough//	  {you can pre-flight buffer allocation with GetRecordSize() }// OUT: recPos = location stored in file, recSize = allocation size of DatabaseRecPtr for recvoidCTextDataFile::ReadRecord(DatabaseRec *ioRecP) {	TextSegmentT segHeader;	Int32 recPos = ioRecP->recID;	Int32 recSize;	SetMarker(recPos, streamFrom_Start);		// read in the segment header	ReadBlock(&segHeader, sizeof(TextSegmentT));	if ( segHeader.recID != ioRecP->recID )		Throw_ ( dbInvalidID );					// make sure we are reading 1st seg of valid record	recSize = segHeader.recSize;		if ( (0 != ioRecP->recSize) && (ioRecP->recSize < recSize) )		recSize = ioRecP->recSize;				// don't overflow buffer	ioRecP->recSize = recSize;					// return allocation size for DatabaseRecPtr	ioRecP->recPos = recPos;	ReadSegments(recPos, (char*)(&ioRecP->recData), recSize - sizeof(DatabaseRec) );}// FindRecord( DatabaseRec* {, LComparator} )// IN: recData = data to search for using comparator (or default cmprtr if not passed in)//	  recSize = 0 if you've allocated your buffer using GetRecordSize(0) to get size of //	  largest record, or recSize = allocated size of buffer.// OUT: recID = id # of first match, recSize = bytes of buffer used to hold record//	  recPos = position of record in datafile, recData = data of record//	returns true if foundBooleanCTextDataFile::FindRecord(DatabaseRec *ioRecP, LComparator *inComparator) {	Int32 recPos = mFirstItemPos;	Int32 recNum = 0;	long endPos;	TextSegmentT segHeader;	endPos = GetLength();						// find out where the file ends	Boolean found = false;#if DB_V15	temp_buffer(DatabaseRec, recP, mLargestRecSize); // allocate read buffer disposed automatically#else // no DB_V15	StHandleBlock buff(mLargestRecSize, true, true); // throw if fail,allocate in temp	StHandleLocker theLockSaver(buff);			// lock temporary buffer	DatabaseRecPtr recP = (DatabaseRec*) (*(Handle)buff);#endif // no DB_V15	if (NULL == inComparator)		inComparator = itsDefaultComparator;	// use one of the comparators//	inComparator->AddUser(this);				// needs to know we are using it еее CW 8 mod	while (recNum < mNumValidRecs) {		if ((recPos + sizeof(TextSegmentT)) < endPos) {			// are we at the end of stream?			SetMarker(recPos, streamFrom_Start); 		// no: check segment			ReadBlock(&segHeader, sizeof(TextSegmentT));	  	}		else {								// end of stream reached: no record found			found = false;				break;							// don't look past EOF or it will generate an exception		};		if (segHeader.isFirstSegment) {					// see if the segment is start of a record			if ( segHeader.recID == recPos ) {			// does the id match the file position?				recNum++;								// found another first seg, inc rec count				recP->recPos = recPos;				recP->recID = segHeader.recID;				if (segHeader.recSize > mLargestRecSize)	// don't overflow our buffer					recP->recSize = mLargestRecSize;				else					recP->recSize = segHeader.recSize;		// get the total record size				ReadSegments(recPos, (char*)&recP->recData, recP->recSize-sizeof(DatabaseRec));				if (inComparator->IsEqualTo(ioRecP, recP, recP->recSize, recP->recSize) ) {						// compare curr rec to the source  еее CW 8 mod - added sizes					found = true;					ioRecP->recPos = recPos;				// return found recPos in DatabaseRec*					if (recP->recSize < ioRecP->recSize)						ioRecP->recSize = recP->recSize;	// return found recSize in DatabaseRec*					UInt8 *dst = (UInt8*)&ioRecP->recSize;		  			UInt8 *src = (UInt8*)&recP->recSize;		// include recSize & recID in copy		  			for (int n = ioRecP->recSize-4; n>0; n--)	// copy the data to be returned		      			*dst++ = *src++;		 			break;				}			}			else if (segHeader.recID != kDeletedRecID)	// are we reading a deleted segment?				Throw_ ( dbDataCorrupt );				// if not we have a data corruption problem		};		recPos += sizeof(TextSegmentT) + segHeader.segmentSize;	// no: get next segment	}	return (found);								// return true if found  еее CW 8 mod}// AddRecord( DatabaseRec* )// IN: recSize = allocated size of DatabaseRecPtr with text block, //	  recID = new valid id # from GetNewRecordID() or 0 for auto-assignment of new id// OUT: recPos = location stored in file// returns new ID# of recordRecIDTCTextDataFile::AddRecord(DatabaseRec *inRecP) {	TextSegmentT segHeader;	RecIDT recID = inRecP->recID;	if (0 == recID)		recID = GetNewRecordID();					// get new id if required	else if (recID != mLastRecID )					// or reject id not from last GetNewRecID()		Throw_( dbInvalidID );	inRecP->recPos = recID;							// return rec pos to caller	inRecP->recID = recID;							// return rec ID to caller	segHeader.recID = recID;	segHeader.nextSegmentPos = 0;	segHeader.recSize = inRecP->recSize;			// recSize is alloc size of DatabaseRecPtr	long textSize = inRecP->recSize - sizeof(DatabaseRec);	segHeader.segmentSize = textSize;				// segSize is size of text only, no header	AddNewEmptySlot(sizeof(TextSegmentT) + textSize);	// create new segment at the end of stream	SetMarker(recID, streamFrom_Start);				// move to location specified by recID	WriteBlock(&segHeader, sizeof(TextSegmentT));	// write the segment header	WriteBlock(&inRecP->recData, textSize);			// write the data	mNumValidRecs += 1;								// one more valid record	if (!mBatchMode)		WriteHeader();	return(recID);									// return the new ID assigned}// UpdateRecord( DatabaseRec* )// IN: recSize = allocated size of DatabaseRecPtr, recID = valid id # of existing record// OUT: recPos = location stored in file, recSize = unchangedvoidCTextDataFile::UpdateRecord(DatabaseRec *inRecP) {	TextSegmentT segHeader;	Int32 bytesWritten = sizeof(DatabaseRec);	Int32 recPos = inRecP->recID;	inRecP->recPos = recPos;						// return the record position 	Int32 nextRecPos;	Int32 lastRecPos;	Int32 recSize = inRecP->recSize;	if (mLargestRecSize < recSize)					// is this larger than our previous largest?		mLargestRecSize = recSize;	Int32 oldRecSize;	long byteCount;	char *buffPos = (char*)&inRecP->recData;		// start getting data from recData	SetMarker(recPos, streamFrom_Start);	ReadBlock(&segHeader, sizeof(TextSegmentT));	if ( segHeader.recID != inRecP->recID )		Throw_ ( dbInvalidID );						// ensure we are reading 1st seg of valid record	oldRecSize = segHeader.recSize; 							// save old size for later compare	segHeader.recSize = recSize;								// store new size in the segment	SetMarker(recPos, streamFrom_Start);						// write out the revised seg header	WriteBlock(&segHeader, sizeof(TextSegmentT));	do {		nextRecPos = segHeader.nextSegmentPos;					// get next segment		if (recSize > bytesWritten) {							// if we need to write more data:			byteCount = segHeader.segmentSize;					// how many byte can we write?			bytesWritten += byteCount;							// written that many more			if (bytesWritten >= recSize) {						// segment bigger than need:				byteCount -= bytesWritten - recSize;			// only write needed bytes				segHeader.nextSegmentPos = 0;					// mark segment as final segment				SetMarker(recPos, streamFrom_Start);				WriteBlock(&segHeader, sizeof(TextSegmentT));	// write out revised segment header			};			WriteBlock(buffPos, byteCount ); 					// write the data			buffPos += byteCount;								// advance the buffer pointer		}		else {													// no more data to write: delete seg			segHeader.nextSegmentPos = mFirstDeletedSlotPos;	// add to deleted linked list			mFirstDeletedSlotPos = recPos;			segHeader.recID = kDeletedRecID;					// mark segment with deleted id			SetMarker(recPos, streamFrom_Start);			WriteBlock(&segHeader, sizeof(TextSegmentT));		// write out revised segment header		}		lastRecPos = recPos;									// save current segment pos		recPos = nextRecPos;									// get the next segment		if (0 != recPos) {			SetMarker(recPos, streamFrom_Start);			ReadBlock(&segHeader, sizeof(TextSegmentT));		// read next segment header			if (segHeader.isFirstSegment)						// validity check:				Throw_( dbDataCorrupt );						// ensure reading extra segment			if (segHeader.firstSegmentPos != inRecP->recID)		// validity check: 				Throw_( dbDataCorrupt );						// ensure reading part of same record		};	} while (0 != recPos);							// stop when no more segments to read	if (recSize > bytesWritten) { 					// What!? More to write? Record must have grown		byteCount = recSize - bytesWritten;  		// find deleted slot larger than leftover data		recPos = mFirstDeletedSlotPos;				// start with the first deleted slot of course		Int32 prevRecPos = 0;		TextSegmentT prevSegHeader;		TextSegmentT currSegHeader;		while (0 != recPos) {			SetMarker(recPos, streamFrom_Start);			ReadBlock(&currSegHeader, sizeof(TextSegmentT));// read next deleted segment header			if ( currSegHeader.recID > kDeletedRecID )		// validity check:				Throw_ ( dbDataCorrupt );					// ensure we are reading deleted seg			if (currSegHeader.segmentSize >= byteCount) {	// is it big enough?				segHeader.nextSegmentPos = recPos;			// maintain the record's linked-list				SetMarker(lastRecPos, streamFrom_Start);				WriteBlock(&segHeader, sizeof(TextSegmentT));				if (0 != prevRecPos) {						// maintain the deletion linked-list					prevSegHeader.nextSegmentPos = currSegHeader.nextSegmentPos;					SetMarker(prevRecPos, streamFrom_Start);					WriteBlock(&prevSegHeader, sizeof(TextSegmentT));	// update previous deletion				}				else 					mFirstDeletedSlotPos = currSegHeader.nextSegmentPos; // or update first deletion				segHeader.segmentSize = currSegHeader.segmentSize;	// need the segment size				break;										// segment found, now go write the data			}			prevRecPos = recPos;							// not found: keep looking			prevSegHeader.recID = currSegHeader.recID;		// save prev for linked-list maintance			recPos = currSegHeader.nextSegmentPos;			// get next deleted slot			prevSegHeader.nextSegmentPos = recPos;			prevSegHeader.recSize = currSegHeader.recSize;			prevSegHeader.segmentSize = currSegHeader.segmentSize;				}		if (0 == recPos) {									// if that doesn't work, try adding a			recPos = AddNewEmptySlot(sizeof(TextSegmentT) + byteCount);	// new segment to end			segHeader.nextSegmentPos = recPos;				// maintain the record's linked-list			SetMarker(lastRecPos, streamFrom_Start);			WriteBlock(&segHeader, sizeof(TextSegmentT));			segHeader.segmentSize = byteCount;				// new seg size is the # remaining bytes		}		segHeader.nextSegmentPos = 0;				 		// no more segments in this record		segHeader.isFirstSegment = false;					// not the first segment		segHeader.segRecID = inRecP->recID;					// specify record ID # (and 1st seg pos)		SetMarker(recPos, streamFrom_Start);		WriteBlock(&segHeader, sizeof(TextSegmentT));		// write final segment header		WriteBlock(buffPos, byteCount);						// write data block	}}voidCTextDataFile::DeleteRecord(RecIDT inRecID) {	TextSegmentT segHeader;	Int32 recPos = inRecID;				  				// the ID is the file pos of the record	Int32 oldFirstDeletedPos = mFirstDeletedSlotPos;	while (0 != recPos) {					 			// mark all segments as deleted		SetMarker(recPos, streamFrom_Start);		ReadBlock(&segHeader, sizeof(TextSegmentT));	// read segment header		if (recPos == inRecID) {			 if (segHeader.recID != inRecID)			// validity check:			 	Throw_ ( dbInvalidID ); 				// make sure we are reading 1st segment			 mFirstDeletedSlotPos = recPos;				// this is our new first deleted segment		}		else if (segHeader.firstSegmentPos != inRecID)			Throw_ ( dbDataCorrupt );					//are we reading valid seg?		SetMarker(recPos, streamFrom_Start);			// reposition for write		recPos = segHeader.nextSegmentPos;				// get pos of next segment for read		if (0 == recPos)								// make last seg point to deleted segs			 segHeader.nextSegmentPos = oldFirstDeletedPos;		segHeader.recID = kDeletedRecID;				// mark segment as deleted		WriteBlock(&segHeader, sizeof(TextSegmentT));	// write deleted segment header	}	mNumValidRecs -= 1;	if (!mBatchMode)		WriteHeader();}Int32CTextDataFile::GetRecordSize(RecIDT inRecID) {	if (0 == inRecID)		return(mLargestRecSize);					// includes fields of DatabaseRec	TextSegmentT segHeader;	Int32 recPos = inRecID;							// the ID is the file pos of the record	SetMarker(recPos, streamFrom_Start);	ReadBlock(&segHeader, sizeof(TextSegmentT));	// read segment header	if (segHeader.recID != inRecID)		Throw_( dbInvalidID );						// make sure we are reading 1st segment	return (segHeader.recSize);						// return the size to allocate}Uint32CTextDataFile::AddNewEmptySlot(Int32 inSize) {	if (inSize > mLargestRecSize)		mLargestRecSize = inSize;			// keep track of largest record	mItemCount++;	Uint32 oldBytesUsed = mBytesUsed;	mBytesUsed += inSize;	if (mBytesUsed >= mAllocatedBytes) {		mAllocatedBytes = mBytesUsed + kAllocationBlockSize;		Uint32 fileSize = mFirstItemPos + mAllocatedBytes;		SetLength(fileSize);						// expand file		if (!mBatchMode)			WriteHeader();							// write new # slots, etc.. in disk file header	}	Uint32 recPos = oldBytesUsed + mFirstItemPos;	TextSegmentT segHeader;	segHeader.isFirstSegment = false;	segHeader.segmentSize = inSize - sizeof(TextSegmentT);	segHeader.nextSegmentPos = 0;	segHeader.segRecID = 0;	SetMarker(recPos, streamFrom_Start);	WriteBlock(&segHeader, sizeof(TextSegmentT));	// write segment header for our empty segment	return recPos;}Boolean	CTextDataFile::ReadHeader() {	Boolean result = ADataStore::ReadHeader();	TextDataFileHeaderT tempHeader;	ReadBlock(&tempHeader, sizeof(TextDataFileHeaderT));	mItemCount = tempHeader.itemCount;				// # items in use (number of slots used)	mAllocBlockSize = tempHeader.allocBlockSize;	// bytes to allocate at once	mFirstItemPos = tempHeader.firstItemPos;		// file position of first item slot	mNumValidRecs = tempHeader.numValidRecs;		// # valid records in the datafile	mAllocatedBytes = tempHeader.allocatedBytes;	// space allocated to file			CVarDataFile	mBytesUsed = tempHeader.bytesUsed;				// space used in file	mLargestRecSize = tempHeader.largestRecSize;	// size of the largest record in the datafile	mFirstDeletedSlotPos = tempHeader.firstDeletedSlotPos;	// position of first deleted slot			CTextDataFile	if ( tempHeader.itemSize != -1 )		Throw_( dbSizeMismatch );	return(result);}voidCTextDataFile::WriteHeader(Boolean inFileOpen) {	ADataStore::WriteHeader(inFileOpen);	TextDataFileHeaderT tempHeader;	tempHeader.itemSize = -1;						// # bytes per item slot ( always -1 )		CDataFile	tempHeader.itemCount = mItemCount;				// # items in use (number of slots used)	tempHeader.allocatedSlots = mItemCount+1;		// # slots allocated to file (always itemCount+1)	tempHeader.allocBlockSize = mAllocBlockSize;	// bytes to allocate at once	tempHeader.firstItemPos = mFirstItemPos;		// file position of first item slot	tempHeader.numValidRecs = mNumValidRecs;		// # valid records in the datafile	tempHeader.allocatedBytes = mAllocatedBytes;	// space allocated to file					CVarDataFile	tempHeader.bytesUsed = mBytesUsed;				// space used in file	tempHeader.largestRecSize = mLargestRecSize;	// size of the largest record in the datafile	tempHeader.firstDeletedSlotPos = mFirstDeletedSlotPos;	// position of first deleted slot			CTextDataFile	WriteBlock(&tempHeader, sizeof(TextDataFileHeaderT));}voidCTextDataFile::ReadSegments(Uint32 pos, char *buffer, Int32 bytes) {	TextSegmentT segHeader;	Int32 segSize;	do {		if (0 == pos) 								// reached end of segments before end of bytes			Throw_( dbDataCorrupt );		SetMarker(pos, streamFrom_Start);			// read in the current segment header		ReadBlock(&segHeader, sizeof(TextSegmentT));		segSize = segHeader.segmentSize;			// get the size of the current segment		if (bytes < segSize )						// only read to end of buffer			segSize = bytes;		ReadBlock(buffer, segSize);					// read segSize bytes into buffer		buffer += segSize;							// advance buffer pointer		bytes -= segSize;							// fewer bytes remaining to be read		pos = segHeader.nextSegmentPos;				// get position of next segment in sequence	} while (bytes > 0);							// read till all bytes read in}voidCTextDataFile::Close() {	ADataStore::Close();	CloseDataFork();}