// =============================================================================// CDataFile.h							 ©1995-2002, Sacred Tree Software, inc.// // Class for fixed size record database files. //// version 1.5.9//// created:   6/16/95, ERZ// modified:  7/25/95, ERZ	extensive changes to use AMasterIndex// modified:  3/29/96, ERZ	rewrote Initialization process, added OpenNew() & OpenExisting()// modified:  4/14/96, ERZ	added file permissions as optional params to Open methods// modified:  7/24/96, ERZ	v1.5, simplified initialization process, platform independant// modified:  8/12/96, ERZ	changed OpenExisting() param order to match ::ResolveAlias()// modified:  8/14/96, ERZ	Thread support// modified: 12/27/96, ERZ	removed inherited virtual method FetchItemAt(IndexT, void*)// modified:  2/21/98, ERZ	v1.5.5, added mReadOnly field to fix bug of writing to Read//								only files// modified:  9/26/98, ERZ	v1.5.6, Added RecordExists(RecIDT), IsReadOnly() virtual//								methods, added GetPrivileges() method, and removed file//								privileges from OpenNew(), which must be Exclusive Read/Write// modified:  5/27/02, ERZ  v1.5.7, converted to bool from MacOS Boolean, removed class typedefs// modified:  9/24/05, ERZ  v1.5.8, added Backup() to create backup version of files// modified: 10/23/05, ERZ  v1.5.9, changed to use platform neutral CFileStream instead of LFileStream//// =============================================================================#ifndef CDATAFILE_H_INCLUDED#define CDATAFILE_H_INCLUDED#include "ADataStore.h"#include "AMasterIndexable.h"#include "CFileStream.h"class CDataFile : public ADataStore, public CFileStream, public AMasterIndexable {public:	#if DB_V15		CDataFile(SInt16 inStrcResID = resID_Undefined);		virtual void			SetStructure(UStructure* inStructure);		virtual AMasterIndex*	MakeMasterIndex();	#else		CDataFile(SInt32 inItemSize, AMasterIndex *inMasterIndex);	#endif		virtual void        Backup(const char* appendToFilename);		virtual bool	    IsFixedSize() {return true;}			void	OpenNew(const char* inPath, const char* inName, const char* inCreator = "????");	// creates and initializes new data file	void	OpenExisting(const char* inPath, const char* inName, int inPrivileges = CFileStream::privileges_ReadWrite);	virtual void		Close();	virtual bool		SetBatchMode(bool inBatchMode);	virtual bool		IsReadOnly() const {return mReadOnly;}	int				    GetPrivileges() const {return mPrivileges;}	// data access methods	virtual UInt32		GetRecordCount() const;	virtual void		ReadRecord(DatabaseRec *ioRecP);	virtual bool		FindRecord(DatabaseRec *ioRecP, LComparator *inComparator = (LComparator*)NULL);	virtual RecIDT		AddRecord(DatabaseRec *inRecP);	virtual void		UpdateRecord(DatabaseRec *inRecP);	virtual void		DeleteRecord(SInt32 inRecID);	virtual SInt32		GetRecordSize(SInt32 inRecID = 0);	virtual bool		RecordExists(RecIDT inRecID);// list iteration methods	virtual UInt32		GetCount() const;	virtual bool		FetchItemAt(IndexT	inAtIndex, void	*outItem, UInt32 &ioItemSize);		protected:	virtual UInt32		AddNewEmptySlot(SInt32 inSize);	virtual void		MarkSlotDeleted(UInt32 inSlotPos, RecIDT recID);    virtual RecIDT      GetRecordAtSlot(UInt32 inSlotPos);		virtual bool		ReadHeader();	virtual void		WriteHeader(bool inFileOpen = true);	SInt32		mItemSize;	UInt32		mItemCount;	UInt32		mAllocatedSlots;	SInt32		mAllocBlockSize;	// num slots to allocate at once	SInt32		mFirstItemPos;	UInt32		mNumValidRecs;	bool		mReadOnly;			// v1.5.5 addition 	SInt16		mPrivileges;		// v1.5.6 addition};#endif // CDATAFILE_H_INCLUDED