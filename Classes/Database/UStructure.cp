// =============================================================================// UStructure.cp								©1996, Sacred Tree Software, inc.// // UStructure is a class for managing structure info for a view of a database// Written to be compiled under MacOS or Win32//// version 1.3, MacOS compiled and tested, Win32 compiled but not tested//// created:   7/23/96, ERZ// modified://// =============================================================================#include "UStructure.h"#include "UFieldComparators.h"#include "handle.h"		// cross platform handle class/*	 general internal structure of a record:	    ========================		 Header:			Int32	recPos;		// never stored in physical record, only in mem struct			Int32	recSize;	// stored for variable length files, not stored if fixed length			RecIDT	recID;		========================		 Flags:					// if there are flags defined for this view in the structure		 	char	flagBytes[];	// an array of bytes sufficient to hold all flags as bits		========================		 Fixed Length Fields:		 	char	fieldData[1][];	// array of bytes that holds data for field 1		 	char	fieldData[2][];	// array of bytes for field 2 data			...						// more arrays for more fields...		========================		 Var Length Field Pointers:		 	long	offset[1];		// offset from start of rec to start of variable length field 1		 	long	offset[2];		// offset to start of data for variable length field 2		 	...						// more offsets for more variable length fields...		========================		 Var Length Field Data:		 	char	data[];			// byte array that holds data for all variable length fields		 		NOTE: the fields are referenced by number, as defined in the 'Strc' resource, however, this		number does NOT represent their actual order in the data as stored. On opening a datafile,		the UStructure class should be told to build an array of FieldXInfo that has the offsets		to the fields of the record. The UStructure class will therefore ultimately determine		the storage order of the fields, in accordance with the general internal record structure		as described above.			ALSO NOTE:, the three Header fields are recognized as: recID = field # 0; recSize = field # -1; 		recPos = field # -2. They should not be defined in the 'Strc' resource, as they will be		added automatically.*/// *******  IMPORTANT  ********//// if you want to create new field types for your database, here's how you do it://// 1. define a new subclass of UFieldTypeInfo as follows:////		typedef class UMyFieldTypeInfo : public UFieldTypeInfo {//		public://			static void	Init();//			.....					// override other functions as needed//		}////// 2. implement the Init() static function to assign a new instance of your class to the//    static member variable sFieldTypeInfo as follows:////		void //		UMyFieldTypeInfo::Init() {//			sFieldTypeInfo = new UMyFieldTypeInfo();//		}////// 3. call your new static Init function in your program initialization, before you call any//	  database functions. ie:////		main() {//			DoSystemInit();				// init MacToolBox, etc...//			...//			UMyFieldTypeInfo::Init();	// init our structure info//			....//			DoDatabaseStuff();			// now you can do whatever you want//		}UFieldTypeInfo*		UFieldTypeInfo::sFieldTypeInfo = (UFieldTypeInfo*)nil;UFieldTypeInfo::UFieldTypeInfo() {	// default constructor, nothing to do here}// called automatically by UStructure to make sure field type info is availablevoidUFieldTypeInfo::Init() {	if (!sFieldTypeInfo)		sFieldTypeInfo = new UFieldTypeInfo();}// override this method if you want to define additional field types with default sizes// not necessary to override to define new variable size field typesvoidUFieldTypeInfo::SetFieldDefaultSize(EFieldType inFieldType, Int32 &ioFieldSize) const {	switch (inFieldType) {		case fieldType_Flag:			ioFieldSize = 0;			break;		case fieldType_LongLong:			ioFieldSize = sizeof(Int32)+sizeof(Int32);	// long long (64bit data type)			break;		case fieldType_Long:		case fieldType_Fixed:			ioFieldSize = sizeof(Int32);			break;		case fieldType_Short:			ioFieldSize = sizeof(Int16);			break;		case fieldType_Char:		case fieldType_Bool:			ioFieldSize = sizeof(Int8);			break;		case fieldType_Float:			ioFieldSize = sizeof(float);			break;		case fieldType_Double:			ioFieldSize = sizeof(double);			break;		case fieldType_LongDouble:			ioFieldSize = sizeof(long double);			break;		case fieldType_RecID:			ioFieldSize = sizeof(RecIDT);			break;		case fieldType_Data:	// these are all variable sized		case fieldType_SmallData:		case fieldType_TinyData:		case fieldType_Text:		case fieldType_PString:			if (ioFieldSize < 1)				ioFieldSize = fieldSize_Variable;	// default variable sized, if they haven't			break;					//  been defined in the Strc resource to have a fixed length		default:			if (ioFieldSize != fieldSize_Variable)	// if we don't know what it is, and it isn't				ioFieldSize = fieldSize_Undefined;	// defined in the Strc res as variable  				break;									// length, we won't allocate space for it.	}}// Override this method if you want to define additional variable length field types that // don't need a 32 bit value to store their length.// It is not necessary to override it to define new fixed size field typesvoidUFieldTypeInfo::SetFieldLengthSize(EFieldType inFieldType, Int8 &ioLengthSize) const {	switch (inFieldType) {		case fieldType_SmallData:			// store size in a short		case fieldType_Text:			ioLengthSize = sizeof(Int16);			break;		case fieldType_TinyData:			// store size in a byte		case fieldType_PString:			ioLengthSize = sizeof(UInt8);			break;		case fieldType_Data:				// store size in a long		default:			ioLengthSize = sizeof(UInt32);	// assume all other variable length fields are				break;							// of the maximum possible length	}}// override this method to return the appropriate default comparator for the data typeLComparator*UFieldTypeInfo::GetFieldComparator(EFieldType inFieldType) const {	LComparator* theComp = (LComparator*) nil;	switch (inFieldType) {		case fieldType_LongLong:			theComp = ULongLongComparator::GetComparator();	// 64bit data type			break;		case fieldType_Long:			theComp = ULongComparator::GetComparator();			break;		case fieldType_Fixed:			theComp = UFixedComparator::GetComparator();			break;		case fieldType_Short:			theComp = UShortComparator::GetComparator();			break;		case fieldType_Char:			theComp = UCharComparator::GetComparator();			break;		case fieldType_Flag:		case fieldType_Bool:			theComp = UBoolComparator::GetComparator();			break;		case fieldType_Float:			theComp = UFloatComparator::GetComparator();			break;		case fieldType_Double:			theComp = UDoubleComparator::GetComparator();			break;		case fieldType_LongDouble:			theComp = ULongDoubleComparator::GetComparator();			break;		case fieldType_RecID:			theComp = URecIDComparator::GetComparator();			break;		case fieldType_Data:		case fieldType_SmallData:		case fieldType_TinyData:			theComp = UDataComparator::GetComparator();			break;		case fieldType_Text:			theComp = UTextComparator::GetComparator();			break;		case fieldType_PString:			theComp = UStrComparator::GetComparator();			break;		default:			break;	}	return theComp;}#pragma mark-UStructure::UStructure(StrcResPtr inStrcRecP) {	UFieldTypeInfo::Init();								// ensure the field type info is available	mFieldTypeInfo = UFieldTypeInfo::sFieldTypeInfo;	// then store a ref to it for later use	mNumFlags = 0;	mNumVarFields = 0;	mNumFixedFields = 0;	mNameSTR_ID = resID_Undefined;	mNamesSTRxID = resID_Undefined;	mNewRecSize = dbRecSize_RecHeader;	if (inStrcRecP == nil)		mNumFields = 0;							// not found or none specified, make default	else		mNumFields = inStrcRecP->numFields;		// find out how many fields we have	mFieldInfo = new FieldXInfoT[mNumFields + 3];	// make field info array + header fields		for (int i = 0; i < 3; i++) {					// create header field specs:		mFieldInfo[i].fieldType = fieldType_Long;	// 3 longs		mFieldInfo[i].fieldSize = sizeof(Int32);		mFieldInfo[i].fieldOffset = i*sizeof(Int32);		mFieldInfo[i].flagMask = 0;		mFieldInfo[i].lengthSize = 0;	}	if (inStrcRecP != nil) {	// if we have a resource, set up specified field types and sizes		for (int i = 3; i < mNumFields + 3; i++) {			mFieldInfo[i].fieldType = inStrcRecP->fields[i-3].fieldType;			mFieldInfo[i].fieldSize = inStrcRecP->fields[i-3].fieldSize;			mFieldInfo[i].fieldOffset = 0;			mFieldInfo[i].flagMask = 0;			mFieldInfo[i].lengthSize = 0;		}		mNameSTR_ID = inStrcRecP->nameSTR_ResID;		mNamesSTRxID = inStrcRecP->namesSTRxResID;	}	// if we don't have a 'Strc' resource, record will have no fields except header fields	InitStructure();}UStructure::~UStructure() {	delete mFieldInfo;}voidUStructure::InitStructure() {	// calc field sizes and offsets	int i;	Int32 fSize;	Int8 lenSize;	Int32 fieldOffset = dbRecOffset_RecData;	// first, set the default sizes where needed, and use the size to determine	// how many there are of each class of field: fixed, flag, and variable	for (i = 3; i < mNumFields + 3; i++) {		fSize = mFieldInfo[i].fieldSize;		lenSize = 0;		mFieldTypeInfo->SetFieldDefaultSize(mFieldInfo[i].fieldType, fSize);		if (fSize == fieldSize_Flag)		// only flags have size 0			mNumFlags++;		else if (fSize == fieldSize_Variable) {	// variable length is -1			mFieldTypeInfo->SetFieldLengthSize(mFieldInfo[i].fieldType, lenSize);			mNumVarFields++;		} else if (fSize > 0)		// fixed size			mNumFixedFields++;		mFieldInfo[i].fieldSize = fSize;		mFieldInfo[i].lengthSize = lenSize;	}	// now calc the number of bytes needed for the flags	int flagBytes = (mNumFlags+7)/8;	// now calc offsets and masks for each flag	UInt8 flagMask = 0x01;	Int32 flagOffset = 0;	for (i = 3; i < mNumFields + 3; i++) {		if (mFieldInfo[i].fieldSize == 0) {	// found a flag			mFieldInfo[i].fieldOffset = fieldOffset + flagOffset;			mFieldInfo[i].flagMask = flagMask;			flagMask = flagMask << 1;			if (flagMask == 0) {				flagMask = 0x01;				flagOffset++;			}		}	}	fieldOffset += flagBytes;	// now calc offsets for each fixed length field	for (i = 3; i < mNumFields + 3; i++) {		fSize = mFieldInfo[i].fieldSize;		if (fSize > 0) {	// found a fixed length field			mFieldInfo[i].fieldOffset = fieldOffset;			fieldOffset += fSize;		}	}	// now calc offsets for each variable length field ptr	for (i = 3; i < mNumFields + 3; i++) {		fSize = mFieldInfo[i].fieldSize;		if (fSize == fieldSize_Variable) {	// found a variable length field			mFieldInfo[i].fieldOffset = -fieldOffset;	// always return field ptrs as negative			fieldOffset += sizeof(Int32);	// field ptr size		}	}	mNewRecSize = fieldOffset;}BooleanUStructure::ValidFieldNum(Int16 &ioFieldNum) const {	if (ioFieldNum > mNumFields)		return false;	ioFieldNum += 2;	if (ioFieldNum < 0)		return false;	else		return true;}Int32UStructure::GetFieldOffset(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		return mFieldInfo[inFieldNum].fieldOffset;	} else		return -1;}Int32UStructure::GetFieldSize(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		return mFieldInfo[inFieldNum].fieldSize;	} else		return fieldSize_Undefined;}EFieldTypeUStructure::GetFieldType(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		return mFieldInfo[inFieldNum].fieldType;	} else		return fieldType_Undefined;}UInt8UStructure::GetFlagMask(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		return mFieldInfo[inFieldNum].flagMask;	} else		return 0;}Int8UStructure::GetFieldLengthSize(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		return mFieldInfo[inFieldNum].lengthSize;	} else		return 0;}Int32UStructure::GetFieldMaxSize(Int16 inFieldNum) const {	if (ValidFieldNum(inFieldNum)) {		Int32 maxSize = mFieldInfo[inFieldNum].fieldSize;		if (maxSize == fieldSize_Variable) {			maxSize = mFieldInfo[inFieldNum].lengthSize;			switch (maxSize) {				case 1:					maxSize = 0xff;					break;				case 2:					maxSize = 0xffff;					break;				case 4:					maxSize = 0x7fffffff;					break;				default:					maxSize = 0;			}		}		return maxSize;	} else		return fieldSize_Undefined;}LComparator*UStructure::GetFieldComparator(Int16 inFieldNum) const {	EFieldType fType = GetFieldType(inFieldNum);	if (fType == fieldType_Undefined)		return (LComparator*)nil;	else		return mFieldTypeInfo->GetFieldComparator(fType);}voidUStructure::GetViewName(Str255 &outName) const {	if (mNameSTR_ID != resID_Undefined) {		handle h;		h = ::GetResource('STR ', mNameSTR_ID);	  	h.lock();		int size = (*h)[0];		h.copyto(&outName[0], size+1);		h.disposeResource();	} else		outName[0] = 0;}voidUStructure::GetFieldName(Int16 inFieldNum, Str255 &outName) const {	if (ValidFieldNum(inFieldNum) && (mNamesSTRxID != resID_Undefined)) {	  #if _MacOS		::GetIndString(outName, mNamesSTRxID, inFieldNum);	  #elif _Win32		int error; // ¥¥¥ WIN32 - UStructure::GetFieldName() NOT YET IMPLEMENTED ¥¥¥	  	// ¥¥¥ not sure how best to handle this yet.	  #elif		int error; // ¥¥¥ OTHER OS - UStructure::GetFieldName() NOT YET IMPLEMENTED ¥¥¥	  	// here's where we would do something in another system to read in resources from 	  	// a file or something.	  	#pragma error UStructure only supports MacOS and Win32 at present	  #endif	} else		outName[0] = 0;}Int16UStructure::GetNamedFieldNum(Str255 &) const {	// inName	int error; // ¥¥¥ UStructure::GetNamedFieldNum() NOT YET IMPLEMENTED ¥¥¥	// ¥¥¥ compare strings to see if name matches, return appropriate number	return 0;}