// =============================================================================// CRecord.cp								©1996-97, Sacred Tree Software, inc.// // CRecord is a class for managing a database record and its associated fields.// it depends on a UStructure class created from a 'Strc' resource to define// general field information.//// version 1.0.1 MacOS compiled and tested, Win32 compiled but not tested//// created:   7/22/96, ERZ// modified:  1/20/97, ERZ	added protected method GetFieldDataPtr()// modified:  5/27/02, ERZ  converted to bool from MacOS Boolean, removed class typedefs//// =============================================================================#include "CRecord.h"#include <LComparator.h>Int32 ExtractFieldLength(char* inFieldP, Int8 inLengthSize);void StoreFieldLength(char* inFieldP, Int8 inLengthSize, Int32 inLength);// these ridiculous functions ensure that even on little endian machines, the length is correctly// extracted from the data field, plus they allow the non-aligned accesses to a long that would// normally give the 68000 a fitInt32ExtractFieldLength(char* inFieldP, Int8 inLengthSize) {	Int32 fLen = 0;	if (inLengthSize == 1)		fLen = *inFieldP;	else if (inLengthSize == 2)		fLen = ((unsigned char)inFieldP[0] << 8) + (unsigned char)inFieldP[1];	else if (inLengthSize == 4) 		fLen = ((unsigned char)inFieldP[0] << 24) + ((unsigned char)inFieldP[1] << 16) + 				((unsigned char)inFieldP[2] << 8) + (unsigned char)inFieldP[3];	return fLen;}voidStoreFieldLength(char* inFieldP, Int8 inLengthSize, Int32 inLength) {	if (inLengthSize == 1)		*inFieldP = inLength;	else if (inLengthSize == 2) {		inFieldP[0] = (inLength >> 8);		inFieldP[1] = inLength;	} else if (inLengthSize == 4) {		inFieldP[0] = (inLength >> 24);		inFieldP[1] = (inLength >> 16);		inFieldP[2] = (inLength >> 8);		inFieldP[3] = inLength;	}}#pragma mark-CRecord::CRecord(UStructure* inStructure) {	mStructure = inStructure;	UInt32 size = mStructure->GetNewRecordSize();	mRecData.resize(size);	mRecData.lock();	DatabaseRec* p = (DatabaseRec*)*mRecData;	p->recID = 0;	p->recSize = size;	p->recPos = 0;  #ifdef DB_CLEAR_NEW_RECORDS  	for (int i = dbRecOffset_RecData; i < size; i++)  		((char*)p)[i] = 0;  #else	// Now we have to set all the field pointers to 0 so we know that these fields	// are not allocated	Int32 offset = 0;	int numFields = mStructure->GetFieldCount();			// do this by searching through	for (int i = 1; i <= numFields; i++) {					// all the fields to find var len fields		Int32 fieldPtrOffset = mStructure->GetFieldOffset(i); // which we can detect here		if (fieldPtrOffset < 0)	{							// because they have negative numbers			char* p = mRecData[-fieldPtrOffset];			// when we find one, we write a zero			::BlockMoveData(&offset, p, sizeof(Int32));		// into as the field offset, to mark it		}													// as unallocated	}  #endif	mRecData.unlock();}CRecord::CRecord(UStructure* inStructure, DatabaseRec* inDataP) {	mStructure = inStructure;	mRecData.copy(inDataP, inDataP->recSize);	// handle automatically reallocates as needed}CRecord::~CRecord() {	mRecData.dispose();	// free the memory used by the record}Int32CRecord::GetFieldSize(Int16 inFieldNum) const {	Int32 size = mStructure->GetFieldSize(inFieldNum);	if (size == fieldSize_Variable) {		Int32 offset;		CalcVarFieldSizeAndOffset(inFieldNum, size, offset);	}	return size;}// handle returned is yours to do with as you pleasehandleCRecord::GetFieldData(Int16 inFieldNum) const {	handle h;	Int32 size = GetFieldSize(inFieldNum);	if (size != fieldSize_Undefined) {		h.resize(size);		h.lock();		GetFieldData(inFieldNum, *h);		h.unlock();	}	return h;}voidCRecord::SetFieldData(Int16 inFieldNum, handle &inFieldH) {	inFieldH.lock();	SetFieldData(inFieldNum, *inFieldH, inFieldH.size());	inFieldH.unlock();}voidCRecord::GetFieldData(Int16 inFieldNum, void* ioFieldP) const {	handle h = (handle&)mRecData;	// bypass the const declaration	h.lock();	Int32 size;	void* srcP;	GetFieldDataPtr(inFieldNum, srcP, size);	if (size != fieldSize_Undefined) {			// don't bother if the field is undefined		::BlockMoveData(srcP, ioFieldP, size);	// move correct amount of data into the result ptr	}	h.unlock();}voidCRecord::SetFieldData(Int16 inFieldNum, void* inFieldP, Int16 inFieldSize) {	Int32 size = mStructure->GetFieldSize(inFieldNum);	if (size == fieldSize_Undefined)		return;		// don't bother if the field is undefined	Int32 copySize = inFieldSize;	Int32 offset = mStructure->GetFieldOffset(inFieldNum);	mRecData.lock();	if (offset >= 0) {				// fixed sized records are easy,		if ((size < copySize) || (copySize == 0))	// just move the correct amount of data			copySize = size;		// into the record at the offset specified by the UStructure		::BlockMoveData(inFieldP, mRecData[offset], copySize);	} else {						// variable sized records are more complicated:		Int32 fieldPtrOffset;		char* p;		CalcVarFieldSizeAndOffset(inFieldNum, size, offset); // first, find out how big field was		if (size == inFieldSize) {	// if sizes are the same, it's just the same as copying to a			if (offset)				// into a fixed size record, we don't need to update any				::BlockMoveData(inFieldP, mRecData[offset], size);	// field pointers or anything		} else {			Int8 lenBytes = mStructure->GetFieldLengthSize(inFieldNum);	// find out how many bytes of length info we store			Int32 recSize = mRecData.size();			Int32 lenOffset;			Int32 sizeDiff;			if (offset == 0) {					// field not currently allocated				offset = recSize + lenBytes;	// so it will be placed at the end of the record				size = 0;						// if field isn't allocated, it's size MUST be 0				fieldPtrOffset = mStructure->GetFieldOffset(inFieldNum);	// we also need to				p = mRecData[-fieldPtrOffset];	// store the field offset to this new field				lenOffset = offset - lenBytes;	// because it was stored as 0 in the record				::BlockMoveData(&lenOffset, p, sizeof(Int32));				sizeDiff = inFieldSize + lenBytes;	// grow the rec by the field size + the num of			} else {								// bytes we need to store the field length				lenOffset = offset - lenBytes;	// calculate where the length info goes				sizeDiff = inFieldSize - size;	// calculate amount to grow the field by			}			if (sizeDiff > 0) {	// we need to enlarge the record, do it before moving the data				mRecData.unlock();				mRecData.resize(recSize + sizeDiff);	// grow entire record by sizeDiff bytes				mRecData.lock();			}			Int32 fieldEnd = offset + size;			Int32 bytesToShift = recSize - fieldEnd;			if (bytesToShift > 0)				::BlockMoveData(mRecData[fieldEnd], mRecData[fieldEnd+sizeDiff], bytesToShift);			if (sizeDiff < 0) {	// we need to shrink the record, do it now that data is moved				mRecData.unlock();				mRecData.resize(recSize + sizeDiff);	// shrink entire record by sizeDiff bytes				mRecData.lock();			}			((DatabaseRec*)*mRecData)->recSize = mRecData.size();	// set the new record size			::BlockMoveData(inFieldP, mRecData[offset], inFieldSize);	// copy the data into record			StoreFieldLength(mRecData[lenOffset], lenBytes, inFieldSize); // store new length info			// Now we have to update all the field pointers that are after			// our field pointer, because we have shifted the position of those fields						int numFields = mStructure->GetFieldCount();	// do this by searching through			for (int i = 1; i <= numFields; i++) {			// all the fields to find var len fields				fieldPtrOffset = mStructure->GetFieldOffset(i); // which we can detect here				if (fieldPtrOffset < 0)	{					// because they have negative numbers					p = mRecData[-fieldPtrOffset];			// when we find one, we get the field					::BlockMoveData(p, &offset, sizeof(Int32));	// offset, then check to see if it is					if (offset > lenOffset) {				// after the new field, and thus was 						offset += sizeDiff;					// one of the ones we moved. If it was,						::BlockMoveData(&offset, p, sizeof(Int32));	// adjust it and write it back					}				}			}		}	}	mRecData.unlock();}// results:   < 0  if data in record field(inFieldNum) is less than data at inFieldP//			   0   if data in record field(inFieldNum) is equal to data at inFieldP//			  > 0  if data in record field(inFieldNum) is greater than data at inFieldPintCRecord::CompareFieldData(Int16 inFieldNum, void* inFieldP, Int16 inDataSize, LComparator *inComp) const {	if (inComp == nil)		inComp = mStructure->GetFieldComparator(inFieldNum);	if (inComp == nil)		return 0;	handle h = (handle&)mRecData;	// bypass the const declaration	h.lock();	Int32 size;	void* srcP;	int result = 1;	// if field undefined, data is always presumed to be greater than	GetFieldDataPtr(inFieldNum, srcP, size);	if (size != fieldSize_Undefined) {			// don't bother if the field is undefined		inComp->Compare(srcP, inFieldP, size, inDataSize);	// compare data in the result ptr	}	h.unlock();	return result;}boolCRecord::FlagIsSet(Int16 inFieldNum) const {	handle h = (handle&)mRecData;	// bypass the const declaration	h.lock();	char* p = *h;	p += mStructure->GetFieldOffset(inFieldNum);	char c = *p;	c &= mStructure->GetFlagMask(inFieldNum);	h.unlock();	return (c != 0);}voidCRecord::SetFlag(Int16 inFieldNum, bool inFlagValue) {	mRecData.lock();	char* p = *mRecData;	p += mStructure->GetFieldOffset(inFieldNum);	char c = *p;	char mask = mStructure->GetFlagMask(inFieldNum);	// since FlagMask is 0 in all other fields,	if (inFlagValue)									// doing this to a non-flag field is harmless		c |= mask;			// do an OR with the mask to set the flag bit	else 		c &= (0xff - mask);	// do an and with the inverse of the mask to clear the flag bit	*p = c;	mRecData.unlock();}// mRecData handle must already be locked before making this callvoidCRecord::GetFieldDataPtr(Int16 inFieldNum, void* &outFieldP, Int32 &outFieldSize) const {	outFieldSize = mStructure->GetFieldSize(inFieldNum);	outFieldP = nil;	if (outFieldSize == fieldSize_Undefined)		return;						// don't bother if the field is undefined	Int32 offset = mStructure->GetFieldOffset(inFieldNum);	if (offset < 0) {				// variable sized records are more complicated		CalcVarFieldSizeAndOffset(inFieldNum, outFieldSize, offset); // into another method		if (offset == 0)			return;	}	outFieldP = mRecData[offset];	// get the appropriate offset in the record}voidCRecord::CalcVarFieldSizeAndOffset(Int16 inFieldNum, Int32 &outSize, Int32 &outOffset) const {	outOffset = mStructure->GetFieldOffset(inFieldNum);	Int8 lenBytes = mStructure->GetFieldLengthSize(inFieldNum);	// find out how many bytes of length info we store	char *p = mRecData[-outOffset];// offsets to var field ptrs are returned as negative values	Int32 realOffset = 0;	// which means we need to calc the actual offset to the start of							// the field ourselves, cause it changes from record to record	::BlockMoveData(p, &realOffset, sizeof(Int32));	// using block move because data is not aligned		// realOffset now contains the offset to the start of the field, which will be a length		// from 1 to 4 bytes in length, depending on field type. lenBytes already has the size		// of this length subfield.	if (realOffset) {		outSize = ExtractFieldLength(mRecData[realOffset], lenBytes);		outOffset = realOffset + lenBytes;	} else {		outSize = 0;	// offset was 0, no data stored in that field		outOffset = 0;	}}