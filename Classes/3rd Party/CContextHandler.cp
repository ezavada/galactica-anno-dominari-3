// =================================================================================//	CContextHandler.cp	version 1.0		©1995 Harold Ekstrom. All rights reserved.// =================================================================================//	This class may be freely used in any project.  The source itself may not//	be sold.  The source may be placed on ftp sites, BBSs, and similar locations//	but distribution on solid media, CD, floppy, etc, requires my permission.////	See header file for explanation and usage.#include <LCommander.h>#include <LWindow.h>#include <UException.h>#include "CContextHandler.h"ContextReplyUPP	CContextHandler::sContextReplyUPP = NewContextReplyProc( CContextHandler::ContextReplyProc );// ---------------------------------------------------------------------------------//		¥ CContextHandler// ---------------------------------------------------------------------------------CContextHandler::CContextHandler(	AEEventID	inEventID )		: mContextRefNum( -1 ){	// Make sure AppleGuide is available.	Boolean	isAppleGuideAvailable;	SInt32	theResult;	isAppleGuideAvailable = Gestalt( gestaltHelpMgrAttr, &theResult ) == noErr &&		(theResult & (1L << gestaltAppleGuidePresent)) != 0;	ThrowIfNot_( isAppleGuideAvailable );		// ERZ Win32 Mod -- Apple Guide not available under Win32  #if TARGET_OS_MAC	// Install the context reply proc.	ThrowIfOSErr_( ::AGInstallContextHandler( sContextReplyUPP,		inEventID, (long) this, &mContextRefNum ) );  #endif}// ---------------------------------------------------------------------------------//		¥ ~CContextHandler// ---------------------------------------------------------------------------------CContextHandler::~CContextHandler(){	// ERZ Win32 Mod -- Apple Guide not available under Win32  #if TARGET_OS_MAC	// Remove the handler.	::AGRemoveContextHandler( &mContextRefNum );  #endif}// ---------------------------------------------------------------------------------//		¥ ContextReplyProc// ---------------------------------------------------------------------------------pascal OSErrCContextHandler::ContextReplyProc(	Ptr				inData,	Size			inDataSize,	Ptr				*outData,	Size			*outDataSize,	AGAppInfoHdl	inAppInfo ){	OSErr	err = noErr;#if TARGET_OS_MAC && TARGET_CPU_68K && !GENERATINGCFM	// Setup our A5 world.	// This may not be necessary but better safe than sorry.	long	theOldA5 = ::SetCurrentA5();#endif	Try_ {		// Get the handler.		CContextHandler	*theHandler;		theHandler = (CContextHandler *) (**inAppInfo).refCon;		ThrowIfNil_( theHandler );		// Perform the context check.		Boolean	theResult;		theResult = theHandler->DoContextCheck( inData, inDataSize );		// Allocate the reply data.		*outData = ::NewPtr( sizeof(Boolean) );		ThrowIfMemFail_( *outData );		// Fill in the reply data.		*(Boolean *)*outData = theResult;		*outDataSize = sizeof(Boolean);	} Catch_( inErr ) {		err = inErr;	} EndCatch_	#if TARGET_OS_MAC && TARGET_CPU_68K && !GENERATINGCFM	// Restore A5 to the old value.	::SetA5( theOldA5 );#endif	return err;}#pragma mark -// ---------------------------------------------------------------------------------//		¥ CCmdContextHandler// ---------------------------------------------------------------------------------CCmdContextHandler::CCmdContextHandler(	AEEventID	inEventID )		: CContextHandler( inEventID ){}// ---------------------------------------------------------------------------------//		¥ ~CCmdContextHandler// ---------------------------------------------------------------------------------CCmdContextHandler::~CCmdContextHandler(){}// ---------------------------------------------------------------------------------//		¥ DoContextCheck// ---------------------------------------------------------------------------------BooleanCCmdContextHandler::DoContextCheck(	const Ptr		inData,	Size			inDataSize ){	Boolean	isEnabled = false;	// Get the command number to test.	ThrowIf_( inDataSize != sizeof(CommandT) );	CommandT	theCommand;	theCommand = *(CommandT *) inData;		// Get the current target.	LCommander	*theTarget = LCommander::GetTarget();		if ( theTarget != nil ) {		// Get the command status.		Boolean		usesMark = false;		Char16		mark = noMark;		Str255		itemName;			itemName[0] = 0;		theTarget->ProcessCommandStatus( theCommand,			isEnabled, usesMark, mark, itemName );	}		return isEnabled;}#pragma mark -// ---------------------------------------------------------------------------------//		¥ CPaneIDContextHandler// ---------------------------------------------------------------------------------CPaneIDContextHandler::CPaneIDContextHandler(	AEEventID	inEventID )		: CContextHandler( inEventID ){}// ---------------------------------------------------------------------------------//		¥ ~CPaneIDContextHandler// ---------------------------------------------------------------------------------CPaneIDContextHandler::~CPaneIDContextHandler(){}// ---------------------------------------------------------------------------------//		¥ DoContextCheck// ---------------------------------------------------------------------------------BooleanCPaneIDContextHandler::DoContextCheck(	const Ptr		inData,	Size			inDataSize ){	Boolean	theResult = false;	// Get the pane id to test.	ThrowIf_( inDataSize != sizeof(PaneIDT) );	PaneIDT	thePaneID;	thePaneID = *(PaneIDT *) inData;	// Get the front window.	WindowPtr	theMacWindowP = ::FrontWindow();	if ( theMacWindowP != nil ) {		// Get the PowerPlant window object.		LWindow	*theWindow = LWindow::FetchWindowObject( theMacWindowP );				if ( theWindow != nil ) {					// Test the pane id.			theResult = (thePaneID == theWindow->GetPaneID());				}		}	return theResult;}