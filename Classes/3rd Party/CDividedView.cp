/**********************************************************************		CDividedView.cp	Written by Rick Eames	й1994-1995 Rick Eames.  All Rights Reserved.		You may use this class in any non-commercial program without	permission.  The only restriction is that you must credit the	author in your about box.  For commercial use, please contact	the author at the email address below.		DESCRIPTION:	This class splits a view into two sub-views that					can be dynamically sized by dragging around a 					dividing line.					Send bug-reports and comments to athos@pendragon.com		02/02/95		(RME)	Added cursor for dividers.				Notes:		-- Need to add a cursor for the divider section.		**********************************************************************/#include "CDividedView.h"#include <UDrawingState.h>/********************************************************************************************************************************************/CDividedView::CDividedView()	: LView(){}/********************************************************************************************************************************************/CDividedView::CDividedView(const CDividedView &inOriginal)	: LView(inOriginal){}/********************************************************************************************************************************************/CDividedView::CDividedView(	const SPaneInfo &inPaneInfo,	const SViewInfo &inViewInfo,	SInt16 inDividerPos,	SInt16 inMinFirstSize,	SInt16 inMinSecondSize,	Boolean	inIsHorizontal): LView(inPaneInfo, inViewInfo){	mDividerPos = inDividerPos;	mMinFirstSize = inMinFirstSize;	mMinSecondSize = inMinSecondSize;	isHorizontal = inIsHorizontal;		InitDividedView();}/********************************************************************************************************************************************/void CDividedView::InitDividedView(){	SPaneInfo	pi;	SViewInfo	vi;	SInt16	firstWidth, firstHeight;	SInt16	secondWidth, secondHeight;	SInt32	firstLeft, firstTop;	SInt32	secondLeft, secondTop;		// first set common fields	pi.visible = true;	pi.enabled = true;	pi.userCon = 0L;	pi.superView = this;	pi.bindings.left =	pi.bindings.right =	pi.bindings.top = 	pi.bindings.bottom = true;		vi.imageSize.width = 0;	vi.imageSize.height = 0;	vi.scrollPos.h = 0;	vi.scrollPos.v = 0;	vi.scrollUnit.h = 1;	vi.scrollUnit.v = 1;	vi.reconcileOverhang = false;		if (isHorizontal)	{		if (mDividerPos == 0)		// еее ERZ mod, if divider pos undefined, set to halfway point			mDividerPos = (mFrameSize.height - kDividerSize)/2;	// еее ERZ Mod			firstLeft = 0;		firstTop = 0;		firstWidth = secondWidth = mFrameSize.width; // could also do -1		firstHeight = mDividerPos;				secondLeft = 0;		secondTop = mDividerPos + kDividerSize;		secondHeight = mFrameSize.height - secondTop;	}	else	{		firstLeft = 0;		firstTop = 0;		secondTop = 0;		firstWidth = mDividerPos;		firstHeight = secondHeight = mFrameSize.height;				secondLeft = mDividerPos + kDividerSize;		secondWidth = mFrameSize.width - secondLeft;	}		// do the first one	pi.paneID = 'pone';	pi.width = firstWidth;	pi.height = firstHeight;	pi.left = firstLeft;	pi.top = firstTop;	pi.bindings.left =	pi.bindings.right =	pi.bindings.left = 	pi.bindings.bottom = false;		if (isHorizontal)	{		pi.bindings.right = true;		pi.bindings.left = true;		pi.bindings.top = true;	}	else	{		pi.bindings.bottom = true;		pi.bindings.left = true;	}		mFirstView = new LView(pi, vi);		// do the second one	pi.paneID = 'ptwo';	pi.width = secondWidth;	pi.height = secondHeight;	pi.left = secondLeft;	pi.top = secondTop;	pi.bindings.left =	pi.bindings.right =	pi.bindings.left = 	pi.bindings.bottom = true;	mSecondView = new LView(pi, vi);		CursHandle	tempCurs = ::MacGetCursor(kHCursor);	mHCursor = **tempCurs;	tempCurs = ::MacGetCursor(kVCursor);	mVCursor = **tempCurs;}/**********************************************************************LView.cp**********************************************************************/CDividedView::CDividedView(	LStream *inStream)	: LView(inStream){	*inStream >> mTopLeftPaneID;	// *** ERZ Additions	*inStream >> mBotRightPaneID;	*inStream >> isHorizontal;	*inStream >> mDividerPos;	*inStream >> mMinFirstSize;	*inStream >> mMinSecondSize;	// *** end ERZ Additions	InitDividedView();}/********************************************************************************************************************************************/CDividedView::~CDividedView(){	InitDividedView();}// *** ERZ Addition//	Finish creation of a Divider by installing the Panes to resizevoidCDividedView::FinishCreateSelf() {	InstallFirstView((LView*)FindPaneByID(mTopLeftPaneID), true);	InstallSecondView((LView*)FindPaneByID(mBotRightPaneID), true);}// *** end ERZ Addition/********************************************************************** InstallViews 	 	Take the input views and place them inside our holding tank views.**********************************************************************/void CDividedView::InstallFirstView(	LView *inFirstView, 	Boolean autoExpand){	if (inFirstView)	{		inFirstView->PutInside(mFirstView);		if (autoExpand)			mFirstView->ExpandSubPane(inFirstView, !isHorizontal, isHorizontal);	}	}void CDividedView::InstallSecondView(LView *inSecondView, Boolean autoExpand){	if (inSecondView)	{		inSecondView->PutInside(mSecondView);		if (autoExpand)			mSecondView->ExpandSubPane(inSecondView, !isHorizontal, isHorizontal);	}}/********************************************************************** DrawSelf 	**********************************************************************/void CDividedView::DrawSelf(){	Rect frame;		CalcDividerRect(frame);  	Pattern black;    UQDGlobals::GetBlackPat(&black);    ::PenPat(&black);	::MacFrameRect(&frame);}/********************************************************************** ClickSelf 	**********************************************************************/void CDividedView::ClickSelf(	const SMouseDownEvent &inMouseDown){	Rect	frame;	CalcDividerRect(frame);		FocusDraw();		if (::MacPtInRect(inMouseDown.whereLocal, &frame))	{		Rect	lRect, sRect;		long	result;		SInt16	delta;				RgnHandle	myRgn;		myRgn = ::NewRgn();		::RectRgn(myRgn, &frame);				CalcLocalFrameRect(lRect);		sRect = lRect;		if (isHorizontal)		{			lRect.top += mMinFirstSize;			lRect.bottom -= mMinSecondSize;		}		else		{			lRect.left += mMinFirstSize;			lRect.bottom -= mMinSecondSize;		}				result = ::DragGrayRgn(myRgn, inMouseDown.whereLocal, 								&lRect, &sRect, 								isHorizontal ? vAxisOnly : hAxisOnly, nil);				::DisposeRgn(myRgn);				if (isHorizontal) delta = HiWord(result);		else delta = LoWord(result);				if ((result == kOutsideSlop) || (delta == 0)) 			return;				/************************************************************			Now we do the following:			(1)	move the divider to our new location			(2)	Resize the top or left pane according to our new				location.			(3)	Move the bottom or right view over			(4)	Resize the bottom or right view to make up for that				move.		************************************************************/				mDividerPos += delta;				if (isHorizontal)		{			mFirstView->ResizeFrameBy(0, delta, true);			mSecondView->MoveBy(0, delta, true);			mSecondView->ResizeFrameBy(0, -delta, true);		}		else		{			mFirstView->ResizeFrameBy(delta, 0, true);			mSecondView->MoveBy(delta, 0, true);			mSecondView->ResizeFrameBy(-delta, 0, true);		}	}}/********************************************************************************************************************************************/void CDividedView::CalcDividerRect(	Rect & outRect){	CalcLocalFrameRect(outRect);		if (isHorizontal)	{			outRect.top = mDividerPos;		outRect.bottom = outRect.top + kDividerSize;		outRect.left--;		outRect.right++;	}	else	{		outRect.left = mDividerPos;		outRect.right = outRect.left + kDividerSize;		outRect.top--;		outRect.bottom++;	}}/********************************************************************************************************************************************/voidCDividedView::AdjustMouseSelf(	Point				inPortPt,	const EventRecord	&, //inMacEvent	RgnHandle) //ioMouseRgn{	Rect	frame;	CalcDividerRect(frame);	PortToLocalPoint(inPortPt);	if (::MacPtInRect(inPortPt, &frame))	{		if (isHorizontal) {			::MacSetCursor(&mHCursor);		} else {			::MacSetCursor(&mVCursor);		}	}}