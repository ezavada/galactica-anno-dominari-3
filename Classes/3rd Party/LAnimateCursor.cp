/*	File:		LAnimateCursor.cp		Contains:	Cursor spinning routines.	Copyright:	©1995 Chris K. Thomas.  All Rights Reserved.		Version:	2.1*/#include "GenericUtils.h"#include "LAnimateCursor.h"#include <LCursor.h>#include <UCursor.h>//// ÑÑÑÑ¥ construct ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//LAnimateCursor::LAnimateCursor(const short inStartID, const short inNumCursors)	//:LProgressIndicator(task_Indeterminate, 0, inNumCursors, 0),:CCursor(0), mYCursors(sizeof(CCursor *)) {	//	// ¥ init state	//	mCursorIterator = 1;	mCursorHandle = NULL;	Lock();		//	// ¥ grab cursors and stuff into our array	//	CCursor	*ourCursor;		// resize the handle just once, thanks	mYCursors.AdjustAllocation(inNumCursors);		for(short i = inStartID; i < (inStartID + inNumCursors); i++)	{		ourCursor = new CCursor(i);//(CursHandle)GetResource('CURS', i);		ThrowIfNULL_(ourCursor);				mYCursors.InsertItemsAt(1, mYCursors.GetCount() + 1, &ourCursor);	}		//	// setup tick counter	//	mLastTicks = TickCount();}LAnimateCursor::~LAnimateCursor(){	Unlock();    UCursor::SetArrow();		// Default cursor is the arrow			CCursor		*ourCurs;	UInt32		curCursCount;		curCursCount = mYCursors.GetCount();		//	// release the last cursor in the array	// until no more items exist	//	while(curCursCount > 0)	{		if(mYCursors.FetchItemAt(curCursCount, &ourCurs))		{			delete ourCurs;		}		--curCursCount;	}}// ÑÑÑÑÑÑÑÑÑ¥ ImplementationÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//// ¥ rotate the cursor//void LAnimateCursor::Set(){	//	// prevent cursor flash and poor performance	// by ensuring a threshold number of ticks have	// passed since last spin	//		if((TickCount() - mLastTicks) > kMinSpinTicks)	{		CCursor *ourCursor;				//		// rotate to the next cursor		//		mCursorIterator++;				if(mCursorIterator > mYCursors.GetCount())			mCursorIterator = 1;				if(mYCursors.FetchItemAt(mCursorIterator, &ourCursor))		{			ourCursor->Set();		}		else		{			SignalPStr_("\pCouldn't find a cursor!");		}				mLastTicks = TickCount();	}}