/* 	File:		GameSmithAPI.h  	Contains:	Freeverse GameSmith Server API  	Version:	GameSmith 3.3.3 2119  	Copyright:	© 1998-2003 by Freeverse Software, Inc. 	 	Contact:	Lane Roathe 				lane@ifd.com 		or 				Randy Thompson 				thompr@earthlink.net 		or	 				Ian Lynch Smith 				ian@freeverse.com*/#ifndef __GS_SERVER_API__#define __GS_SERVER_API__#include "OpenPlay.h"#ifdef __cplusplusextern "C" {#endif/* crt 8/5/2001 Force our compiler to use 68K alignment, regardless of project settings. */#pragma options align=mac68k/************************  Constant definitions:************************/#define	kGS_NotRanked				0enum{	kEventClassGSServer           	= FOUR_CHAR_CODE('_FV_')				// Carbon Event class for Freeverse Server events};enum{	kEventParamNSpGameReference		= FOUR_CHAR_CODE('NSPG'),				// typePtr	kEventParamConnectInfoPtr		= FOUR_CHAR_CODE('CIPP'),				// typePtr	kEventParamUnrankedGame			= FOUR_CHAR_CODE('RANK'), 				// typeBoolean	kEventParamTeachingGame		 	= FOUR_CHAR_CODE('TEAC'), 				// typeBoolean	kEventParamText					= FOUR_CHAR_CODE('TEXT')				// typeChar};typedef UInt32 GS_ServerEventType;/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* GameSmith Carbon Events                                                              *//*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*//* *  Summary: *    GameSmith events (kEventClassGSServer) */enum{	/* 	 * The user hosted a new game and expects to play in it.	 * GameSmith created the NSpGameReference for you via NSpGame_Host()	 */	kGS_GameHosted					= 2,		/* 	 * The user joined a new game and expects to play in it.	 * GameSmith joined an existing game refernce for you via NSpGame_Join()	 */	kGS_GameJoined					= 3,		/* 	 * The user joined a game and just wants to watch.	 * GameSmith joined an existing game refernce for you via NSpGame_Join()	 */	kGS_GameJoinedForObserving		= 4,		/* 	 * The user selected the go away box in the server window.  You should respond by either calling GS_ServerDisconnect() or GS_HideServerWindow()	 * depending on the behavior that is appropriate for your game. Current convention is to just hide the server window.	 */	kGS_ServerGoAwayHit				= 5,		/* 	 * The user wants to disconnect from the Freeverse network.  In response, you should call GS_ServerDisconnect()	 */	kGS_UserDisembark				= 6,		/* 	 * Sent after connecting is completely over. Gives app a chance to change state of menu items for example	 * bmp 7/4/2001	 */	kGS_EmbarkingComplete			= 7,	/* 	 * Sent after connecting is over and has failed. Gives app a chance to change state of menu items for example	 * LR 020622 -- don't say we've completed embarking if we've actually failed!	 */	kGS_EmbarkingFailed				= 8,	/* 	 * sent when GSL updates itself or the user did so manually. App should make an effort to quit as quickly as possible	 * The GameSmith libraries were updated, the game must call GS_RestartToConnect() asap and then quit	 */	kGS_RestartToConnect			= 9,	/* 	 * User wants to host a new game, app is responsible for the the protocol and method of hosting the game	 * LR 020322	 */	kGS_MustHostGame				= 10,	/* 	 * User wants to join a  game, app is responsible for the the protocol and method of joining the game	 * LR 020322	 */	kGS_MustJoinGame				= 11,			/* 	 * Requesting content for the "Game Status" portion of the Game info dialog 	 */	kGS_StatusRequest				= 15,			/* 	 * Requesting content for the "Game Rules" portion of the Game info dialog 	 */	kGS_RulesRequest				= 16,			/* 	 * Should the Host Game dialog allow the user to specify a game should be unranked?	 * bmp 12/14/2002	 */	kGS_AllowHostingUnrankedGames	= 20,	/* 	 * Should the Host Game dialog allow the user to specify a game should be a teaching kind of game?	 * bmp 12/14/2002	 */	kGS_AllowHostingTeachingGames	= 21,	/* 	 * User's registration code was deemed invalid by the server, app should do something appropriate (such as expire the game)	 * bmp 12/8/2002	 */	kGS_RegistrationCodeLockOut		= 50,	/* 	 * The user clicked the help button in the sign on dialog. If app handles, great, open the	 * appropriate page in the help book. Otherwise, if not GS will display a basic alert with help info.	 */	kGS_HelpSignOn					= 100,	/* 	 * The user clicked the help button in the server window. If app handles, great, open the	 * appropriate page in the help book. Otherwise, if not GS will display a basic alert with help info.	 * bmp 7/4/2001	 */	kGS_HelpServer					= 101};/* *	backwards compatiblity #defines */#define	kGS_NetPlayGameHost	kGS_GameHosted		#define	kGS_NetPlayGameJoin	kGS_GameJoined	#define	kGS_NetObserveGame	kGS_GameJoinedForObserving	#define	kGS_NetPlayHostGame	kGS_MustHostGame	#define	kGS_NetPlayJoinGame	kGS_MustJoinGame	/*    Parameters for GameSmith events:		kGS_GameHosted		-->		kEventParamNSpGameReference		 typePtr		// contains an NSpGameReference that was created by GameSmith for the game that is to be hosted        -->     kEventParamUnrankedGame		     typeBoolean  	// whether or not the game is unranked        -->     kEventParamTeachingGame		     typeBoolean  	// whether or not the game is unranked	kGS_GameJoined		-->		kEventParamNSpGameReference		 typePtr		// contains an NSpGameReference that was created by GameSmith for the game to be joined        -->     kEventParamUnrankedGame		     typeBoolean  	// whether or not the game is unranked        -->     kEventParamTeachingGame		     typeBoolean  	// whether or not the game is unranked	kGS_GameJoinedForObserving		-->		kEventParamNSpGameReference		 typePtr		// contains an NSpGameReference that was created by GameSmith for the game to be joined        -->     kEventParamUnrankedGame		     typeBoolean  	// whether or not the game is unranked        -->     kEventParamTeachingGame		     typeBoolean  	// whether or not the game is unranked	kGS_ServerGoAwayHit							(no parameters)											kGS_UserDisembark							(no parameters)	kGS_EmbarkingComplete						(no parameters)		kGS_EmbarkingFailed							(no parameters)		kGS_RestartToConnect						(no parameters)	kGS_MustHostGame					        -->     kEventParamConnectInfoPtr   	 typePtr		// pointer to a GS_ConnectInfo_t struct with game information        -->     kEventParamUnrankedGame		     typeBoolean  	// whether or not the game is unranked        -->     kEventParamTeachingGame		     typeBoolean  	// whether or not the game is unranked	kGS_MustJoinGame					        -->     kEventParamConnectInfoPtr   	 typePtr		// pointer to a GS_ConnectInfo_t struct with game information        -->     kEventParamUnrankedGame		     typeBoolean  	// whether or not the game is unranked        -->     kEventParamTeachingGame		     typeBoolean  	// whether or not the game is unranked	kGS_StatusRequest        <--     kEventParamStatus			   	 typeChar		// text for the status content		kGS_RulesRequest        <--     kEventParamRules			   	 typeChar		// text for the rules content		kGS_AllowHostingUnrankedGames		(no parameters)	kGS_AllowHostingTeachingGames		(no parameters)	kGS_RegistrationCodeLockOut					(no parameters)		kGS_HelpSignOn								(no parameters)											kGS_HelpServer		(no parameters)*//*  When the function GS_ServerConnect() returns, it will return with one of the following values...  */typedef enum{	kGS_ConnectFailed			= 0,		/* The connection attempt failed, possibly a network issue */	kGS_ConnectSucceeded		= 1,		/* The connection attempt succeeded */	kGS_ConnectCancelled		= 2,		/* The user cancelled the connection request at the join dialog */	kGS_ConnectBadUserID		= 3			/* The user entered a bad User ID or password, might want to retry! */} GS_ConnectResultType;/*  If you use server-side ranking, you may need to know whether a player has an account or	is a guest.  The server will supply this information when it calls your	server-side ranking function, using the following constants.*/typedef enum {	kGS_GuestType			= 0,				kGS_MemberType			= 1} GS_NetworkAccountType;/*  There is another way that you can distinguish between actual players and observers.	If at any time during your game, you need to find out whether a player is REALLY a 	player or if he/she is an observer, call NSpPlayer_GetInfo() and examine the contents	of the "type" field.  It will contain a value of kGS_PlayerType or kGS_ObserverType.	It doesn't make sense to call that function for a non-network player, so you'll	never receive a type of kGS_AIType.*/typedef enum {	kGS_PlayerType			= 0,				kGS_ObserverType		= 1,	kGS_AIType				= 2		} GS_NetworkPlayerType;/*  A perfect time to check this would be when you receive an NSpPlayerJoined message.	This message contains the NSpPlayerInfo structure for the new player.  Your game can	determine what the new player is (even if it is yourself) almost immediately, record	that information in your own internal player information structures (if you have such),	set up for a new player or observer, and go on. *//*  Here are some constants to be used as room numbers with the function GS_SetHeadless(),	if your game is supposed to be "headless".  See the function declaration below for	details.*/typedef enum {	kGS_AllRooms			= -1,			kGS_MainDeck			= 0,				kGS_QuarterDeck			= 1,	kGS_CrowsNest			= 2,				kGS_ThePlank			= 3,	kGS_CapnQuarters		= 4,				kGS_JensCabin			= 5,	kGS_TheGalley			= 6,				kGS_TheBilge			= 7} GS_RoomNumber;/*  Constants to denote which platform this is (Mac/Windows).*/typedef enum 	/* crt 8/5/2001, Platform types used in join context for all Freeverse games... */{	kGS_PlatformMac			= 0,				kGS_PlatformPC			= 1} GS_PlatformType;/************************	Error & Warning Codes************************/#define		kGS_DataFileNotFoundError	-1		/* To be moved into the public headers after values are selected... */#define		kGS_DataFileOpenError		-2				#define		kGS_DataFileReadOnlyWarning	-26000				enum{	errCantCreateRoomsFileURL			= -2100,	errCantCreateRoomsDataRef			= -2101,	errCantCreateRoomsXMLTree			= -2102,	errCantParseRoomsXMLTree			= -2103,	errUpdateDownloadFailed				= -2110};/************************	Data types for the interface:	Note that these data types are matched to types of the same name in the 	GameRanking.h file, which is used by the server.  If you change these	here, you must change them there too, which may cause backwards compatibility issues.************************//* Structure passed to games that request we don't create NSp game for them */typedef struct{	char				publicIP[256];			/* information used to connect to a server on internet (ie, outside NAT) */	char				publicPort[32];	char				localIP[256];			/* information used to connect to local server (ie, LAN server inside NAT) */	char				localPort[32];	unsigned char *		gameName;				/* name player gave to game */	unsigned char *		gamePassword;	unsigned char *		playerName;				/* player's name */	short				gamePort;				/* IP port to start game on */	short				playerType;				/* player's type (from an NSpPlayerType) */	short				maxPlayers;				/* max # of players */} GS_ConnectInfo_t, *GS_ConnectInfoPtr;/* GS_PlayerResults: */typedef struct {							char		playerName[32];		/* The player's network name. */							int			score;				/* The player's score at the end of the game. */							Boolean		isHuman;			/* "true" for a Human player, "false" for a Bot. */							int			gamesWon;			/* Don't fill this field on the client side. */							int			gamesLost;			/* Don't fill this field on the client side. */							int			rankPoints;			/* Don't fill this field on the client side. */} GS_PlayerResults,	*GS_PlayerResultsPtr;/* GS_GameResults: */typedef struct {							int					numPlayers;							GS_PlayerResults	playerResults[kVariableLengthArray];} GS_GameResults, *GS_GameResultsPtr;/* GS_GameJoinContext:		crt 8/5/2001, Adding a join context for all Freeverse games... */typedef struct {                           FourCharCode			signature;                           UInt32				structureVersion;                           NMNumVersion			appVersion;                           UInt32				platformType;} GS_GameJoinContext, *GS_GameJoinContextPtr;/* crt 8/5/2001	A constant that represents this join context structure.  In the future, if/when	we update the structure of the join context, I recommend that we retain in comments all previous 	struct definitions together with their version numbers.  Here is the version number of the 	current structure:*/enum {  kGS_GameJoinStructureVersion = 0	/* crt 8/5/2001 Supports new join game context structure. */};									/* *Must* be incremented when GS_gameJoinContext structure changes. *//* crt 8/5/2001	A signature for this join context structure... */enum {  kGS_GameJoinSignature = FOUR_CHAR_CODE('HMS!')	/* crt 8/5/2001 Supports new join game context structure. */};/************************  Function Prototypes:************************//*----------------------------------------------------------------------------------------------------	Before you use any other function in this API, you must first call GS_Init().  You	can do this before or after you initialize NetSprocket.  That's right, you need to	initialize NetSprocket yourself.  (I decided this was best because the initialization	of NetSprocket contains game dependent parameters, and you may not like the ones I	pick for you.) */OSStatus 		GS_Init(const char *appName, OSType gameCreatorCode, unsigned short maxPlayersAllowed, 					Boolean observeCapable, Boolean gameRegistered, NSpMessageHandlerProcPtr asyncMessageHandlerPtr, 					void *asyncContextPtr, const NMNumVersion *gameVersionPtr);											/* crt 8/5/2001, Init now requires "Game Version". */										/*  The parameters mean:	appName				    This is a string that will only be used to customize server generated alert dialogs.                 			For example, if a user attempts to join a new game while one is still in progress, a                 			dialog might say "This version of <gameName> does not allow multiple games.  							Try quitting the one in progress."  I will probably use "NetCribbage" for my game.  							Bryan could use "Spades Deluxe".  You get the idea.  Must be less than 32 characters.	gameCreatorCode			This is your application's creator code.  It will be used to host and check for							games on an AppleTalk network.  Enter it as 'xxxx'.  Example:  'NtCb'	maxPlayersAllowed		This is the maximum number of players allowed to join with your game.  It is							used to fill out the associated value in a call to NSpGame_Host() when the user							starts a new game.  This value should be the sum total of the number of players							you are going to allow and the number of observers you will allow. 	observeCapable			This is a Boolean which tells the server whether your game can support observers.							If not, the "Observe" button will not be displayed.  (In future versions of the 							interface.)  :--)     	gameRegistered			When a game is not registered, GameSmith will not allow them to host or join games.	                        Additionally, chat they send will be "tagged" as coming from an unregistered player.	                        If your game is unregistered, you may want to give them a trial period before passing	                        false here. The registration code is sent via a different API (GS_SetRegistrationCode)	                        so as to not change this API	asyncMessageHandlerPtr  If your game uses an asynchronous message handler for NetSprocket messages, insert							the name of that function here.  IMPORTANT:  Do not call the NetSprocket function							NSpInstallAsyncMessageHandler().  The libraries will do that for you.  The reason							for this restriction is that the libraries install an asynchronous message handler,							and there can only be one installed.  The asynchronous message handler installed by							the libraries will call your async message handler and pass it your context pointer							when appropriate.  ALSO IMPORTANT:  If your game does not use an asynchronous							message handler, then you must pass NULL here.  Otherwise, CRASH!	asyncContextPtr  		A pointer used to pass game contextual information in to your asynchronous message							handler.  If you don't need to use this pointer, pass NULL.	gameVersionPtr  		A pointer used to pass the game's version into the libraries.  If you supply a value							of NULL the libraries will use check the 'vers' 1 resource for game's version.							Be sure this parameter is valid (or the vers 1 resource is accurate) so that							GameSmith based version notification can work accurately.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	When you are done using this API, call GS_Terminate().  It's job is to kill some offscreen GWorlds	created by GS_Init().  Call this whether you actually connected to the server or not.  Don't call it 	before you call GS_Init().  But then, that's obvious, right?*/OSStatus	GS_Terminate(void);/*  The parameters mean:	void				The space between my ears.						For now, this function has two possible return values, noErr and -1.						When I work up a convention for error reporting, this will change.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Init the GameSmith networking. Only call this if you do not initialize	NetSprockets yourself! This only sets the game ID, the rest of the NSp	init values are set to defaults. If you want more control, you can call	NSpInitialize directly instead of this function.	Exit: errors*/OSStatus GS_InitNetworking( NSpGameID gameID );/*  The parameters mean:	gameID					ID used to uniquely identify your game, usually your application's creator code.							It will be used to host and check for games on an AppleTalk network.							Enter it as 'xxxx'.  Example:  'NtCb'----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Inform GameSmith on whether or not it should create an NSp game for	you when the user hosts/joings. Must be called before you connect to GameSmith, but after init!*/void GS_CreateNSpGames( Boolean createGame );/*  The parameters mean:	createGame				true : GameSmith will create the NetSprocket game for your. If you are							joining then you will also be connected to the host game (which must also							be running NetSprocket!) automatically.							false : you are only given the info required to host or join a game. For							hosting this is basically "do it" and for joining it will be the IP # of							the hosting application. In both cases it will be up to your application							to create all network connections, accept clients, connect to hosts, etc.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	When the user indicates that he/she wants to play on the internet, call GS_ServerConnect().	This function will connect you to the server, after which it spawns the "server window" 	unless the connection was not made, for whatever reason.  It will return control to your	application only after the connection has succeeded or failed or the user has given up	and cancelled.  The return value is one of the possible GS_ConnectResultType's described above.	It indicates whether the connection attempt was successful or not and whether the user wants to 	quit.  If successful, a server window exists and is showing.	Pass a value of "true" for the parameter doSignOn, if you want to give the user a chance	to change his name and password.  Otherwise, the values you supply here will be used.*/GS_ConnectResultType GS_ServerConnect(const char *playerName, const char *requestedPassword, Boolean newGamesEnabled, Boolean doSignOn);/*  The parameters mean:	playerName			The player's name you want to start with.  Pass in the name used last time, for						example, by keeping it in your preferences file. Must be less than 32 characters.						You may also pass a value of NULL for this parameter.	requestedPassword	The player's password you want to start with.  This is only used if "doSignOn" has						a value of "false".  Must be less than 32 characters. You may also pass a value of 						NULL for this parameter.						Note:  If "doSignOn" is "true" the libs ignore the requestedPassword,						and enter the player's remembered password or an empty string if a remembered						password can't be found for this player.	newGamesEnabled		Don't ask me why, but you may wish to connect to the server but not allow the						user to immediately begin starting / joining new games.  (Perhaps you have a						local game active, cannot support multiple games, and don't want to auto-quit						your local game in favor of a new net game.)  If that is the case, pass						"false" in this parameter.  Otherwise, pass "true" and let 'em ride!  I suspect						that "true" will be your most common choice.	doSignOn			You may want to allow your user to connect to the server without having to						fill out the dialog, instead opting to use the playerName and password supplied.						If so, pass a value of "false" here.  To bring up the sign-on dialog, enter a value						of "true".----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_ServerDisconnect() when you want to end the "server game"	and close the server window.  You no longer need to close the server window yourself. */OSStatus 	GS_ServerDisconnect();/*						For now, this function has two possible return values, noErr and -1.						When I work up a convention for error reporting, this will change.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Since the previous function causes a new window to be created, which you don't have the	WindowPtr for, I have decided that it would be nice of me to provide the services of	"hiding" and "showing" the server window.  Note that these functions do not dispose of or create	the window.  They only hide and show one that is already created.  If the functions are called when	not appropriate, e.g. attempting to show or hide a nonexistent window, they have no effect.	Only call these functions in response to a user request to do so.  That way you can be sure not	to surprise them by spuriously hiding and showing windows.*/void	GS_HideServerWindow();void	GS_ShowServerWindow();/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_ServerWindowExists() when you are curious whether the server	window is open.*/OSStatus	GS_ServerWindowExists(Boolean *outServerWindowExists);/*  The parameters mean:	outServerOwnsWindow		A boolean that tells whether the server window is open.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_ServerOwnsWindow() when you are curious whether a specific window	belongs to the server process or to your own application.*/OSStatus	GS_ServerOwnsWindow(const WindowPtr inWindow, Boolean *outServerOwnsWindow);/*  The parameters mean:	inWindow				This is the pointer to the window that you are curious about.  	outServerOwnsWindow		A boolean that tells whether the window belongs to the server.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call GS_InstallMenuItems() to have GameSmith install menu items in the menu bar. GameSmith will	install its own menu command handlers on these items, so the app doesn't need to do anything with them.		A divider is always installed as the last item in this grouping.		Currently, Get Info, Join Game and Host Game items are installed.*/OSStatus	GS_InstallMenuItems		(MenuRef menu, MenuItemIndex afterItem);/*  The parameters mean:	menu					The menu to install the items into 	afterItem				The items will be installed after this item----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_GetMyNetPlayerName() when you want to find out what name the user	has selected for network play.  (Note that if a NetSprocket game has been started, then this	information is available via successive calls to NSpPlayer_GetMyID() and NSpPlayer_GetInfo(). )*/OSStatus 	GS_GetMyNetPlayerName(char *playerName);/*  The parameters mean:	playerName				A "C" pointer containing the player's name.  You need to have							allocated some space for this on your own stack prior to calling.							Will be less than 32 characters, so if you declare it as										char playerName[32] = "\0"							you will be safe. ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_GetMyNetPlayerPassword() when you want to find out what password the user	has selected for network play.  (This is his Freeverse account password, and in general has 	nothing to do with any game specific password used.)*/OSStatus 	GS_GetMyNetPlayerPassword(char *playerPassword);/*  The parameters mean:	playerPassword			A "C" pointer containing the player's password.  You need to have							allocated some space for this on your own stack prior to calling.							Will be less than 32 characters, so if you declare it as										char playerPassword[32] = "\0"							you will be safe. ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	These two functions are so simple and related that I thought I'd describe them together...	Call GS_DisableNewGames() when your game is at its limit of number of games it	can handle.  Since this may depend upon the amount of memory allocated by the user	as well as the number of local (non-networked) games currently running, there is no 	clean way for the server process to know when it should prohibit new games.  The cleanest 	way is for you to explicitly tell it to do so.  In a game like SimpleCards (Cribbage also)	which is not yet capable of controlling multiple concurrent games, you can call	GS_DisableNewGames() at the beginning of each game.	When your application is once again capable of handling a new game, call the opposite	function, GS_EnableNewGames().*/void 		GS_DisableNewGames();void 		GS_EnableNewGames();/*  Note:  In SimpleCards, I do not disable new games when a local game is started.  Instead,	I allow new connections, and if a local game is running when GS_IsServerEvent() reports 	that a new game connection has been made, I blow away the local game and start the net game.	This is a good thing to do, since it was obviously the user's preference to play on the	net.  Alternatively, you can at least present a dialog that asks them which they'd rather	do:  Quit the local game or dispose of the network game.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	If you are hosting a game, call GS_AllowPlayers() with a value of "true" to let people 	on the server know that your game is open and ready to accept new players.  A counter 	example is when your game is actually in progress, rather than waiting for new joiners.  	In that case, call GS_AllowPlayers() with a value of "false".	If you are hosting a game, call GS_AllowObservers() with a value of "true" to let people 	on the server know that your game is open and ready to accept observers.  If you don't	want observers, call it with a value of "false".  Note:  If you originally passed a	value of "false" in the observeCapable parameter of NSvInit(), then GS_AllowObservers()	has no effect.  Observers are never allowed in that case, and the "Observe" button	won't even be displayed.*/void 		GS_AllowPlayers(Boolean allowThem);void		GS_AllowObservers(Boolean allowThem);/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	By default, the server libs play some subtle sounds when specific events occur, such	as when players enter/leave your current room and when a chat message is received. Note	that sounds that are played to let a user know that they can't perform a specific action	cannot be disabled.		These APIs are no longer functional. They are now no-ops. As of GameSmith 3.3, the user	can control sound effects with the /sound command*/void		GS_EnableSound	(void);void		GS_DisableSound	(void);/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	If you are hosting a game, call GS_PlayerJoined() with a value of kGS_PlayerType, 	kGS_ObserverType, or kGS_AIType	to let everyone that a new player has joined your	game and what type of player it is.  This facilitates the drawing of icons next	to the games in the server window to represent the players in the game.  Since it is	conceivable that you add the ability to allow folks to join your game directly,	using standard NetSprocket Join Dialogs instead of the server, and since it is	possible that you can add new computer players at any time, it is necessary that	you tell the server about the joiner.  You do not need to call this function for	the host itself, so don't just blindly call it upon receiving a PlayerJoined message.			If you are hosting a game, call GS_PlayerLeft() with a value of kGS_PlayerType, 	kGS_ObserverType, or kGS_AIType	to let everyone that a player has left your	game and what type of player it is. 		The named player versions have been added to support the new Game Info dialog in GameSmith 3.2	They are the preferred API*/void 		GS_PlayerJoined			(GS_NetworkPlayerType playerType);void		GS_PlayerLeft			(GS_NetworkPlayerType playerType);void		GS_NamedPlayerJoined	(GS_NetworkPlayerType playerType, const char *playerName);void		GS_NamedPlayerLeft		(GS_NetworkPlayerType playerType, const char *playerName);/*  The parameters mean:	playerType			The type of player that has joined or left the game.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	These two functions tell the server that you have started or ended a game.  	If you use a ranking system, any started game that is not 	accompanied by an "end game" will be recorded as an incomplete game.	If you want your ranking system to be accurate, it is very important that	you call GS_ReportGameStart() from each player at the moment the game actually starts	(i.e. not when you have just joined and are waiting for players).  Then you must	call GS_ReportGameEnd() to tell the server that your game is over.  Once again, call	these functions from EACH PLAYER, not just the host.	NOTE:  Call these functions whether you use a ranking system or not.  It is important	for tracking the popularity of the Freeverse!  A good rule of thumb is, use these	functions whenever there are two or more human players.  (We don't need to track	games against the computer, even if they were started while connected to the Freeverse.)	SECOND NOTE:  We are transitioning over to a new method for tracking and ranking games	played.  The new method uses the functions GS_SendGameLineup() and GS_SendGameResults().	Once you transition over to the new method, you should discontinue using GS_ReportGameStart()	GS_ReportGameEnd(), GS_GetRatingPoints(), and GS_SetRatingPoints().	They will be maintained in the interface for backwards compatibility, but once you have	activated server-side ranking, these functions will do nothing.*/void 		GS_ReportGameStart(Boolean isRankable);void		GS_ReportGameEnd(Boolean isRankable, Boolean iWon);	/* ( Note: See GS_SendGameResults(). ) *//*  The parameters mean:	isRankable		A Boolean which tells whether this game will contribute to the					ranking statistics.  Pass false if you don't use a ranking system					or if this game should not be counted towards rank.  (For example, you					may not want to rank games that include AI players.  It's up to you.)	iWon			For GS_ReportGameEnd(), a Boolean which tells whether you won or					lost the game.----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	If you created your own networking (ie, GS_CreateNSpGames( false ) was called ), you need to call	this function when you terminate the hosting game.*/void 		GS_SendHostQuitting( void );/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	If your game makes use of the rating/ranking system, these two functions are	all you'll need to obtain and set the rating points for the local player.	NOTE:  IF you don't use a rating system, then don't call these functions.	SECOND NOTE:  We are transitioning over to a new method for tracking and ranking games	played.  The new method uses the functions GS_SendGameLineup() and GS_SendGameResults().	Once you transition over to the new method, you should discontinue using GS_ReportGameStart()	GS_ReportGameStart(), GS_GetRatingPoints(), and GS_SetRatingPoints().	They will be maintained in the interface for backwards compatibility, but once you have	activated server-side ranking, these functions will do nothing.*/OSStatus 	GS_GetRatingPoints(int *ratingPointsPtr);OSStatus	GS_SetRatingPoints(int ratingPoints);		/* ( Note: See GS_SendGameResults(). ) *//*  The parameters mean:	ratingPointsPtr		For the "Get" function, a pointer to an integer, which on return						will contain the current rating points of the local player. 	ratingPoints		For the "Set" function, an integer which tells the server how many						points the local player should now have.  This is not an amount						to add.  It is the new total points. ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_GameDispose() instead of NSpGame_Dispose() whenever you quit a	game, whether you were hosting or not.  The API will take care of the NSpGame_Dispose()	call as well as a few other things related to updating the game list in the server window.*/OSStatus	GS_GameDispose(NSpGameReference *whichGameReferencePtr);/*  The parameters mean:	whichGameReferencePtr	This is the NSpGameReference that was supplied when the new							game was started ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Call the function GS_HandleGameQuit() when a game where you created the networking stuff ends.	This will clear up a few things related to updating the game list in the server window.*/void		GS_HandleGameQuit(NSpGameReference whichGameReference);/*  The parameters mean:	whichGameReference		pass NULL to signal you created the game ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	You can let the server libraries know that your game is registered at any time using	GS_GameRegistered().  That way your customer doesn't need to Quit your game and relaunch	in order for the libraries to know the game is registered.  	When a game is not registered, GameSmith will "tag" their chat as coming from an unregistered player.    If your game is unregistered, you may want to give them a trial period before passing false*/OSStatus 	GS_GameRegistered(Boolean gameRegistered);/*  The parameters mean:	gameRegistered	Whether your game is registered or not.  ----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	When the client joins the server, it will pass the registration code you send here. You must	call this before calling GS_ServerConnect()	*/OSStatus 	GS_SetRegistrationCode(const char *registrationCode);/*  The parameters mean:	registrationCode	your gameÕs registration code. Limited to 50 characters max, paramErr will be	                    returned if the code is longer.----------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------- 	GS_LaunchURL	Provides a mechanism for launching the user's web browser (via Internet Config)	and opening the specified URL.	If this function returns an error, it probably	means that InternetConfig isn't installed.  You should probably notify the user that	"Couldn't access URL. Please make sure Internet Config is installed and configured correctly."*/OSStatus	GS_LaunchURL(const char *url);					/* carbon-bmp 1/19/2001 made it const *//*  The parameters mean:	url		The URL that you want to open.  ----------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------- 	GS_GetVersion	Returns the NumVersion of the GameSmithLib in the parameter numVersionPtr.	If a value of "false" is returned, the result is not valid and you cannot determine	the version.  You may call this at any time before or after GS_Init().  It doesn't	matter which you choose.*/Boolean 	GS_GetVersion(NMNumVersion *numVersionPtr);/*----------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------- 	GS_GetBuildVersion	Returns the internal build version of the GameSmith library. An example might be something	like "0711" or "Build 523". The internal build number's definition is reserved for internal	meaning. This API is provided for applications that want to provide some kind of detailed info.	If a value of "false" is returned, the result is not valid and you cannot determine	the version.  You may call this at any time before or after GS_Init().  It doesn't	matter which you choose.*/Boolean 	GS_GetBuildVersion(char *buffer, UInt32 bufferLength);/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	GS_ModalGetHostInfo and GS_HostAppleTalk	Together, these functions let the user to host a game on the local AppleTalk network.  This game	will not interact with the HMS Freeverse server in any way.  However, the game is entirely yours to	control, yours to dispose of, and you should not make any calls to the Freeverse Server on behalf of	this game (Such as GS_PlayerJoined/Left, GS_ReportGameStart/End, etc).  These AppleTalk functions are 	provided to you merely as a service.  (In a later version I may make it so you can still call the GS_() 	functions, and they will know whether they should really do anything with it.  It's a more subtle	problem than it seems.)	First, call GS_ModalGetHostInfo() to allow the user to select a game name and password.	Returns "false" if the user cancels the request at this point, "true" otherwise.  */// ######################################################//     THIS API IS GOING AWAY, PLEASE STOP USING IT// ######################################################Boolean		GS_ModalGetHostInfo(char *playerName, char *gameName, char *gamePassword, char *theFailReason);/*  The parameters mean:	playerName			The requested playerName.  You may enter "\0" as a requested name 						if you don't want a default name entered for the user.  Allocate 32						characters for this in your calling routine.	gameName			The requested name of the AppleTalk game.  Can be an empty string, but						I recommend that you supply a string of the type "Fred's Game", if Fred is the						name passed in for the previous parameter.  This name may be changed by the 						user during this function.   Allocate 32 characters for this in your 						calling routine.	gamePassword		The password that will be used to control entry into the NetSprocket game.  You						will probably want to supply an empty string for this function, unless						you store commonly used passwords in your preferences.  Allocate 32 characters						for this in your calling routine.	theFailReason		If there was a failure, this string will contain an explanation that you can						then display for the user.  Allocate at least 128 characters for this string						in the calling routine.	If the host attempt was not cancelled by the user in the previous call, you need to pass the 3 	parameters from that call into the function GS_HostAppleTalk()...*/// ######################################################//     THIS API IS GOING AWAY, PLEASE STOP USING IT// ######################################################Boolean		GS_HostAppleTalk(char *playerName, char *gameName, char *gamePassword, NSpGameReference *gameReferencePtr, char *theFailReason);							/*  The parameters mean:	playerName			The player name from the previous call.  May have changed.	gameName			The game name from the previous call.  May have changed.	gamePassword		The game password from the previous call.  May have changed.	gameReferencePtr	The NetSprocket game reference if the host attempt is successful.						Otherwise, this value will be NULL.	theFailReason		If there was a failure, this C String will contain an explanation that you can						then display for the user.  Allocate at least 128 characters for this string						in the calling routine.	This function returns "true" if the host attempt was successful, otherwise "false".	NOTE:	I could have performed the GS_ModalGetHostInfo() call for you within GS_HostAppleTalk(),			but since the former call displays a modal dialog box and then the latter call may block 			for a while, I thought it would be best to break these calls apart so that you can tidy up			whatever windows may have been invalidated by the first call.----------------------------------------------------------------------------------------------------*/																					/*---------------------------------------------------------------------------------------------------- 	GS_ModalGetJoinAddress and GS_JoinAppleTalk	Together, these functions let the user to join a game on the local AppleTalk network.  This game	will not interact with the HMS Freeverse server in any way.  However, the game is entirely yours to	control, yours to dispose of, and you should not make any calls to the Freeverse Server on behalf of	this game (Such as GS_PlayerJoined/Left, GS_ReportGameStart/End, etc).  These AppleTalk functions are 	provided to you merely as a service.  (In a later version I may make it so you can still call the GS_() 	functions, and they will know whether they should really do anything with it.  It's a more subtle	problem than it seems.)	First, call GS_ModalGetJoinAddress() to allow the user to change his player name and submit	a password.  Returns "false" if the user cancels the request at this point, "true" otherwise.  */														// ######################################################//     THIS API IS GOING AWAY, PLEASE STOP USING IT// ######################################################Boolean		GS_ModalGetJoinAddress(char *playerName, char *gamePassword, NSpAddressReference *addressPtr);/*  The parameters mean:	playerName			The requested playerName.  You may enter "\0" as a requested name 						if you don't want a default name entered for the user.  Allocate 32						characters for this in your calling routine.	gamePassword		The password that will be used to attempt entry into the NetSprocket game.  You						will probably want to supply an empty string for this function, unless						you store commonly used passwords in your preferences.  Allocate 32 characters						for this in your calling routine.	addressPtr			A pointer to the NSpAddressReference that will be passed into the next function. 						If upon dereferencing addressPtr you get NULL, then the call was not						successful due to some network error.  Think up something smart to tell the user						but don't call the next function.	If the join attempt was not cancelled by the user in the previous call, and address = *NSpAddressPtr	is not NULL, you need to pass all 3 parameters from that call into the function GS_JoinAppleTalk()...*/// ######################################################//     THIS API IS GOING AWAY, PLEASE STOP USING IT// ######################################################Boolean		GS_JoinAppleTalk(char *playerName, char *gamePassword, NSpAddressReference address, NSpGameReference *gameReferencePtr, char *theFailReason);/*  The parameters mean:	playerName			The player name from the previous call.  May have changed.	gamePassword		The game password from the previous call.  May have changed.	address				The dereferenced addressPtr from the previous call.  Do not pass in a						NULL value.	gameReferencePtr	The NetSprocket game reference if the join attempt is successful.						Otherwise, this value will be NULL.	theFailReason		If there was a failure, this C String will contain an explanation that you can						then display for the user.  Allocate at least 128 characters for this string						in the calling routine.	NOTE:	I could have performed the GS_ModalGetJoinAddress() call for you within GS_JoinAppleTalk(),			but since the former call displays a modal dialog box and then the latter call may block 			for a while, I thought it would be best to break these calls apart so that you can tidy up			whatever windows may have been invalidated by the first call.----------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------- 	GS_SendGameLineup and GS_SendGameResults	These functions are to be used in place of GS_ReportGameStart(), GS_ReportGameEnd(), 	GS_GetRatingPoints(), and GS_SetRatingPoints() if you decide to use the server-side ranking 	system (which you should).  Unlike the four functions that GS_SendGameLineup() and GS_SendGameResults()	replace, call these new functions only from the host.  Call GS_SendGameLineup() as soon as your 	network game actually starts (i.e. you are done waiting for players to join and the game has really 	started.)  Call GS_SendGameResults() as soon as your network game ends.	NOTE:  Call these functions whether the game is going to be ranked or not.  It is important	for tracking the popularity of the Freeverse!*/OSStatus GS_SendGameLineup(GS_GameResultsPtr theGameLineup);/*  The parameters mean:	theGameLineup	A pointer to the game results structure which contains the names and types of 					the players.  Your game populates these structures before calling this function.					You don't need to populate the "score" or "hasAccount" field.  */OSStatus GS_SendGameResults(GS_GameResultsPtr theGameResultsPtr, int customDataLength, void *customDataPtr);/*  The parameters mean:	theGameResultsPtr	A pointer to the game results structure which contains... you guessed it ...						the game results as described by the "GameResults" and "PlayerResults" structures						defined above.  Your game populates these structures before calling this function.						You don't need to populate the "hasAccount" field.  This structure will be supplied 						to your server-side ranking function.	customDataLength	The length (in bytes) of any custom data that you want sent to the server and passed						along to your server-side ranking function.  Pass a value of 0 if you have no custom						data to send.	customDataPtr		A pointer to the custom data that you want sent to the server and passed						along to your server-side ranking function.  Pass a value of "NULL" if you have no custom						data to send.----------------------------------------------------------------------------------------------------*//*  IMPORTANT NOTE:  THE FOLLOWING FUNCTIONS ARE NOT TRULY IMPLEMENTED YET.  THEY	ARE JUST PLACEHOLDERS IN THE API WHILE THE "HEADLESS" FUNCTIONALITY IS BEING	ADDED TO THE SOFTWARE.  DO NOT ATTEMPT TO USE THESE FUNCTIONS YET!!!!*//*----------------------------------------------------------------------------------------------------	Call the function GS_SetHeadless() prior to connecting to the server if your game is 	supposed to be "headless".  This is an uncommon arrangement in which you need to host 	your game on a machine that is not controlled by a client.  In this case, the game will 	appear in whatever room you specify (including all of them) but no associated player 	will appear in the various rooms' player lists.  Named constants for the various room	choices are "enum"ed above.*/OSStatus GS_SetHeadless(Boolean isHeadless, GS_RoomNumber roomNumber);/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Blah Blah Blah...*/Boolean GS_IsServerConnected(void);/*----------------------------------------------------------------------------------------------------*//*----------------------------------------------------------------------------------------------------	Blah Blah Blah...*/OSStatus GS_MakeGameAvailable(char *gameName, char *gamePassword);/*----------------------------------------------------------------------------------------------------*//**************************************************************************** * Downloads any image needed that is not already available locally or cached * * When GameSmith is first initialized it reads in the Rooms.xml file and queues * any <image> element not present in the packaged "GameSmith Data/Images" folder * or in the ~/Library/Application Support/Freeverse/GameSmith cache folder. * * Calling GS_ServerConnect will also begin downloading queued images, so this * API is not required. However, some clients may want to initiate image downloads * even before attempting to connect to the server. Especially apps that are aware * of whether or not an internet connection is already present. * * bmp 7/2/2002 */void GS_DownloadImages(void);/**************************************************************************** * Application needs to update the GameSmith libs. Before doing that, it must quit and restart */void GS_RestartToConnect(void);/* crt 8/5/2001 Reset compiler options to whatever they were before. *//**************************************************************************** * Convenience wrapper for StandardAlert * *	¥ alertType is defined in Dialogs.h * *	¥ errorTitle should be a short, concise, one sentence description of the problem. * *	¥ explanationMessage should be a more detailed, multiple sentence description of the problem. * *	¥ buttons are optional and can be NULL * *		- if all are null, just one button will be used: OK *		- otherwise these buttons are the buttons used in the dialog *		- putting a # at the end of the 2nd button makes it the default (with no "cancel" button) *		- putting a ! at the end of the 1st button makes it the cancel (escape key) button *		- a button titled "Cancel" in either the 1st or 2nd position is automatically make the cancel button (bound to escape key) *		- ! and # can be used together:  NULL, "Cancel#", "Revert!" *		- per HIG ! and # cannot be used on the button3 (left most on-screen) * * EXAMPLES: * *		¥ GSStandardAlert(kAlertCautionAlert, "Save Document", "Save changes to the document Ò^2Ó before closing?", "Don't Save","Cancel", "Save"); *		¥ GSStandardAlert(kAlertCautionAlert, "Revert to the last saved version of Ò^2Ó, "Reverting changes will discard all changes...", NULL, "Cancel#", "Revert!);" *		¥ GSStandardAlert(kAlertStopAlert, "You cannot modify this document", "This document is opened in Read Only mode meaning that you cannot make changes to it, you can only view or print it.", NULL, NULL, NULL); */DialogItemIndex GS_StandardAlert(AlertType alertType, const char * errorTitle, const char * explanationMessage, const char * button3, const char * button2, const char * button1);#pragma options align=reset#ifdef __cplusplus}#endif#endif		/*  __GS_SERVER_API__  */