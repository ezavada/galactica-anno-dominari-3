// Source for CBalloonApp class// updated for PowerPlant 2.2, 1/10/02, ERZ#ifndef CBALLOONAPP_H_INCLUDED#define CBALLOONAPP_H_INCLUDED#include "GenericUtils.h"#include "CBalloonApp.h"#include "CHelpAttach.h"#include <LArrayIterator.h>#include <LWindow.h>#include <UDrawingState.h>#include <UEnvironment.h>#include <UWindows.h>#include <UCursor.h>// ===========================================================================//		¥ CBalloonApp Class// ===========================================================================#define MOUSE_LINGER_TICKS	120// Static variablesLPane*	CBalloonApp::sHelpPane = nil;			// Cached pane for balloon displayLPane*	CBalloonApp::sLastHelpLine = nil;		// Cached pane for help line displayLPane*	CBalloonApp::sHelpLineDisplay = nil;	// pane into which help line is placedUInt32	CBalloonApp::sLastMouseMoveTick = 0xffffffff;	// when did the mouse last move?bool	CBalloonApp::sMouseLingerActive = false;bool	CBalloonApp::sMouseLingerEnabled = true;// ---------------------------------------------------------------------------//		¥ CBalloonApp// ---------------------------------------------------------------------------//	ConstructorCBalloonApp::CBalloonApp() {	mHasBalloonHelp = UEnvironment::HasGestaltAttribute(gestaltHelpMgrAttr,gestaltHelpMgrPresent);}// Handle cursor motion for help balloonsvoid CBalloonApp::AdjustCursor(	const EventRecord	&inMacEvent){	bool		useArrow = true;	// Assume cursor will be the Arrow		WindowPtr	macWindowP;    static  Point   lastGlobalMouse;	Point		globalMouse = inMacEvent.where;	if (::EqualPt(globalMouse, lastGlobalMouse)) {	    // mouse hasn't moved, don't adjust cursor	    return;	}	lastGlobalMouse = globalMouse;	WindowPartCode	part = ::MacFindWindow(globalMouse, &macWindowP);	mMouseRgn.Clear();				// Start with an empty mouse region	if (macWindowP != nil) {		// Mouse is inside a Window		LWindow	*theWindow = LWindow::FetchWindowObject(macWindowP);		if ( (theWindow != nil)  &&			// Mouse is inside an active			 theWindow->IsActive()  &&		//   and enabled PowerPlant			 theWindow->IsEnabled() ) {		//   window			 			useArrow = false;			Point	portMouse = globalMouse;			theWindow->GlobalToPortPoint(portMouse);						if (part == inContent) {				theWindow->AdjustContentMouse(portMouse, inMacEvent, mMouseRgn);			} else {				theWindow->AdjustStructureMouse(part, inMacEvent, mMouseRgn);			}// -------------------- Start of help line code ---------------------			UInt32 tick = ::TickCount();			// Find the top pane under the mouse			LPane* hitPane = theWindow->FindDeepSubPaneContaining(portMouse.h, portMouse.v);			if (hitPane!=sLastHelpLine) {		// Check if it's different from the last time				if (CBalloonApp::sHelpLineDisplay) {	// clear old display					CBalloonApp::sHelpLineDisplay->SetDescriptor("\p");					CBalloonApp::sHelpLineDisplay->UpdatePort();				}				sLastHelpLine = hitPane;				// Cache it				sLastMouseMoveTick = tick;	// save the time we last moved				// when balloon help is off, we need to check for a balloon drawn				// because of a lingering mouse and remove it.			  #if BALLOON_SUPPORT				if (sMouseLingerActive) {					sMouseLingerActive = false;					::HMRemoveBalloon();	// turn off balloon help, which was only active to show					::HMSetBalloons(false);	// this one item.				}			  #endif // BALLOON_SUPPORT				if (hitPane) {					hitPane->ExecuteAttachments(msg_ShowHelpLine, (void*) hitPane);				}			}#if BALLOON_SUPPORT	// --------------- Start of balloon help support code ---------------			if (mHasBalloonHelp) {				bool balloonHelpActive = ::HMGetBalloons();				// ERZ Mod, v1.2fc1, check for lingering mouse and show balloon				// ERZ Mod, v1.2fc4, only permit mouse linger in windows with UserCon set to 'help' 				if (sMouseLingerEnabled && !sMouseLingerActive						&& !balloonHelpActive && (theWindow->GetUserCon() == 'help')) {					// mouse is not already lingering, and balloon help is not active, so see if					// we need to activate balloon help because of a lingering mouse					if (hitPane && ((sLastMouseMoveTick + MOUSE_LINGER_TICKS) < tick)) {						sMouseLingerActive = true;	// mouse lingered in same pane long enough to show the balloon						::HMSetBalloons(true);	// turn on balloon help so we can display this balloon						balloonHelpActive = true;					}				}				if (balloonHelpActive) {	// Only do if balloons currently being shown					if (hitPane!=sHelpPane) {		// Check if it's different from the last time						sHelpPane = hitPane;		// Cache it						if (hitPane) {	// Execute the CHelpAttach if the pane exists							hitPane->ExecuteAttachments(msg_ShowHelp, (void*) hitPane);						}					}				}			}// --------------- End of balloon help support code ---------------#endif // BALLOON_SUPPORT		}	}		if (mMouseRgn.IsEmpty()) {		// No Pane set the mouse region		mMouseRgn = ::GetGrayRgn();	// Gray region is desktop minus menu bar											// Add bounds of main device so mouse									//   region includes the menu bar		GDHandle	mainGD = ::GetMainDevice();		mMouseRgn += (**mainGD).gdRect;											// Exclude structure regions of all									//   active windows		UWindows::ExcludeActiveStructures(mMouseRgn);	}			if (useArrow) {					// Window didn't set the cursor		UCursor::SetArrow();		// Default cursor is the arrow		}	}#endif // CBALLOONAPP_H_INCLUDED