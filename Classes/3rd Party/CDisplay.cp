/* CDisplay.cp - display manager interface. 	by David Oster February 1997.	Revision info:	based on example generic C code by Mike Marinkovich at apple.com	October 1996 - Kent Johnson pointed out that powerplant keeps track of the GrayRegion		in UScreenPort, and that we should tell UScreenPort that GrayRgn has changed. He 		sent me code!	November 1996 - Steve R Webster <srw@zanshin.com> points out that trying to set the		standard zoom state of a non-Powerplant, non-zoomable window makes the machine		crash. He also pointed out a bug in GetOwningDevice (fixed)	mid-November 1996 - (1) we get the true title height using routines in UWindows that work		even if the window is invisible.		(2) If the display is changed using the control strip, then LMGetWindowList() lies:		it gives us a list length 1 of the ControlStrip window.		(3) if PowerPlant throws, catch it before we get back the operating system.	February 1997 - Steve informs me that AEGetKeyPtr wants to write a size. I passed nil.		fixed.		We check that the display manager exists. if it does, we register	a callback (or an AppleEvent Handler, if it is version 1 of the Display Manager)	that the O.S. will call when the display environment changes.	When that callback is called, for each display that changed, we find the effected	windows, and move (and resize) as necessary. If the window is a PowerPlant window,	we call the appropriate PowerPlant function, othewise we call the tollbox function.	Hardest part to debug: invisible windows that get moved off of any screen.>>>	Not done: cache position info, so if the user resizes the display, then		resizes it back, we can put each windows back where it was. */#include "CDisplay.h"#include <Displays.h>#include <UScreenPort.h>#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#include <LPeriodical.h>/* When we get called by the device manager, if it is called from the control strip, the	wrong window list is in place (at least in 7.5.3 rev 2). So, we append a record to the	LArray sDeviceList, and create a CDeviceChanger. The CDeviceChanger will run at the next	idle event time, and move the windows around for us. */class CDeviceChanger : public LPeriodical {public:						CDeviceChanger();	virtual				~CDeviceChanger();	virtual void		SpendTime(const EventRecord		&inMacEvent);	static CDeviceChanger*	sDeviceChange;};#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif/* HandleNotification - handle notification will put these on sDeviceList */typedef struct DeviceChangeRec{	DisplayIDType 	displayID;	Rect			newRect;}DeviceChangeRec;CDeviceChanger*	CDeviceChanger::sDeviceChange = nil;	// created by HandleNotification, destroys itselfstatic LArray*			sDeviceList = nil;		// list of work for DeviceChanger to do.	еее ERZ, changed to LArray#define kFudgeFactor		4		// fudge factor for boundary around windowstatic OSErr InstallDMNotification(void);static OSErr InstallAEDMNotification(void);static pascal	void WorldChangedProc(AppleEvent *event);static pascal	OSErr DoAEDisplayUpdate(const AppleEvent* event,AppleEvent* reply, long refCon);static OSErr	HandleNotification(AppleEvent *event);static OSErr	HandleDeviceChange(DisplayIDType displayID, Rect *newRect);static Boolean	OutOfBoundsRect(GDHandle gd, WindowRef window, Rect screenRect);static void		MoveInbounds(WindowRef window, GDHandle gd, Rect screenRect);static GDHandle	GetOwningDevice(WindowRef window);static GDHandle	GetGreatestDevice(WindowRef window);static void		GetWindowRect(WindowRef window, Rect *windRect);static void		ResizeInbounds(WindowRef window, GDHandle gd, Rect screenRect);static void		ResetStdState(WindowRef window);static void		SendResized(WindowRef window);	// еее ERZ additionCDeviceChanger::CDeviceChanger() : LPeriodical() {}CDeviceChanger::~CDeviceChanger(){	if(this == sDeviceChange){		sDeviceChange = nil;	}}/* SpendTime - do our enqueued work, then die. */void CDeviceChanger::SpendTime(const EventRecord& /*inMacEvent */){	if(nil != sDeviceList){		LArrayIterator	iter(*sDeviceList, LArrayIterator::from_Start);	// еее ERZ, changed to LArrayIterator		DeviceChangeRec	dc;			while(iter.Next(&dc)){			HandleDeviceChange(dc.displayID, &dc.newRect);		}		sDeviceList->RemoveItemsAt(0x7FFFFFFFL, 1);	}	delete this;	// done the work. vanish.}/* EnqueueDeviceChange - record command for the benefit of our periodical. */static OSErr	EnqueueDeviceChange(DisplayIDType displayID, const Rect& newRect){	try{		DeviceChangeRec	dc;		dc.displayID = displayID;		dc.newRect = newRect;		if(nil != sDeviceList){			sDeviceList->InsertItemsAt(1, LArray::index_Last, &dc, sizeof dc);	// еее ERZ, changed to LArray		}		if(nil == CDeviceChanger::sDeviceChange){			CDeviceChanger::sDeviceChange = new CDeviceChanger;			if(nil != CDeviceChanger::sDeviceChange){				CDeviceChanger::sDeviceChange->StartIdling();			}		}	}catch(ExceptionCode inErr){		return inErr;	}	return noErr;}/* Init -  */void CDisplay::Init(){	Boolean		mHasDM;		// True if Display Manager exists	Boolean		mHasDMTwo;	// " " true in version 2.	OSErr		errCode;	long		response;		// check to see if the Display Manager is present. If it is 	// then we have a PowerMac or System 7.5.	mHasDM = (noErr == (errCode = Gestalt(gestaltDisplayMgrAttr, &response)) && 		(response & (1 << gestaltDisplayMgrPresent)));	mHasDMTwo = false;	if( ! mHasDM){		return;	}	if((noErr == (errCode = Gestalt(gestaltDisplayMgrVers, (long*)&response)))){		mHasDMTwo = (response >= 0x00020000);	// check for Display Manager 2.0	}	// we have DM 2.0 so install	// world changed notification proc	if(mHasDMTwo){		errCode = InstallDMNotification();	// we have DM 1.0 so install AppleEvent Notification	}else{		errCode = InstallAEDMNotification();	}	ThrowIfOSErr_(errCode);	sDeviceList	= new LArray(sizeof(DeviceChangeRec));	// еее ERZ, changed to LArray}/* Stop */void CDisplay::Stop(){	delete CDeviceChanger::sDeviceChange;	delete sDeviceList;}/*  GetWTitleHeight - return the height of the titlebar for a given	window. If the window is nil a zero height will be returned.	We call the code in UWindows, which will work even if the window is		invisible. */static short GetWTitleHeight(WindowRef window){	short	 tHeight;	tHeight = 0;	if (nil != window){#if 1		tHeight = UWindows::GetWindowContentRect(window).top -			UWindows::GetWindowStructureRect(window).top;		return tHeight;#else		tHeight = 19;	// a reasonable guess		if(IsWindowVisible(window)){			RgnHandle	cRgn, sRgn;			cRgn = nil;			sRgn = nil;			if(nil != (cRgn = NewRgn()) && nil != (sRgn = NewRgn())){				GetWindowContentRgn(window, cRgn);				GetWindowStructureRgn(window, sRgn);				tHeight = (**cRgn).rgnBBox.top - (**sRgn).rgnBBox.top;			}			if(nil != cRgn){				DisposeRgn(cRgn);			}			if(nil != sRgn){				DisposeRgn(sRgn);			}		}#endif	}	return tHeight;}/* InstallDMNotification - tell DM that we want to be notified by callback. */static OSErr InstallDMNotification(void){	OSErr	err;	ProcessSerialNumber		thePSN;		// use our process number so when we get called	// the A5 is ours	if(noErr == (err = ::MacGetCurrentProcess(&thePSN))){		err = DMRegisterNotifyProc(NewDMNotificationUPP(WorldChangedProc), &thePSN);	}	return err;}	/* InstallAEDMNotification - tell DM that we want to be notified by AE. */static OSErr InstallAEDMNotification(void){	return AEInstallEventHandler(kCoreEventClass, kAESystemConfigNotice,								NewAEEventHandlerUPP(DoAEDisplayUpdate),								0L, false);}/*	WorldChangedProc - Display Manager calls this proc when a depth or  					   mode change is made. Your application should					   handle window repositioning here.  *///static pascal OSErr WorldChangedProc(AppleEvent *event){static pascal void WorldChangedProc(AppleEvent *event){//	return HandleNotification(event);	HandleNotification(event);}/*	DoAEDisplayUpdate - Display Manager calls this proc when a depth or  					    mode change is made. Your application should					    handle window repositioning here.  */static pascal OSErr DoAEDisplayUpdate(const AppleEvent *event,AppleEvent *reply, long refCon){#pragma unused (reply, refCon)	return HandleNotification(const_cast<AppleEvent*>(event));}/* HandleNotification - handle the AppleEvent returned by either the 					  	 callback or the AppleEvent procedure. */static OSErr HandleNotification(AppleEvent *event){	OSErr					err;	GrafPtr					oldPort;	AEDescList				displayList;	AEDescList				aDisplay;	AERecord				oldConfig,newConfig;	AEKeyword				tempWord;	DisplayIDType			displayID;	unsigned long			returnType;	long					count, dontCare;	Rect					oldRect, newRect;		GetPort(&oldPort);	displayList.dataHandle = nil;	// Get a list of the displays from the Display Notice AppleEvent.	err = AEGetParamDesc(event,kAEDisplayNotice,typeWildCard,&displayList);	// How many items in the list	if(noErr == err){ err = AECountItems(&displayList,&count); }				while(noErr == err && count > 0){	 // Loop through the list.		aDisplay.dataHandle = nil;		oldConfig.dataHandle = nil;		newConfig.dataHandle = nil;		if(noErr == err){err = AEGetNthDesc(&displayList, count, typeWildCard, &tempWord, 									&aDisplay); }				// Get the Old Rect.					if(noErr == err){ err = AEGetNthDesc(&aDisplay, 1, typeWildCard, &tempWord, 						   &oldConfig); }		if(noErr == err){ err = AEGetKeyPtr(&oldConfig, keyDeviceRect, typeWildCard, 						  &returnType, &oldRect, 8, &dontCare); }				// Get the DisplayID so we can get the GDevice later.						if(noErr == err){ err = AEGetKeyPtr(&oldConfig, keyDisplayID, typeWildCard, 						  &returnType, &displayID, 8, &dontCare); }		// Get the New Rect.						if(noErr == err){ err = AEGetNthDesc(&aDisplay, 2, typeWildCard, &tempWord, 						   &newConfig); }		if(noErr == err){ err = AEGetKeyPtr(&newConfig, keyDeviceRect, typeWildCard, 						  &returnType, &newRect, 8, &dontCare); }				// If the New and Old rects are not the same then we can assume		// the GDevice has changed and we need to rearrange the windows.		if(err == noErr && ! ::MacEqualRect(&newRect, &oldRect)){			err = EnqueueDeviceChange(displayID, newRect);		}		count--;		if(nil != aDisplay.dataHandle){ AEDisposeDesc(&aDisplay); }		if(nil != oldConfig.dataHandle){ AEDisposeDesc(&oldConfig); }		if(nil != newConfig.dataHandle){ AEDisposeDesc(&newConfig); }	}		if(nil != displayList.dataHandle){ AEDisposeDesc(&displayList); }	::MacSetPort(oldPort);	return err;}/* HandleDeviceChange - called when the oldconfig is different from  newconfig. Will check all windows on affected device and move if needed. Note: we use LMGetWindowList(), since we also want to move invisible windows. */static OSErr HandleDeviceChange(DisplayIDType displayID, Rect *newRect){	OSErr		err = noErr;	GDHandle	gd;	WindowRef	window;		// Force rebuild of screen port - Kent Johnson October 1996	UScreenPort::Dispose();	// Get the GDevice from the DisplayID.	err = DMGetGDeviceByDisplayID((DisplayIDType) displayID, &gd, false);	if(err == noErr && gd != nil){		for(window = (WindowPtr) LMGetWindowList(); window != nil; window = (WindowRef)(((WindowPeek)window)->nextWindow)){			::MacSetPort(window); 			// If the window is mostly on this device			if(gd == GetOwningDevice(window)){				if(OutOfBoundsRect(gd, window, *newRect)){					MoveInbounds(window, gd, *newRect); 					if(OutOfBoundsRect(gd, window, *newRect)){						ResizeInbounds(window, gd, *newRect);					} else {						SendResized(window);	// еее ERZ change					}				} else {					SendResized(window);	// еее ERZ change				}				ResetStdState(window);			}			}	}	return err;	}/* OutOfBoundsRect -  check to see if the window is out of the device rect. */static Boolean OutOfBoundsRect(GDHandle gd, WindowRef window, Rect screenRect){	Boolean		out = false;	Rect		windRect;	short		mHeight = 0;		GetWindowRect(window, &windRect);		if (gd == GetMainDevice())		mHeight = GetMBarHeight();	if ((windRect.right > screenRect.right) || (windRect.bottom > screenRect.bottom))		out = true;	if ((windRect.left < screenRect.left) || (windRect.top < screenRect.top + mHeight))		out = true;		return out;	}/* MoveInbounds -  Move window on to desired device */static void MoveInbounds(WindowRef window, GDHandle gd, Rect screenRect){	Rect		bounds;	short		mHeight = 0;	Point		globalPos;	short		titleBarHeight;	GetWindowRect(window, &bounds);	if (gd == GetMainDevice())		mHeight = GetMBarHeight();		titleBarHeight = GetWTitleHeight(window);	globalPos.h = bounds.left;	globalPos.v = bounds.top + titleBarHeight;		// we want to make the left-top a priority so adjust it first	// as to override the bottom, right movements. This is so we	// can resize the window later. 		if (((bounds.right - bounds.left) > (screenRect.right - screenRect.left)) ||		((bounds.bottom - bounds.top) > 		((screenRect.bottom - screenRect.top) - mHeight))) {				// adjust left		if (bounds.left < screenRect.left){			globalPos.h = screenRect.left + kFudgeFactor;		}		// adjust top		if (bounds.top < screenRect.top + mHeight){			globalPos.v = screenRect.top + titleBarHeight + mHeight + kFudgeFactor;		}	}else{		// adjust left		if (bounds.left < screenRect.left){			globalPos.h = screenRect.left + kFudgeFactor;		}else{			// adjust right			if (bounds.right > screenRect.right){				globalPos.h = (screenRect.right - (bounds.right - bounds.left)) - kFudgeFactor;			}		}				// adjust top		if (bounds.top < screenRect.top + mHeight){			globalPos.v = screenRect.top + titleBarHeight + mHeight + kFudgeFactor;		}else {			// adjust bottom			if (bounds.bottom > screenRect.bottom){				globalPos.v = (screenRect.bottom -  kFudgeFactor -						  (bounds.bottom - bounds.top) + mHeight);			}		}			}	LWindow *win;	if(nil != (win = LWindow::FetchWindowObject(window))){		win->DoSetPosition(globalPos);	}else{		::MacMoveWindow(window, globalPos.h, globalPos.v,false);	}	}/* GetWindowRect - return actual window rect in global coords */static void GetWindowRect(WindowRef window, Rect *windRect){		*windRect = window->portRect;		// add the titlebar height for actual height	windRect->top -= GetWTitleHeight(window);		LocalToGlobal(&topLeft(*windRect));	LocalToGlobal(&botRight(*windRect));}/* GetGreatestDevice - find the device that holds the greatest area of the window. */static GDHandle GetGreatestDevice(WindowRef window){	GDHandle	gd;	GDHandle	savedGD;	Rect		portRect;	Rect		foundRect;	long		size;	long		greatest = 0;	portRect = window->portRect;	LocalToGlobal(&topLeft(portRect));	LocalToGlobal(&botRight(portRect));	savedGD = nil;		// Loop through the device list	for(gd = DMGetFirstScreenDevice(dmOnlyActiveDisplays) ; gd != nil ; gd = DMGetNextScreenDevice(gd, dmOnlyActiveDisplays)) {			if(SectRect(&portRect, &(**gd).gdRect, &foundRect)) {			size = ((long)(foundRect.right - foundRect.left) * 				   (long)(foundRect.bottom - foundRect.top));						if(greatest < size){				greatest = size;				savedGD = gd;		// save the greatest device			}			}	}	return savedGD;}/* GetClosestDevice - return gd of device that is closest to window. */static GDHandle GetClosestDevice(WindowRef window){	GDHandle	gd;	GDHandle	savedGD;	Rect		gdRect, portRect;	long		distance;	long		smallest = 0x7FFFFFFFL;	Point		gdCenter, portCenter;	portRect = window->portRect;	LocalToGlobal(&topLeft(portRect));	LocalToGlobal(&botRight(portRect));	portCenter.h = (portRect.right - portRect.left)/2;	portCenter.v = (portRect.bottom - portRect.top)/2;	savedGD = nil;		// Loop through the device list	for(gd = GetDeviceList() ; gd != nil ; gd = GetNextDevice(gd)) {		if(TestDeviceAttribute(gd, screenDevice) && TestDeviceAttribute(gd, screenActive)) {			gdRect = (**gd).gdRect;			gdCenter.h = (gdRect.right - gdRect.left)/2;			gdCenter.v = (gdRect.bottom - gdRect.top)/2;			// actually the distance squared.			distance =  (gdCenter.h-portCenter.h)*(long)(gdCenter.h-portCenter.h) + 						(gdCenter.v-portCenter.v)*(long)(gdCenter.v-portCenter.v);						if(distance < smallest){				smallest = distance;				savedGD = gd;		// save the smallest device			}			}		}	return savedGD;}/* GetOwningDevice - the owning device is a Device Manager active device that	either holds the bulk of the window, or if the window is not on any	device, the device the window is closest to. */static GDHandle GetOwningDevice(WindowRef window){	GDHandle	gd;	if(nil != (gd = GetGreatestDevice(window))){		return gd;	}	return GetClosestDevice(window);}/* ResizeInbounds -  resize the window to fit in the graphics device */static void ResizeInbounds(WindowRef window, GDHandle gd, Rect screenRect){	Rect		windRect;	short		h;	short		v;	windRect = window->portRect;	// make the window bounds the size of the gdRect	// less the fudge factor.	h = windRect.right - windRect.left;	v = windRect.bottom - windRect.top;	if (h > screenRect.right - screenRect.left) {		h = ((screenRect.right - screenRect.left) - (kFudgeFactor * 2));	}		if (v > screenRect.bottom - screenRect.top) {		v = ((screenRect.bottom - screenRect.top) - (kFudgeFactor * 2));				// If we are on the main device then subtract the mBar		// height plus a fudge factor for a boundary. 		if (gd == GetMainDevice()) {			v -= (GetMBarHeight() + GetWTitleHeight(window));		}	}			LWindow*	win;		if(nil != (win = LWindow::FetchWindowObject(window))){		if(win->HasAttribute(windAttr_Resizable)){			Rect		r;			WindowPtr	port;			GetPort(&port);			::MacSetPort(window);			topLeft(r) = topLeft(window->portRect);			LocalToGlobal(&topLeft(r));			r.right = r.left + h;			r.bottom = r.top + v;			if (win->ExecuteAttachments(msg_DisplayManagerResize, win))	{ // еее ERZ change				win->DoSetBounds(r);			}			::MacSetPort(port);		} else {				// send a resize even to non-resizable windows, just in case			win->ExecuteAttachments(msg_DisplayManagerResize, win); // еее ERZ change		}	} else{		SizeWindow(window, h, v, true);	}}/* IsZoomable - true if this window can be zoomedNote: 11/4/96 David Oster: this function exists to make sure we don't try to set the	zoom structures of a window that doesn't have zoom structures. However, My tests	do not yet show that this _ever_ returns true, and it won't be compatible with	Copland's opaque window structures. */static Boolean IsZoomable(WindowRef win){	Handle	dataHandle;	dataHandle = * (Handle *) (((UInt8 *) win) + sizeof(GrafPort) + 0x16);	return nil != dataHandle && sizeof(WStateData) == GetHandleSize(dataHandle);}/* ResetStdState - since we are now on a different size screen we need					to change the stdState window size so our zooming					will work properly. */ static void	ResetStdState(WindowRef window){	Rect		screenRect;		screenRect = window->portRect;	LocalToGlobal(&topLeft(screenRect));	LocalToGlobal(&botRight(screenRect));		LWindow*	win;		if(nil != (win = LWindow::FetchWindowObject(window))){		if(win->HasAttribute(windAttr_Zoomable)){			Rect	r;					win->CalcStandardBoundsForScreen(screenRect, r);			SetWindowStandardState(window, &r);		}	}else if(IsZoomable(window)){		SetWindowStandardState(window, &screenRect);	}}// еее ERZ Begin Additionsstatic voidSendResized(WindowRef window) {	LWindow*	win;		if(nil != (win = LWindow::FetchWindowObject(window))){		win->ExecuteAttachments(msg_DisplayManagerResize, win);	}}#pragma mark-voidCFullScreenWindAttach::ExecuteSelf(MessageT, void *ioParam) { //inMessage	LWindow* wind = (LWindow*)ioParam;	GrafPtr windP = wind->GetMacPort();		Rect strucRect = UWindows::GetWindowStructureRect(windP);	GDHandle dominantDevice = UWindows::FindDominantDevice(strucRect);	Rect screenRect = (**dominantDevice).gdRect;	if (dominantDevice == ::GetMainDevice()) {		screenRect.top += ::GetMBarHeight(); // don't overwrite menu bar on main device	}	wind->DoSetBounds(screenRect);	// always resize to screen in full screen mode	SetExecuteHost(false);}