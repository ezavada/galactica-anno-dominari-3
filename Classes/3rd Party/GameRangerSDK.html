<HTML><HEAD><TITLE>GameRanger Library</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><H2><U>Adding Support for GameRanger</U></H2>(Copyright &copy; 1999-2002 by Scott Kevill)<p><I><B>December 6, 2000</B><BR><B>Added <TT><A HREF="#GRHasProperty">GRHasProperty</A></TT>&nbsp; and<TT><A HREF="#GRIsGameRangerInstalled">GRIsGameRangerInstalled</A></TT>&nbsp;for convenience.</B><P>July 20, 2000<BR><Fixed a bug where <TT><A HREF="#GRGetJoinAddressStr">GRGetJoinAddressStr</A></TT> occasionallyreturned an incorrect address. Replaced use of LMGetTime() with GetDateTime() for Carbon compatibility.<P>April 6, 2000<BR>Extended score reporting to include player IDs/references to identify the scores.<P>December 4, 1999<BR>Added <TT><A HREF="#GRGetJoinAddressStr">GRGetJoinAddressStr</A></TT> &nbsp;for convenience.<P>September 20, 1999<BR>A number of changes have been made to simplify this SDK. The AppleEvent support is nolonger encouraged, but will continue to work, and the previous documentation is<A HREF="GameRanger(Old).html">preserved</A>.<P></I><UL><LI><A HREF="#STARTUPCMD">Receiving the host/join command from GameRanger at startup</A><LI><A HREF="#RESUMECMD">Receiving the host/join command from GameRanger after resuming</A><LI><A HREF="#HOSTING">Hosting</A><LI><A HREF="#JOINING">Joining</A><LI><A HREF="#SCORING">Scoring</A><LI><A HREF="#PROPERTIES">Properties</A><LI><A HREF="#OPENINGGR">Opening GameRanger</A></UL><A HREF="#NSp">NetSprocket Helpers</A><BR><A HREF="#REF">Function Reference</A><P>Use the included <B>GRTest</B> application to test your game's support. While this is happening, GRTestwill play sounds in the background, so you can tell that the calls are being made while your game isfrontmost.<P>If you have any questions or comments or if there is anything you would like to see added, please email me.<BR><B>Scott Kevill</B><BR><B><A HREF="mailto:developer@GameRanger.com">developer@GameRanger.com</A></B><P><HR SIZE="4"><A NAME="STARTUPCMD"></A><H3><U>Receiving the host/join command from GameRanger at startup</U></H3>During your startup process, call<TT><A HREF="#GRCheckFileForCmd">GRCheckFileForCmd</A></TT> and if <TT>true</TT> is returned,call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd</A></TT> and skip any intro movies and set-up menus, and host/join the game.<P>At any point, these inexpensive calls can be made to determine which parts of menus or intros to skip:<BR><UL><TT><A HREF="#GRIsCmd">GRIsCmd</A></TT><BR><TT><A HREF="#GRIsHostCmd">GRIsHostCmd</A></TT><BR><TT><A HREF="#GRIsJoinCmd">GRIsJoinCmd</A></TT><P></UL><HR><A NAME="RESUMECMD"></A><H3><U>Receiving the host/join command from GameRanger after resuming</U></H3>If your game allows switching out to other applications, you should try to accept host/join commands after resuming.This allows a player to switch back to GameRanger to choose someone new to play against without having to quit andrelaunch the game.<P>After resuming call<TT><A HREF="#GRCheckFileForCmd">GRCheckFileForCmd</A></TT> and if <TT>true</TT> is returned,abort the current game (if any) and any menus, and host/join the game.<P>If there was a game in progress already, do not call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd</A></TT>immediately. During the abort process you will still need the information about the current command(eg. <TT><A HREF="#GRIsHostCmd">GRIsHostCmd</A></TT> to determine if you need to call<TT><A HREF="#GRHostClosed">GRHostClosed</A></TT>). Once the aborting is complete(and perhaps returned to the main menu) the code can call <TT><A HREF="#GRIsWaitingCmd">GRIsWaitingCmd</A></TT>and then <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd</A></TT> to continue starting a new game.<P>If there was not a game in progress, then you can just call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd</A></TT>and start the new game.<P><HR><A NAME="HOSTING"></A><H3><U>Hosting</U></H3>Begin a game with these optional calls to specify settings:<BR><UL><TT><A HREF="#GRGetPlayerName">GRGetPlayerName</A></TT><BR><TT><A HREF="#GRGetHostGameName">GRGetHostGameName</A></TT><BR><TT><A HREF="#GRGetHostMaxPlayers">GRGetHostMaxPlayers</A></TT><BR><TT><A HREF="#GRGetPortNumber">GRGetPortNumber</A></TT><BR>(If you are using NetSprocket then there are <A HREF="#NSp">helpers</A> to make this part even easier.)<P><TT><A HREF="#GRGetPlayerIconData">GRGetPlayerIconData</A></TT> / <TT><A HREF="#GRGetPlayerIconSuite">GRGetPlayerIconSuite</A></TT> (optional)<P><TT><A HREF="#GRGetPropertyStr">GRGetPropertyStr</A></TT><BR><TT><A HREF="#GRGetPropertyVal">GRGetPropertyVal</A></TT><BR>(For any options defined specifically for your game)<BR></UL>When ready to accept connections from clients, call<BR><UL><TT><A HREF="#GRHostReady">GRHostReady</A></TT><BR></UL>At this stage, the game may have it's own pre-game lounge where various options are set by all players,otherwise the following <TT><A HREF="#GRGameBegin">GRGameBegin</A></TT> would be called immediately.<P>When the player is actually in the game and game play has started, call<UL><TT><A HREF="#GRGameBegin">GRGameBegin</A></TT><BR></UL>If the player leaves the game early without it ending normally or if their internet connection drops, call<UL><TT><A HREF="#GRGameAbort">GRGameAbort</A></TT><BR></UL>At the end of the game (or before aborting - optional), report the scores by calling<UL><TT><A HREF="#GRStatScore">GRStatScore</A></TT> (for this player) and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT> (once for each other player)<BR></UL>And then call<UL><TT><A HREF="#GRGameEnd">GRGameEnd</A></TT><BR></UL>If there are multiple rounds, call the<TT><A HREF="#GRGameBegin">GRGameBegin</A></TT> ...<TT><A HREF="#GRGameEnd">GRGameEnd</A></TT> sequence for each round. For example, in Quake, each level played would be a round.<P>When the game has completely ended, call<BR><UL><TT><A HREF="#GRHostClosed">GRHostClosed</A></TT></UL><B>Summary</B><BR><UL><TT><A HREF="#GRHostReady">GRHostReady</A></TT><BR><UL><TT><A HREF="#GRGameBegin">GRGameBegin</A></TT><BR>. . . game play . . .<BR><TT><A HREF="#GRStatScore">GRStatScore</A></TT><BR><TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT><BR><TT><A HREF="#GRGameEnd">GRGameEnd</A></TT><BR>. . . repeat above loop for any further rounds . . .<BR></UL><TT><A HREF="#GRHostClosed">GRHostClosed</A></TT><BR>. . . optionally return to GameRanger via switching or quitting . . .<BR></UL><HR><A NAME="JOINING"></A><H3><U>Joining</U></H3>Begin a game with these calls to specify settings:<BR><UL><TT><A HREF="#GRGetJoinAddress">GRGetJoinAddress</A></TT> (<B>required</B>) or <TT><A HREF="#GRGetJoinAddressStr">GRGetJoinAddressStr</A></TT><BR><TT><A HREF="#GRGetPlayerName">GRGetPlayerName</A></TT> (optional)<BR><TT><A HREF="#GRGetPortNumber">GRGetPortNumber</A></TT> (optional)<BR>(If you are using NetSprocket then there are <A HREF="#NSp">helpers</A> to make this part even easier.)<P><TT><A HREF="#GRGetPlayerIconData">GRGetPlayerIconData</A></TT> / <TT><A HREF="#GRGetPlayerIconSuite">GRGetPlayerIconSuite</A></TT> (optional)<P><TT><A HREF="#GRGetPropertyStr">GRGetPropertyStr</A></TT><BR><TT><A HREF="#GRGetPropertyVal">GRGetPropertyVal</A></TT><BR>(For any options defined specifically for your game)<BR></UL>When the player is actually in the game and game play has started, call<UL><TT><A HREF="#GRGameBegin">GRGameBegin</A></TT><BR></UL>If the player leaves the game early without it ending normally or if their internet connection drops, call<UL><TT><A HREF="#GRGameAbort">GRGameAbort</A></TT><BR></UL>At the end of the game (or before aborting - optional), report the scores by calling<UL><TT><A HREF="#GRStatScore">GRStatScore</A></TT> (for this player) and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT> (once for each other player)<BR></UL>And then call<UL><TT><A HREF="#GRGameEnd">GRGameEnd</A></TT><BR></UL>If there are multiple rounds, call the<TT><A HREF="#GRGameBegin">GRGameBegin</A></TT> ...<TT><A HREF="#GRGameEnd">GRGameEnd</A></TT> sequence for each round. For example, in Quake, each level played would be a round.<P>Finally, call <TT><A HREF="#GRReset">GRReset</A></TT> to clear that GameRanger command.<P><B>Summary</B><BR><UL><TT><A HREF="#GRGameBegin">GRGameBegin</A></TT><BR>. . . game play . . .<BR><TT><A HREF="#GRStatScore">GRStatScore</A></TT><BR><TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT><BR><TT><A HREF="#GRGameEnd">GRGameEnd</A></TT><BR>. . . repeat above loop for any further rounds . . .<BR><TT><A HREF="#GRReset">GRReset</A></TT><BR>. . . optionally return to GameRanger via switching or quitting . . .<BR></UL><HR><A NAME="SCORING"></A><H3><U>Scoring</U></H3>The <TT><A HREF="#GRStatScore">GRStatScore</A></TT> and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT>calls may seem a little confusing at first. They both take a parameter for a score value and also a 32 bit player ID.The actual value of the player ID is not important so long as it is unique for that player in the game, and the playeris represented by the same ID across all clients. Example: A pointer to a player structure will <B>not</B> be sufficient,since that will be different for other clients in the game. For NetSprocket games, you can simply use the <TT>NSpPlayerID</TT>(which is just a 32 bit integer). In the unlikely event that your game does not have a method for representing/identifying players,just use zero for the player ID.<P>These calls need to be supported to allow the game to automatically report scores for when ladders,rankings and tournaments are added to GameRanger in the future.<P>Right before calling <TT><A HREF="#GRGameEnd">GRGameEnd</A></TT>, every player's game calls<TT><A HREF="#GRStatScore">GRStatScore</A></TT> with their <B>own</B> score. Additionally, each player also calls<TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT> one time for each <B>other</B> player's score (order isnot important). This serves as a simple cheat check to make sure all games agree on the scores.<P>If a player leaves the game early, scoring is optional. If you want to report the scores anyway, the other playersdon't need to remember that player. Instead they just call <TT><A HREF="#GRStatOtherScore">GRStatOtherScore</A></TT> atthe time the player leaves (assuming the missingplayer won't be counted again at the end). The player that leaves early should only report their own score (plusthe scores of any previous players that left that they would have reported). The simple way of describing this is,a player should have reported only the scores that it knows were <B>final</B>.<P>If the game doesn't use a numerical score, but instead is more of a win vs loss, simply use <B>1</B> for<B>win</B> and <B>0</B> for <B>loss</B>. In the event of a tie or stalemate situation, both scores could be<B>1</B> or both scores could be <B>0</B>.<P><HR><A NAME="PROPERTIES"></A><H3><U>Properties</U></H3>Parameters specific to your game may be passed via <B>properties</B>.<P>A property is identified by a 32 bit <B>key</B>. For example 'Kind' or 12345. A property valueis stored internally as a string, but may be returned as either a string or a 32 bit integer withthe calls <TT><A HREF="#GRGetPropertyStr">GRGetPropertyStr</A></TT> and<TT><A HREF="#GRGetPropertyVal">GRGetPropertyVal</A></TT><P>Use <TT><A HREF="#GRHasProperty">GRHasProperty</A></TT> to test for the presence of a property.<P>An example of a use of properties might be to pass the type of game to be hosted(eg. deathmatch or cooperative). This is less likely to be necessary with gamesthat have their own lobby for choosing game options once the players have connected.<P>Another example of use that might be common for games that are Macintosh conversions of PC titles,is a property for a command-line string.<P>Contact <B><A HREF="mailto:developer@GameRanger.com">Scott Kevill</A></B> if you feel thereare any properties that might be useful for your game's support.<P><HR><A NAME="OPENINGGR"></A><H3><U>Opening GameRanger</U></H3>To provide a button or menu command for launching or switching to GameRanger, call<BR><UL><TT><A HREF="#GROpenGameRanger">GROpenGameRanger</A></TT><BR></UL>To test to see if GameRanger is installed (eg. to adjust the state of a button), call<BR><UL><TT><A HREF="#GRIsGameRangerInstalled">GRIsGameRangerInstalled</A></TT></UL>This call may have a very slight delay the first time it is called, but the result is cached after that.<P>If you have just responded to a command from GameRanger, it should already be running, and thiscall can be used to switch back to it.<P>Added convenience for players is to switch back to GameRanger automatically after the game playhas finished when the game was initiated from GameRanger. If the game doesn't support switchingout to other apps, the player would benefit from the game quitting at this point (also returningthem to GameRanger).<P>Most likely return values for failure would be <TT>fnfErr</TT> (-43), and <TT>memFullErr</TT> (-108) if theGameRanger application cannot be found, or there is not enough memory to launch it.<P><HR><A NAME="NSp"></A><H3><U>NetSprocket Helpers</U></H3>Simply replace <TT>NSpDoModalHostDialog</TT> with <A HREF="#GRNSpDoModalHostDialog"><TT>GRNSpDoModalHostDialog</TT></A> and<TT>NSpDoModalJoinDialog</TT> with <A HREF="#GRNSpDoModalJoinDialog"><TT>GRNSpDoModalJoinDialog</TT></A>.<P>When a GameRanger command is in progress, the dialogs will be skipped and the parameters filled in from GameRanger, otherwisethey will call through to the normal NetSprocket routines.<P>You will also need to replace <TT>NSpReleaseAddressReference</TT> with<A HREF="#GRNSpReleaseAddressReference"><TT>GRNSpReleaseAddressReference</TT></A>. This will correctly dispose ofan address reference in all cases.<P><HR><A NAME="REF"></A><H3><U>Function Reference</U></H3><DL><DT><A NAME="GRCheckFileForCmd"><B><TT>Boolean GRCheckFileForCmd()</TT></B></A></DT><DD>Call this during startup and when resuming (if your game allows switching out) to check for a command in a temporary file.<BR>Returns <TT>true</TT> if a command was accepted.<P></DD><DT><A NAME="GRIsWaitingCmd"><B><TT>Boolean GRIsWaitingCmd()</TT></B></A></DT><DD>Call this at any point to tell if a command is waiting to be acted upon. You may want to use this at the end ofaborting the current game to determine if a new game should be started in its place.<BR><P></DD><DT><A NAME="GRGetWaitingCmd"><B><TT>void GRGetWaitingCmd()</TT></B></A></DT><DD>Sets the waiting command to be the current command, and then clears the waiting command.<P></DD><DT><A NAME="GRIsCmd"><B><TT>Boolean GRIsCmd()</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>host or join</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRIsHostCmd"><B><TT>Boolean GRIsHostCmd()</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>host</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRIsJoinCmd"><B><TT>Boolean GRIsJoinCmd()</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>join</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRGetPlayerName"><B><TT>char* GRGetPlayerName()</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns a pointer to the player name (C string). Remember to check the length and truncate if necessary. (Static data)<P></DD><DT><A NAME="GRGetPortNumber"><B><TT>UInt16 GRGetPortNumber()</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns the port number to host the game on, or to connect to when joining. Ignore this if not applicable, or if the value is zero (0).<P></DD><DT><A NAME="GRGetHostGameName"><B><TT>char* GRGetHostGameName()</TT></B></A></DT><DD><B>Host parameter</B>. Returns a pointer to the game name (C string). Remember to check the length and truncate if necessary. (Static data)<P></DD><DT><A NAME="GRGetHostMaxPlayers"><B><TT>UInt16 GRGetHostMaxPlayers()</TT></B></A></DT><DD><B>Host parameter</B>. Returns the maximum number of players to host the game for (includes the host).<P></DD><DT><A NAME="GRGetJoinAddress"><B><TT>UInt32 GRGetJoinAddress()</TT></B></A></DT><DD><B>Join parameter</B>. Returns the IP address of the host to join. Address is a 32 bit IP address in network order (big endian).<P></DD><DT><A NAME="GRGetJoinAddressStr"><B><TT>char* GRGetJoinAddressStr()</TT></B></A></DT><DD><B>Join parameter</B>. Returns the IP address of the host to join. Address is a pointer to a dotted IP address C string. (Static data)<P></DD><DT><A NAME="GRGetPlayerIconData"><B><TT>char* GRGetPlayerIconData()</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns a pointer to the player's icon data. The icon is 16x16, 8-bit colour (system palette),and a 1-bit mask (256 bytes + 32 bytes). (Static data)<P></DD><DT><A NAME="GRGetPlayerIconSuite"><B><TT>IconSuite GRGetPlayerIconSuite()</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns a new icon suite handle. The icon is 16x16, 8-bit colour (system palette), and includes a 1-bit mask. Youare responsible for disposing of it with <B><TT>DisposeIconSuite</TT></B>.<P></DD><DT><A NAME="GRHasProperty"><B><TT>Boolean GRHasProperty(SInt32 key)</TT></B></A></DT><DD>This call tests for the presence of a property identified by <B><TT>key</TT></B>. This can be useful when you're expecting an integerproperty value that could be 0, as <TT><A HREF="#GRGetPropertyVal">GRGetPropertyVal</A></TT> additionallyreturns 0 if the property is not present.<P><P></DD><DT><A NAME="GRGetPropertyStr"><B><TT>char* GRGetPropertyStr(SInt32 key)</TT></B></A></DT><DD>Returns a pointer to a C string value of the property identified by <B><TT>key</TT></B>. Will returnNULL if the property was not present. Used for game specific parameters. The stringshould be treated as read-only. (Static data)<P></DD><DT><A NAME="GRGetPropertyVal"><B><TT>SInt32 GRGetPropertyVal(SInt32 key)</TT></B></A></DT><DD>Returns a signed integer value of the property identified by <B><TT>key</TT></B>. Will return 0 if theproperty was not present or was not an integer. Used for game specific parameters.<P></DD><DT><A NAME="GRReset"><B><TT>void GRReset()</TT></B></A></DT><DD>Clears the current GameRanger command. Call this after a completed game that was joined.It's not necessary if the game was hosted, as <TT><A HREF="#GRHostClosed">GRHostClosed</A></TT> calls this anyway,but it harmless to be called more than once.<P></DD><DT><A NAME="GRHostReady"><B><TT>void GRHostReady()</TT></B></A></DT><DD>Call this when hosting and ready to accept connections. This will trigger the other clients in the game room to join.This call will do nothing if the current game was not a GameRanger game. After calling this, you must balance it witha <TT><A HREF="#GRHostClosed">GRHostClosed</A></TT> call at a later point.<P></DD><DT><A NAME="GRGameBegin"><B><TT>void GRGameBegin()</TT></B></A></DT><DD>Call this once the game play has started for this player. This is mainly to begin the scoring. For example, Quake wouldcall this after joining a game and after each level change. With other games where a "join" puts them into a lobby, thiswould be called only when the game actually begins. Should be balanced with a call to<TT><A HREF="#GRGameEnd">GRGameEnd</A></TT>. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRGameAbort"><B><TT>void GRGameAbort()</TT></B></A></DT><DD>Call this if you are able to determine that the user aborted their game early or their internet connection dropped. It is optionalto call the scoring routines in this case. If <TT><A HREF="#GRGameBegin">GRGameBegin</A></TT> has not yet beencalled, or if the the current game was not a GameRanger game, then this call will do nothing. It is desirable to supportthis so that players intentionally aborting a game that they were about to lose are detected, and can have this markedagainst them.<P></DD><DT><A NAME="GRStatScore"><B><TT>void GRStatScore(SInt32 score, UInt32 playerID)</TT></B></A></DT><DD>Call this at the end of the game (before calling <TT><A HREF="#GRGameEnd">GRGameEnd</A></TT>) with the finalscore of this player. See the <A HREF="#SCORING">Scoring</A> section for more details. This call will do nothingif the current game was not a GameRanger game.<P></DD><DT><A NAME="GRStatOtherScore"><B><TT>void GRStatOtherScore(SInt32 score, UInt32 playerID)</TT></B></A></DT><DD>Call this at the end of the game (before calling <TT><A HREF="#GRGameEnd">GRGameEnd</A></TT>) with the final scores of all<B>other</B> players. This enables GameRanger to do a simple check to help detect another client cheating.See the <A HREF="#SCORING">Scoring</A> section for more details.This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRGameEnd"><B><TT>void GRGameEnd()</TT></B></A></DT><DD>Call this when the currently playing game has ended and scores are reported. This might only be temporary as is thecase with Quake changing levels. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRHostClosed"><B><TT>void GRHostClosed()</TT></B></A></DT><DD>Call this on the host when the game has completely ended. In the GameRanger application, the game will no longerbe flagged as in-progress. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRIsGameRangerInstalled"><B><TT>Boolean GRIsGameRangerInstalled()</TT></B></A></DT><DD>Call this to determine if GameRanger is installed on one of the user's hard disks. You may want to use this toenable/disable the state of an in-game button used to launch GameRanger. There may be a very slight delay the firsttime this is called, but the result is cached and used after that.<BR>Returns <TT>true</TT> if GameRanger is installed.<P></DD><DT><A NAME="GROpenGameRanger"><B><TT>OSErr GROpenGameRanger()</TT></B></A></DT><DD>Call this if you want to provide a button or menu command for launching or switching to GameRanger.<BR>Common return values for failure would be <TT>fnfErr</TT> (-43), and <TT>memFullErr</TT> (-108) if theGameRanger application cannot be found, or there is not enough memory to launch it.<P></DD><DT><PRE><A NAME="GRNSpDoModalHostDialog"></A><B>BooleanGRNSpDoModalHostDialog(NSpProtocolListReference  ioProtocolList,                       Str31                     ioGameName,                       Str31                     ioPlayerName,                       Str31                     ioPassword,                       NSpEventProcPtr           inEventProcPtr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpDoModalHostDialog</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD><DT><PRE><A NAME="GRNSpDoModalJoinDialog"></A><B>NSpAddressReferenceGRNSpDoModalJoinDialog(ConstStr31Param           inGameType,                       ConstStr255Param          inEntityListLabel,                       Str31                     ioName,                       Str31                     ioPassword,                       NSpEventProcPtr           inEventProcPtr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpDoModalJoinDialog</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD><DT><PRE><A NAME="GRNSpReleaseAddressReference"></A><B>voidGRNSpReleaseAddressReference(NSpAddressReference inAddr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpReleaseAddressReference</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD></DL></BODY></HTML>