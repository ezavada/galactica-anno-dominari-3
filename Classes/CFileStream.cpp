// ===========================================================================// CFile.cpp//// std::FILE based implementation of LFile.cpp from PowerPlant 2.2//// (c) 2005, Sacred Tree Software & Ed Zavada// ===========================================================================////	A wrapper class for a file with a data fork. No resource fork support////	This class does not provide many functions for manipulating files, add//  them as needed#include "CFileStream.h"#include "pdg/sys/platform.h"#include <unistd.h> // for unlink#include <errno.h>#include <cstring>#include <stdio.h>#if !defined( POSIX_BUILD ) && (defined( PLATFORM_MACOS ) || defined( PLATFORM_MACOSX ))#include "FullPath.h"#endif // Mac#define CFILE_PATH_SEPARATOR '/'#if PLATFORM_WIN32    #define CFILE_NATIVE_PATH_SEPARATOR '\\'#elif PLATFORM_MACOS    #define CFILE_NATIVE_PATH_SEPARATOR ':'//#elif PLATFORM_MACOSX && !defined( POSIX_BUILD )//    #define CFILE_NATIVE_PATH_SEPARATOR ':'#else    #define CFILE_NATIVE_PATH_SEPARATOR '/'#endifCFileStream::CFileStream() : mName(""),   mPath(""),   mPathName(""),   mType(""),   mNativePathName(""),  mPrivs(0),  mFilePtr(0){}// unix style path, plus nameCFileStream::CFileStream(const char* inPath, const char* inName): mName(inName),   mPath(inPath),   mPathName(inPath),   mType(""),   mNativePathName(""),  mPrivs(0),  mFilePtr(0){    if (mPathName.length() > 0) {        mPathName += CFILE_PATH_SEPARATOR;    }    mPathName += inName;    mNativePathName = mPathName;#if PLATFORM_WIN32    // convert to Win32 separators    char * p;    p = std::strchr(mNativePathName.c_str(), CFILE_PATH_SEPARATOR);     while (p) {        *p = CFILE_NATIVE_PATH_SEPARATOR;        p = std::strchr(p+1, CFILE_PATH_SEPARATOR);    }#endif // PLATFORM_WIN32#if defined( PLATFORM_MACOS ) // || (defined( PLATFORM_MACOSX ) && !defined( POSIX_BUILD ))    // convert to Mac separators    if (mNativePathName[0] == '/') {        // full path, must remove leading slash        mNativePathName.erase(0, 1);    } else {        // relative path, must start with colon        mNativePathName.insert(0, 1, CFILE_NATIVE_PATH_SEPARATOR);    }    char * p;    p = std::strchr(mNativePathName.c_str(), CFILE_PATH_SEPARATOR);     while (p) {        *p = CFILE_NATIVE_PATH_SEPARATOR;        p = std::strchr(p+1, CFILE_PATH_SEPARATOR);    }#endif // PLATFORM_MACOS	char* extp = std::strrchr(inName, '.');	if (extp) {	    mType = (char*)&extp[1]; // copy the extension for later use	}}// unix style full path plus nameCFileStream::CFileStream(const char* inPathName): mName(""),   mPath(""),   mPathName(""),   mType(""),   mNativePathName(""),  mPrivs(0),  mFilePtr(0){    SetPathName(inPathName);}voidCFileStream::SetName(const char* inName) {    CloseFile();    std::string fullpath = mPath;    if (fullpath.length() > 0) {        fullpath += CFILE_PATH_SEPARATOR;    }    fullpath += inName;    SetPathName(fullpath.c_str());}void CFileStream::SetPath(const char* inPath) {    CloseFile();    std::string fullpath = inPath;    if (fullpath.length() > 0) {        fullpath += CFILE_PATH_SEPARATOR;    }    fullpath += mName;    SetPathName(fullpath.c_str());}void CFileStream::SetPathName(const char* inPathName) {    CloseFile();    mPathName = inPathName;    mNativePathName = mPathName;#if PLATFORM_WIN32    // convert to Win32 separators    char * p;    p = std::strchr(mNativePathName.c_str(), CFILE_PATH_SEPARATOR);     while (p) {        *p = CFILE_NATIVE_PATH_SEPARATOR;        p = std::strchr(p+1, CFILE_PATH_SEPARATOR);    }#endif // PLATFORM_WIN32#if defined( PLATFORM_MACOS ) //|| (defined( PLATFORM_MACOSX ) && !defined( POSIX_BUILD ))    // convert to Mac separators    if (mNativePathName[0] == '/') {        // full path, must remove leading slash        mNativePathName.erase(0, 1);    } else {        // relative path, must start with colon        mNativePathName.insert(0, 1, CFILE_NATIVE_PATH_SEPARATOR);    }    char * p;    p = std::strchr(mNativePathName.c_str(), CFILE_PATH_SEPARATOR);     while (p) {        *p = CFILE_NATIVE_PATH_SEPARATOR;        p = std::strchr(p+1, CFILE_PATH_SEPARATOR);    }#endif // PLATFORM_MACOS    char* namep = std::strrchr(inPathName, CFILE_PATH_SEPARATOR);    if (namep) {        mName = (char*)&namep[1];        mPath.assign(inPathName, (size_t)(namep - inPathName));    } else {        // only the filename was specified        mName = inPathName;        mPath = "";    }    // get file type from extension	char* extp = std::strrchr(mName.c_str(), '.');	if (extp) {	    mType = (char*)&extp[1]; // copy the extension for later use	} else {	    mType = "";	}}				CFileStream::~CFileStream() {    try {        CloseFile();    }    catch(...) {} // make sure we don't throw an exception here}ExceptionCode 		CFileStream::CreateFile() {    // duplicate behaviour of MacOS. It is an error to try to create a new    // file where one already exists.    if (FileExists()) {        return fileExistsErr;    }    // try to create the file    const char* filename = mNativePathName.c_str();    std::FILE* tempFilePtr = std::fopen(filename, "w");    if (!tempFilePtr) {        return fileSystemErr;    } else {        std::fclose(tempFilePtr);  // success        return fileSuccess;    }}ExceptionCode 		CFileStream::OpenFile(int inPrivileges) {    const char* mode;    if (inPrivileges == privileges_ReadOnly) {        // this mode represents read only        mode = "rb";    } else {        // everything else is read write        mode = "r+b";    }    mFilePtr = std::fopen(mNativePathName.c_str(), mode);    if (!mFilePtr) {        if (FileExists()) {            return fileSystemErr;        } else {	        return fileNotFoundErr;        }    }    return fileSuccess;}bool		CFileStream::FileExists() {    if (mFilePtr) {        return true; // we have the file open, it must exist    } else {        std::FILE* tempFilePtr = std::fopen(mNativePathName.c_str(), "rb");        if (tempFilePtr) {            std::fclose(tempFilePtr);  // we opened the file for reading, it must exist            return true;        } else {            return false;   // couldn't open the file for reading, probably doesn't exist        }    }}void		CFileStream::CloseFile() {    FlushFile();    if (mFilePtr) {        std::fclose(mFilePtr);        mFilePtr = 0;    }}void		CFileStream::FlushFile() {    if (mFilePtr) {        std::fflush(mFilePtr);    }}ExceptionCode         CFileStream::DeleteFile() {    if (unlink(mNativePathName.c_str()) == 0) {        return fileSuccess;    } else if (!FileExists()) {        return fileNotFoundErr;    } else {        return fileSystemErr;    }}ExceptionCode         CFileStream::SetFileAttribute(int attribKey, const char* attribValue) {#if !defined( POSIX_BUILD ) && (defined( PLATFORM_MACOS ) || defined( PLATFORM_MACOSX ))    // get the dirID for the backup folder    FSSpec spec;#if defined( PLATFORM_MACOSX )    OSErr err = FSpMakeFSSpecFromPosixFullPath(mNativePathName.c_str(), spec);#else    OSErr err = FSpMakeFSSpecFromNativeFullPath(mNativePathName.c_str(), spec);#endif    if (err == fnfErr) {        return fileNotFoundErr;    } else if (err != noErr) {        return fileSystemErr;    }    CInfoPBRec pb;    pb.dirInfo.ioNamePtr = spec.name;    pb.dirInfo.ioVRefNum = spec.vRefNum;    pb.dirInfo.ioFDirIndex = 0;    pb.dirInfo.ioDrDirID = spec.parID;    if (MacAPI::PBGetCatInfoSync(&pb) == noErr) {  // do nothing if call failed        bool isFolder = ((pb.dirInfo.ioFlAttrib & kioFlAttribDirMask) != 0);        if (!isFolder) {            if (attribKey == attrib_Type) {                std::memcpy(&pb.hFileInfo.ioFlFndrInfo.fdType, attribValue, sizeof(OSType));            } else if (attribKey == attrib_Creator) {                std::memcpy(&pb.hFileInfo.ioFlFndrInfo.fdCreator, attribValue, sizeof(OSType));            }        }        pb.dirInfo.ioDrDirID = spec.parID; // need to reset because this got stomped        err = MacAPI::PBSetCatInfoSync(&pb);        if (err != noErr) {            return fileSystemErr;        }    } else {        return fileSystemErr;    }#endif // MACOS    return fileSuccess;}const char*CFileStream::GetFileAttribute(int attribKey, char* buffer, long bufferSize) {    buffer[0] = 0; // start with empty buffer#if !defined( POSIX_BUILD ) && (defined( PLATFORM_MACOS ) || defined( PLATFORM_MACOSX ))    // get the dirID for the backup folder    FSSpec spec;#if defined( PLATFORM_MACOSX )    OSErr err = FSpMakeFSSpecFromPosixFullPath(mNativePathName.c_str(), spec);#else    OSErr err = FSpMakeFSSpecFromNativeFullPath(mNativePathName.c_str(), spec);#endif    if (err == noErr) {        CInfoPBRec pb;        pb.dirInfo.ioNamePtr = spec.name;        pb.dirInfo.ioVRefNum = spec.vRefNum;        pb.dirInfo.ioFDirIndex = 0;        pb.dirInfo.ioDrDirID = spec.parID;        if (MacAPI::PBGetCatInfoSync(&pb) == noErr) {  // do nothing if call failed            bool isFolder = ((pb.dirInfo.ioFlAttrib & kioFlAttribDirMask) != 0);            if (!isFolder) {                char* p;                if (attribKey == attrib_Type) {                    p = (char*)&pb.hFileInfo.ioFlFndrInfo.fdType;                    snprintf(buffer, bufferSize, "%c%c%c%c", p[0], p[1], p[2], p[3]);                } else if (attribKey == attrib_Creator) {                    p = (char*)&pb.hFileInfo.ioFlFndrInfo.fdCreator;                    snprintf(buffer, bufferSize, "%c%c%c%c", p[0], p[1], p[2], p[3]);                }            }            if (attribKey == attrib_IsFolder) {                // write the boolean result into the string buffer                buffer[0] = (isFolder)?'1':'0';                buffer[1] = 0;            }        }    }#endif // MACOS    return buffer;}void		CFileStream::SetMarker(SInt32 inOffset, EStreamFrom inFromWhere) {    if (!mFilePtr) {        ThrowIfOSErr_(fileNotOpenErr);    }		// LStream uses positive offsets from the end to mean move		// backwards. But, std::fseek always uses negative offsets for		// moving backwards. To allow people to use LFileStream from		// a LStream pointer, we need to support the PP convention		// by switching positive offsets from the end to the negative		// value so that std::fseek does what was intended.	if ((inFromWhere == streamFrom_End) && (inOffset > 0)) {		inOffset = -inOffset;	}	// also translate the mode from PowerPlant to what std::fseek expects    int origin;    switch (inFromWhere) {        case streamFrom_Start:            origin = SEEK_SET;            break;        case streamFrom_Marker:            origin = SEEK_CUR;            break;        case streamFrom_End:            origin = SEEK_END;            break;    }	std::fseek(mFilePtr, inOffset, origin);//	ThrowIfOSErr_(errno);}SInt32		CFileStream::GetMarker() const {    if (!mFilePtr) {        ThrowIfOSErr_(fileNotOpenErr);    }	SInt32 theMarker = std::ftell(mFilePtr);//	ThrowIfOSErr_(errno);	return theMarker;}void		CFileStream::SetLength(SInt32 inLength) {    if (!mFilePtr) {        ThrowIfOSErr_(fileNotOpenErr);    }    std::fseek(mFilePtr, inLength, SEEK_SET);          // set total length.//	ThrowIfOSErr_(errno);	LStream::SetLength(inLength);}SInt32		CFileStream::GetLength() const {    if (!mFilePtr) {        ThrowIfOSErr_(fileNotOpenErr);    }    long oldPos = std::ftell(mFilePtr);         // save current marker, then move//	ThrowIfOSErr_(errno);                       // to end and ask where we are to    std::fseek(mFilePtr, 0, SEEK_END);          // get total length.//	ThrowIfOSErr_(errno);	SInt32	theLength = std::ftell(mFilePtr);//	ThrowIfOSErr_(errno); 	std::fseek(mFilePtr, oldPos, SEEK_SET);     // restore saved marker//	ThrowIfOSErr_(errno);	return theLength;}ExceptionCode	        CFileStream::PutBytes(const void* inBuffer, SInt32& ioByteCount) {    if (!mFilePtr) {        return fileNotOpenErr;    }    size_t bytesWritten = std::fwrite(inBuffer, 1, ioByteCount, mFilePtr);    ExceptionCode resultCode = noErr;    if (bytesWritten < ioByteCount) {        resultCode = fileSystemErr;    }    ioByteCount = bytesWritten;	return resultCode;}ExceptionCode	        CFileStream::GetBytes(void* outBuffer, SInt32& ioByteCount) {    if (!mFilePtr) {        return fileNotOpenErr;    }    size_t bytesRead = std::fread(outBuffer, 1, ioByteCount, mFilePtr);    ExceptionCode resultCode = noErr;    if (bytesRead < ioByteCount) {        resultCode = fileSystemErr;    }    ioByteCount = bytesRead;	return resultCode;}