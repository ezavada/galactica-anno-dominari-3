//	GalacticaDoc.cp
// ===========================================================================
// Copyright (c) 1996-2002, Sacred Tree Software
// All rights reserved
// ===========================================================================
// Changes:
//	9/21/96, ERZ, 1.0.8 fixes integrated
//	1/3/97, ERZ, 1.1 fixes integrated
//  10/7/97, ERZ, 1.2 changes


/* 

FUNCTIONAL OVERVIEW:

The GalacticaDoc (often referred to as the GameDoc) is the base user interface
for client and single player. It handles all functions that affect the game UI
as a whole, such as window creation, message playback, and player comparison. 
The GalacticaSingleDoc and GalacticaClient are both specialized types of 
GalacticaDoc, with added functions to handle multiplayer client and single
player games. 

NOTE: GalacticaHostDoc is *not* a subclass of GalacticaDoc.

There are several major catagories of methods and data in a GameDoc, reflecting 
the basic functional areas:

User Interface: These handle display of game specific information, and
		coordinate the display of thingy (ship, star, etc...) specific info.
		They are generally called during the user's turn in response to specific
		events (user actions).

Event Messages: Events are always generated by the host, with the sole
		exception of Interplayer Messages sent with the "Send Message" menu
		item. Currently, all events are sent to every player by the host, but
		this will change when info hiding is implemented. The basic process is:
				
Event Report and Playback: The event report window has a list of all events,
    	and the list handles most of the details of displaying them. ShowMessages()
    	handles the autoplay events, and ShowNextNeedyThingy() is called each time
    	the user hits <tab> to see the next item that wants attention.

*/

#include "GalacticaGlobals.h"
#include "Galactica.h"
#include "GalacticaConsts.h"
#include "GalacticaDoc.h"
#include "GalacticaKeys.h"
#include "GalacticaPanels.h"
#include "CGalacticSlider.h"
#include "GalacticaTables.h"
#include "CStar.h"
#include "GalacticaUtils.h"
#include "CShip.h"
#include "CRendezvous.h"
#include "GalacticaRegistration.h"

#include "GalacticaTutorial.h"

#include <PP_Messages.h>
#include <PP_Resources.h>
#include <UDrawingState.h>
#include <LArrayIterator.h>
#include <LEditField.h>
#include <LWindow.h>
#include <UModalDialogs.h>
#include <LMenuBar.h>
#include <LFileStream.h>
#include <UWindows.h>
#include <UEnvironment.h>

#include <LowMem.h>

#include "CLayeredOffscreenView.h"
#include "CMasterIndexFile.h"
#include "CMessage.h"
#include "CNewGWorld.h"
#include "CResCaption.h"
#include "CStyledText.h"
#include "CTextTable.h"
#include "CWindowMenu.h"
#include "LAnimateCursor.h"
#include "LPPobView.h"
#include "Slider.h"
#include "USound.h"
#include "CSummaryLine.h"
#include "CSystemInfoLine.h"
#include "CFleetInfoLine.h"

#include "pdg/sys/config.h"

#if TARGET_OS_MAC && !TARGET_API_MAC_CARBON
	#include "CDisplay.h"
#endif

#if TARGET_OS_MAC && defined(DEBUG) && defined( __MWERKS__ )
	#include "DebugNew.h"
#endif


LAttachment*	GalacticaWindow::sFullScreenResizer = NULL;
LWindow*		GalacticaDoc::sEventsWindow = NULL;


void
GalacticaWindow::ActivateSelf() {
	CBalloonApp::sHelpLineDisplay = this->mHelpLinePane;	// use our help line pane for this window
	MacAPI::HiliteWindow(mMacWindowP, true);
	if (!Galactica::Globals::GetInstance().getFullScreenMode())	{	// don't want to draw a size box while in
		DrawSizeBox();
	}
	bool adminWindow = false;
	GalacticaDoc* game = dynamic_cast<GalacticaDoc*>(mSuperCommander);
	if (game) {
	    game->WindowActivated();
	    adminWindow = (game->GetMyPlayerNum() == kAdminPlayerNum);
	} else {
	   GalacticaShared* shared = dynamic_cast<GalacticaShared*>(mSuperCommander);
	   if (shared && shared->IsHost()) {
	      adminWindow = true;
	   }
	}
	// if we have a menu bar and an admin menu, figure out if we need to install them
	LMenuBar* theMBar = LMenuBar::GetCurrentMenuBar();
	LMenu* adminMenu = Galactica::Globals::GetInstance().getAdminMenu();
	if (theMBar && adminMenu) {
	   	// add or remove Admin Menu
	   	if ( adminWindow && !adminMenu->IsInstalled()) {
	    	theMBar->InstallMenu(adminMenu, 0);
	   	} else if (!adminWindow && adminMenu->IsInstalled()) {
	   	   	theMBar->RemoveMenu(adminMenu);
	   	}
	}
}


void
GalacticaWindow::DrawSelf() {
//	PaintRect(&mMacWindowP->portRect);		// DEBUG, for checking update region
//    DEBUG_OUT("In GalacticaWindow::DrawSelf()", DEBUG_IMPORTANT);

	if (Galactica::Globals::GetInstance().getFullScreenMode()) {		// no size box in full screen mode
		ClearAttribute(windAttr_SizeBox);
		
	} else {
		SetAttribute(windAttr_SizeBox);
	}
	if (HasAttribute(windAttr_EraseOnUpdate)) {
		RgnHandle eraseRgn = MacAPI::NewRgn();	// we don't want the ugly grey flicker that's caused
		Rect portRect;
		MacAPI::GetWindowPortBounds(mMacWindowP, &portRect);
		MacAPI::RectRgn(eraseRgn, &portRect);
		if (mStarMap) {									// the starmap, so exclude the starmap
			RgnHandle workRgn = MacAPI::NewRgn();				// from the erasure
			Rect r;
			mStarMap->CalcPortFrameRect(r);
			MacAPI::RectRgn(workRgn, &r);
			MacAPI::DiffRgn(eraseRgn, workRgn, eraseRgn);
        	GalacticaDoc* game = dynamic_cast<GalacticaDoc*>(mSuperCommander);
        	if (game) {
    			LPicture *dimmer = ((GalacticaDoc*)mSuperCommander)->GetDimmerPict();
    			if (dimmer) {
    				dimmer->CalcPortFrameRect(r);	// also get rid of flicker on the ship picture
    				MacAPI::RectRgn(workRgn, &r);
    				MacAPI::DiffRgn(eraseRgn, workRgn, eraseRgn);
    			}
    		}
			MacAPI::DisposeRgn(workRgn);
		}
		ApplyForeAndBackColors();
		MacAPI::EraseRgn(eraseRgn);
		DisposeRgn(eraseRgn);
	}
	if (!Galactica::Globals::GetInstance().getFullScreenMode())	{	// also, we don't want to draw a size box while in
		DrawSizeBox();						// full screen mode
	}
}


void
GalacticaWindow::UseFullScreen(Boolean inFull) {
  #if TARGET_OS_MAC && !TARGET_API_MAC_CARBON
	if (inFull) {												// full screen mode, add a special attachment to handle
		if (!sFullScreenResizer) {								// Display Manager messages, creating it first is necessary
			sFullScreenResizer = new CFullScreenWindAttach();
		}
		AddAttachment(sFullScreenResizer, nil, false);
	} else if (sFullScreenResizer) {							// not full screen mode, dump the special DM msg handler
		RemoveAttachment(sFullScreenResizer);
	}
  #else
    #pragma unused(inFull)
  #endif // TARGET_OS_MAC
}


void 
GalacticaWindow::UpdatePort() {
    GalacticaDoc* game = dynamic_cast<GalacticaDoc*>(((CStarMapView*)mStarMap)->GetGame());
    if (game) {
	    game->HideSelectionMarker();
	}
	LWindow::UpdatePort();
}


void
GalacticaWindow::HandleClick(const EventRecord &inMacEvent, SInt16 inPart) {
	if (HasAttribute(windAttr_SizeBox) && (inPart == inContent)) {
		Point wherePort = inMacEvent.where;
		GlobalToPortPoint(wherePort);
		Rect	sizeBox;
		::GetWindowPortBounds(mMacWindowP, &sizeBox);
		sizeBox.left = sizeBox.right - 15;
		sizeBox.top = sizeBox.bottom - 15;
		if (::MacPtInRect(wherePort, &sizeBox)) {
			ClickInGrow(inMacEvent);
		} else {
			ClickInContent(inMacEvent);
		}
	} else {
		LWindow::HandleClick(inMacEvent, inPart);
	}
}


#pragma mark-

GalacticaDoc*		GalacticaDoc::sStreamingDoc = nil;


#define snd_Attention	1001


GalacticaDoc::GalacticaDoc(LCommander *inSuper)
: LSingleDoc(inSuper), 
  GalacticaSharedUI(),
  LPeriodical(), 
  CTimed(), 
  mControlListener(this, cmd_BaseSortCommand - base_SortButtonPaneId) {
	DEBUG_OUT("New GameDoc", DEBUG_IMPORTANT | DEBUG_USER);
	mNextSpendTime = 0;
	mNextCursorFlash = 0;
	mLastStarIndex = 0;
	mCompareWindow = NULL;
	mSystemsWindow = NULL;
	mFleetsWindow = NULL;
	mFleetsSortColumn = 0;
	mSystemsSortColumn = 0;
	mDrawNames = mDrawShips = mDrawGrid = mShowAllCourses = true;
	mDrawCourierCourses = true;
	mDrawRangeCircles = true;
	mDrawStarLanes = false;
	mDrawStarmapNebulaBackground = true;
	// initialize sort columns from config if possible
    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
    if (config) {
    	long columnNum = 0;
    	config->getConfigLong(GALACTICA_PREF_SYS_WIND_SORTBY, columnNum);
    	mSystemsSortColumn = columnNum;
    	config->getConfigLong(GALACTICA_PREF_FLEETS_WIND_SORTBY, columnNum);
    	mFleetsSortColumn = columnNum;
    	config->getConfigBool(GALACTICA_PREF_SHOW_NAMES, mDrawNames);
    	config->getConfigBool(GALACTICA_PREF_SHOW_SHIPS, mDrawShips);
    	config->getConfigBool(GALACTICA_PREF_SHOW_COURSES, mShowAllCourses);
    	config->getConfigBool(GALACTICA_PREF_SHOW_COURIERS, mDrawCourierCourses);
    	config->getConfigBool(GALACTICA_PREF_SHOW_RANGES, mDrawRangeCircles);
    	config->getConfigBool(GALACTICA_PREF_SHOW_GRIDLINES, mDrawGrid);
    	config->getConfigBool(GALACTICA_PREF_SHOW_NEBULA, mDrawStarmapNebulaBackground);
    }
	mFleetsScrollPos = 0;
	mSystemsScrollPos = 0;
	mStarMap = NULL;
	mEndTurnButton = NULL;
	mGameInfo.currTurn = 1;
	mFOWOverride = false;
	mDisallowCommands = false;
	PaletteHandle ph = MacAPI::GetNewPalette(pltt_DefaultColors);
	for (int i = 0; i < kNumUniquePlayerColors; i++) {
        RGBColor rgb;
		MacAPI::GetEntryColor(ph, i*2, &rgb);
        // the palette resource is big endian, need to swap colors
        mSelectedColorArray[i].red = EndianU16_BtoN(rgb.red);
        mSelectedColorArray[i].green = EndianU16_BtoN(rgb.green);
        mSelectedColorArray[i].blue = EndianU16_BtoN(rgb.blue);        
		MacAPI::GetEntryColor(ph, i*2+1, &rgb);
        mColorArray[i].red = EndianU16_BtoN(rgb.red);
        mColorArray[i].green = EndianU16_BtoN(rgb.green);
        mColorArray[i].blue = EndianU16_BtoN(rgb.blue);        
	}
	MacAPI::DisposePalette(ph);
	mOldSelectedThingy = NULL;
	sStreamingDoc = NULL;
	mClosing = false;
	mIsIdling = false;
	mGotoEnemyMoves = true;
	mShowMessagesPending = false;
	mNumUnprocessedGotos = 0;
	mNumUnprocessedAutoShows = 0;
	mEventsWereShown = true;
	mWantGameMessages = true;
	mWantPlayerMessages = true;
	mPlayerNames = nil;
	mNeedy = nil;
	mNeedyIterator = nil;
	mNewOrChangedClientThingys = nil;
	mEventsWindow = nil;
	mEventsTable = nil;
	mDimmerPict = nil;
	mEventText = nil;
	mPanelCaption = mViewNameCaption = nil;
	mButtonBar = mPanel = nil;
	mViewer = nil; 
	SetTimer(&mAutoEndTurnTimer);	// let our timer know it is timing us
	mTimer = nil;	// but the timer wasn't allocated with new, so hide it
	SetModified(false);	// clear the flag that says we changed stuff

	// Setup the keyboard equivalents for zoom in and zoom out	
	CKeyCmdAttach* anAttach = new CKeyCmdAttach('-\0\0\0', cmd_ZoomOut);
	AddAttachment(anAttach);
	anAttach = new CKeyCmdAttach('+=\0\0', cmd_ZoomIn);
	AddAttachment(anAttach);
	anAttach = new CKeyCmdAttach('0*\0\0', cmd_ZoomFill);	// zero key and keypad * for zoom to fit
	AddAttachment(anAttach);
	anAttach = new CKeyCmdAttach('\t\0\0\0', cmd_GotoNext);	// TAB key for Next Item
	AddAttachment(anAttach);
	anAttach = new CKeyCmdAttach('\1\0\0\0', cmd_GotoHome);	// HOME key for Home Planet
	AddAttachment(anAttach);

	CButtonKeyAttach *aBAttach = new CButtonKeyAttach('Ii\0\0', cmd_SetPanelInfo, this);	// Info button in main bar
	AddAttachment(aBAttach);
	aBAttach = new CButtonKeyAttach('Ss\0\0', cmd_SetPanelShips, this, buttonbar_Star);		// main bar ships in system
	AddAttachment(aBAttach);
	aBAttach = new CButtonKeyAttach('Ss\0\0', cmd_SetPanelFleetShips, this, buttonbar_Fleet);		// main bar ships in system
	AddAttachment(aBAttach);
	aBAttach = new CButtonKeyAttach('Nn\0\0', cmd_SetPanelNav, this, buttonbar_Fleet);		// main bar ships in system
	AddAttachment(aBAttach);
	for (int i = 0; i < 8; i++) {	// display mode buttons
		unsigned long key = i+'1';
		aBAttach = new CButtonKeyAttach(key<<24, cmd_DisplayNone+i, this);
		AddAttachment(aBAttach);
	}

	CGalacticaKeyAttach* aGAttach = new CGalacticaKeyAttach('Ee\r\0', 'bSet', this);
	AddAttachment(aGAttach);									// RETURN for double-click in list
	aGAttach = new CGalacticaKeyAttach('Aa\0\0', 'bAdd', this);
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Rr\0\0', 'bLop', this);	// repeat course
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Cc\0\0', 'bCal', this);	// callin
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Mm\0\0', 'bMem', this);	// ship memory
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach(0x1B000000, 'bClr', this);	// CLEAR key for erase all
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Pp\0\0', 'bPat', this);	// patrol
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Hh\0\0', 'bHun', this);	// hunt mode
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach('Xx\0\0', 'bExg', this);	// exchange ships between fleets
	AddAttachment(aGAttach);
	aGAttach = new CGalacticaKeyAttach(0x08000000, 'bDel', this);	// DELETE key for delete one
	AddAttachment(aGAttach);	
	CListNavKeyAttach* aNavAttach = new CListNavKeyAttach();
	AddAttachment(aNavAttach);
	CPanelKeyAttach* aPAttach;
	aPAttach = new CPanelKeyAttach(0x1D000000, 'rght', this);	// right arrow
	AddAttachment(aPAttach);
	anAttach = new CKeyCmdAttach(0x1C000000, 'left');	// left arrow; Note that this is not the same kind of key
	AddAttachment(anAttach);							// attach used for other arrows because it has to work from
														// all panels														
	anAttach = new CKeyCmdAttach(0x08000000, cmd_Delete);	// trying to delete a rendezvous point
	AddAttachment(anAttach);	
	StartRepeating();	// ERZ v1.2b8d5, animated selection marker
}

GalacticaDoc::~GalacticaDoc() {
	DEBUG_OUT("GalacticaDoc::~GalacticaDoc ", DEBUG_IMPORTANT | DEBUG_USER);
	StartClosing(); // v2.1, make sure everyone knows we are going away
	StopIdling();
	StopRepeating();	// ERZ v1.2b8d5, animated selection marker

	mSelectedThingy = nil;
	mPanelCaption = nil;
	if (mNeedy) {	// 1.2b10, delete the needy list, and all messages in it
		if (mNeedyIterator) {
			delete mNeedyIterator;
			mNeedyIterator = nil;
		}
		LArrayIterator iterator(*mNeedy, LArrayIterator::from_End);
		ThingMemInfoT	info;
		while (iterator.Previous(&info)) {
			mNeedy->RemoveItemsAt(1, iterator.GetCurrentIndex());
			if (ValidateThingy(info.thing)) {
				delete info.thing;
			}
		}
		delete mNeedy;
		mNeedy = nil;
	}
	if (mWindow) {
		Galactica::Globals::GetInstance().getWindowMenu()->RemoveWindow( mWindow );
	}
	if (mPlayerNames) {
		delete mPlayerNames;
	}
	CbxShPanel::sPrevThingy = nil; // clear in case item was one of our thingys
}


void
GalacticaDoc::HideSelectionMarker() {
	if (mSelectedThingy) {
		mSelectedThingy->EraseSelectionMarker();
	}
}


Boolean
GalacticaDoc::ObeyCommand(CommandT inCommand, void *ioParam) {

	if (mDisallowCommands) {
		SysBeep(1);
		return true;
	}

	if ((inCommand >= cmd_BaseSortCommand) && (inCommand <= cmd_LastSortCommand)) {	// change compare window sort
	    int columnNum = inCommand - cmd_BaseSortCommand; // which column number are we sorting by?
	    if (mFleetsWindow) {
	        SortFleetsWindowByColumn(columnNum);
	    } else if (mSystemsWindow) {
	        SortSystemsWindowByColumn(columnNum);
	    } else if (mCompareWindow) {
	        SortCompareWindowByColumn(columnNum);
	    }
    }
    
	if ((inCommand >= cmd_SetPanelFirst) && (inCommand <= cmd_SetPanelLast)) {	// change panel command
		if (mPanel && mButtonBar) {
			SInt32 id = mButtonBar->GetActiveViewID() - buttonbar_Empty;
			id *= 10;								// get panel id offset for buttonbar number
			id += (inCommand - cmd_SetPanelFirst);	// add in offset for selected button, gives total offset
			id += panel_Empty;		// now ID is correct PPob res ID, so load that puppy
			sStreamingDoc = this;	// set streaming game because SetPPob call could load a PPob from a stream
			mPanel->SetPPob(id);
			CBoxView* activePanel = GetActivePanel();
			if (activePanel) {
				activePanel->UpdatePanel(mSelectedThingy);
				if (mPanelCaption != nil) {
					LStr255 s(STRx_PanelNames, activePanel->GetPanelStrResIndex());
					mPanelCaption->SetDescriptor(s);
				}
				// begin tutorial stuff
			  #if TUTORIAL_SUPPORT
				if ((id == 2032) && Tutorial::TutorialIsActive()) {
					Tutorial* t = Tutorial::GetTutorial();
					if (t->GetPageNum() == tutorialPage_ClickShipsButn) {
						// waiting for them to click on ships in fleet button
						t->NextPage();
					}
				}
			  #endif // TUTORIAL_SUPPORT
				// end tutorial stuff
			}
			sStreamingDoc = nil;
			// clear any pending clicks, no panel to notify
			StopAllMouseTracking();		// v1.2b9, ERZ, was	CStarMapView::ClickReceived();
		}
		return true;	// command was handled
	}
	Boolean		cmdHandled = true;
	Boolean 	bCanDo, bShow, bCellSelected = false;
	SInt32 value = 0;	// v1.2fc3, check for NULL ioParam before dereferencing it
	if (ioParam != NULL) {
		value = *((long*)ioParam);
	}

  #if TUTORIAL_SUPPORT
	SInt32 pageNum;
    Tutorial* t;
  #endif //TUTORIAL_SUPPORT

	switch (inCommand) {


	  #if TUTORIAL_SUPPORT && defined(DEBUG)
		case 9101:		// goto a tutorial page
			if (UModalDialogs::AskForOneNumber(this, 9101, 1, pageNum)) {
				Tutorial* t = Tutorial::GetTutorial();
				if (!Tutorial::TutorialIsActive()) {
					t->StartTutorial(this, pageNum);
				} else {
					t->GotoPage(pageNum);
				}
			}			
	  #endif //TUTORIAL_SUPPORT

		case cmd_TutorialOK:
          #if TUTORIAL_SUPPORT
			t = Tutorial::GetTutorial();
			t->NextPage();	// normally we just go to the next page
			pageNum = t->GetPageNum();
			if ( pageNum >= tutorialPage_YourStarSys) {
			   bool changedZoom = false;
			   // we need to make sure the zoom level is correct, so restore it if not
			   if (mStarMap->GetZoom() < 4) {
			      while (mStarMap->GetZoom() < 4) {
			         mStarMap->ZoomIn();
			         mStarMap->UpdatePort();
         		  #if TARGET_API_MAC_CARBON
                  ::QDFlushPortBuffer(mStarMap->GetMacPort(), NULL);
                 #endif
                  changedZoom = true;
			      }
			   } else if (mStarMap->GetZoom() > 6) {
			      while (mStarMap->GetZoom() > 6) {
			         mStarMap->ZoomOut();
			         mStarMap->UpdatePort();
         		  #if TARGET_API_MAC_CARBON
                  ::QDFlushPortBuffer(mStarMap->GetMacPort(), NULL);
                 #endif
                  changedZoom = true;
			      }
			   }
			   if (changedZoom) {
			      mStarMap->ZoomTo(4, true);
			   }
			}
			if (pageNum >= tutorialPage_EndTurnOne) {
				if (pageNum == tutorialPage_LastPage) {
					mGotoEnemyMoves = true;	// turn back on show enemy moves
					CBalloonApp::sMouseLingerEnabled = true;
				}
				break;	// all done
			}
			// we haven't finished turn one yet, so fall thru to cmd_GotoHome
			// just to make sure it stays selected
          #endif //TUTORIAL_SUPPORT

		case cmd_GotoHome:
        {
            DEBUG_OUT("Player "<<GetMyPlayerNum()<<" goto home: "
                << GetMyPlayerHomeID(), DEBUG_IMPORTANT | DEBUG_USER);
			AGalacticThingy *home = FindThingByID(GetMyPlayerHomeID());
			if (home) {
			    AGalacticThingyUI* ui = home->AsThingyUI();
			    if (ui) {
    				ui->Select();
				}
				if (mSelectedThingy) {
					mStarMap->ScrollToThingy(mSelectedThingy);
				}
			}
			break;
        }

		case 'left':		// left arrow pressed, back up in ship/fleet/star containment hierarchy
			if (CStarMapView::IsAwaitingClick()) {
				SysBeep(1); 
			} else if (mSelectedThingy) {
				AGalacticThingy* it = mSelectedThingy->GetPosition();
				AGalacticThingy* prev = mSelectedThingy;
				if (it) {
					it->AsThingyUI()->Select(); // we know the selected thingy will always be contained by a UI object
					CBoxView* bar = GetCurrButtonBar();
					if (bar) {
						CbxShPanel::sPrevThingy = prev;	// thingy selected just before we hit left arrow
						if (it->GetThingySubClassType() == thingyType_Star) {	// if item is a star, choose
							bar->SimulateButtonClick(cmd_SetPanelSecond, true);// the ships in system panel
						} else {
							bar->SimulateButtonClick(cmd_SetPanelThird, true);// otherwise it, try to choose
						}												// the ships in fleet panel
					}
				} else {
					new CSoundResourcePlayer(snd_NoMore);
				}
			}
			break;
			
		case cmd_ShowAllCourses:
			mShowAllCourses = !mShowAllCourses;
			mStarMap->Refresh();
			break;
			
		case cmd_Revert:  {
				LStr255	docName;
				GetDescriptor(docName);
				MovableParamText(0, docName);
				if (MovableAlert(window_ConfirmRevert) == 1) {
					SendSelfAE(kAEMiscStandards, kAERevert, false);
					DoRevert();
				}
			}
			break;
		
		case cmd_EndTurn:
			bCanDo = true;
			if ((mNumUnprocessedGotos > 0) || (mNumUnprocessedAutoShows > 0)) {
				bCanDo = ( MovableAlert(window_EndTurnEarly) == 1 );
			}
			if (bCanDo) {
				if (ExecuteAttachments(msg_TurnEnded, nil)) {
					DoEndTurn();
				}
			} else {
				if (mNumUnprocessedAutoShows > 0) {
					ShowMessages();
				}
				ShowNextNeedyThingy();
			}
			SetUpdateCommandStatus(true);
			break;
		
		case cmd_GotoCurr:
			if (mSelectedThingy) {
				mStarMap->ScrollToThingy(mSelectedThingy);
			}
			break;

		case cmd_GotoNext:
			if (!CStarMapView::IsAwaitingClick()) {
				if (mNumUnprocessedGotos > 0) {
					ShowNextNeedyThingy();
				} else {
					new CSoundResourcePlayer(snd_NoMore);
                  #if TUTORIAL_SUPPORT
					if (Tutorial::TutorialIsActive()) {
						Tutorial* t = Tutorial::GetTutorial();
						SInt16 pageNum = t->GetPageNum();
						if ( (pageNum == tutorialPage_HitTabAgain) ||
							 (pageNum == tutorialPage_CourierArrive) ||
							 (pageNum == tutorialPage_PatrolHitTab) ||
							 (pageNum == tutorialPage_IgnoreCourier) ||
							 (pageNum == tutorialPage_HitTab_2) ) {
							// we were waiting for them to go to next event, but there wasn't one
							t->NextPage();
							// here we need to make sure they actually set the courier's course correctly
							if (pageNum == tutorialPage_CourierArrive) {
								AGalacticThingy* it = FindThingByID(tutorial_S7StarID);
								CShip* ship = ValidateShip(FindThingByID(tutorial_CourierShipID));
								if (it && ship) {
									ship->ClearCourse(false, kDontRefresh);
									ship->AddWaypoint(1, it, kRefresh);
								}
							}
						}
					}
                  #endif // TUTORIAL_SUPPORT				
				}
			} else {
				SysBeep(1);	// can't show next thing while awaiting click
			}
			break;

		case cmd_ShowHideEvents:
			bShow = true;
			if (mEventsWindow && mEventsWindow->IsVisible()) {
				bShow = false;
			}
			if (bShow) {
				ShowEventsWindow();
			} else if (mEventsWindow) {
				mEventsWindow->Hide();
				mEventsWereShown = false;
				if (sEventsWindow == mEventsWindow) {
					sEventsWindow = NULL;
				}
			}
			break;

		case cmd_ShowMessages:
        {
			// have to temporarily remove the "hold messages" flag if we want the 
			// messages to be able to play
			Boolean oldWantMessages = mWantGameMessages;
			mWantGameMessages = true;
			ShowMessages();
			mWantGameMessages = oldWantMessages;
			break;
        }

		case cmd_HoldMessages:
			mWantGameMessages = !mWantGameMessages;
			SetUpdateCommandStatus(true);
			break;

		case cmd_GotoEnemyMoves:
			mGotoEnemyMoves = !mGotoEnemyMoves;
			SetUpdateCommandStatus(true);
			break;


		case cmd_NewRendezvous:
			if (CStarMapView::GetClickType()==clickType_Rendezvous) {
				MapClickT *theClickInfo = (MapClickT*)ioParam;
				// begin tutorial stuff
              #if TUTORIAL_SUPPORT
				if (Tutorial::TutorialIsActive()) {
					Tutorial* t = Tutorial::GetTutorial();
					SInt16 pageNum = t->GetPageNum();
					if (pageNum == tutorialPage_SetRendezPt) {
						// we were waiting for them to click to locate the new rendezvous point,
						// but make sure they put it in the right place
						Waypoint wp = theClickInfo->clickedWP;
						AGalacticThingy* newTerra = (AGalacticThingy*)FindThingByID(tutorial_NewTerraStarID);
						AGalacticThingy* homeStar = (AGalacticThingy*)FindThingByID(tutorial_HomeStarID);
						UInt32 dist = newTerra->Distance(homeStar);
						UInt32 distNT = wp.Distance(newTerra);
						UInt32 distHm = wp.Distance(homeStar);
						// make sure the Rendezvous point is at least as close to each star
						// as the stars are to one another. This is more or less "between"
						if ( (distNT > dist) || (distHm > dist) ) {
							SysBeep(1);
							// send back false to let the caller know to restart the mouse tracking
							cmdHandled = false;
							break;
						}
					}
				}
              #endif //TUTORIAL_SUPPORT
				// end tutorial stuff
				CRendezvous *rpt = new CRendezvous(mStarMap, this);
				rpt->SetOwner(GetMyPlayerNum());
				rpt->SetPosition(theClickInfo->clickedWP, kRefresh);	// do refresh
				LStr255 s(STRx_NameYourNew, str_RendezvousPt);
				MovableParamText(0, s);
				s.Assign(STRx_General, str_New);	// Set name to New
				CGet1StringDlgHndlr *hdlr = new CGet1StringDlgHndlr(&s);	// will autodelete
				if ( 1 == MovableAlert(window_NameNewItem, this, 0, false, hdlr)) {
				    rpt->Persist();
					// begin tutorial stuff
                 #if TUTORIAL_SUPPORT
					if (Tutorial::TutorialIsActive()) {
						Tutorial* t = Tutorial::GetTutorial();
						SInt16 pageNum = t->GetPageNum();
						if (pageNum == tutorialPage_NameAlpha) {
							s = "Alpha";	// force the name
							// we were waiting for them to choose New Rendezvous
							t->NextPage();
						}
					}
                 #endif //TUTORIAL_SUPPORT
					// end tutorial stuff
					rpt->SetDescriptor(s);	// must set name after calling Persist()
					rpt->Refresh();
					rpt->Changed();
				} else {
					rpt->Refresh();	// so that we can erase ourself
					delete rpt;
				}
				StopAllMouseTracking();		// v1.2b9, ERZ, was	CStarMapView::ClickReceived();
			} else {
				CStarMapView::ClickPending(clickType_Rendezvous);	// tell starmap to use X cursor
				new CMouseTracker(mStarMap);	// tracker will report position upon next click
				// begin tutorial stuff
              #if TUTORIAL_SUPPORT
				if (Tutorial::TutorialIsActive()) {
					Tutorial* t = Tutorial::GetTutorial();
					SInt16 pageNum = t->GetPageNum();
					if (pageNum == tutorialPage_DoNewRendez) {
						// we were waiting for them to choose New Rendezvous
						t->NextPage();
					}
				}
              #endif //TUTORIAL_SUPPORT
   				// end tutorial stuff
			}
			break;

		case cmd_Delete:	// delete a rendezvous point
			if (mSelectedThingy && (mSelectedThingy->GetThingySubClassType() == thingyType_Rendezvous)) {
			    if (mSelectedThingy->GetOwner() == GetMyPlayerNum()) {
    				CRendezvous* rendezvous = static_cast<CRendezvous*>(mSelectedThingy);
    				rendezvous->RemoveSelfFromClient();
                	// now remove self from anything that refers to this
    				SetSelectedThingy(nil);
				} else {
				    SysBeep(1);
				}
			}
			break;

		case cmd_SwitchLanguages:
        {
			LArrayIterator *iterator = new LArrayIterator(mWindow->GetSubPanes(), LArrayIterator::from_Start);
			LPane* theSub;
			CResCaption* theResCaption;
			CBoxView* theBoxView;
			while (iterator->Next(&theSub)) {
				theResCaption = dynamic_cast<CResCaption*>(theSub);
				if (theResCaption) {
					theResCaption->ReloadStrRes();
				} else {
					theBoxView = dynamic_cast<CBoxView*>(theSub);
					if (theBoxView) {
						theBoxView->ListenToMessage(cmd_SwitchLanguages, nil);
					}
				}
			}
			delete iterator;
			break;
        }

		case cmd_ComparePlayers:
			DoComparePlayers();
			break;

      case cmd_ShowSystems:
         ShowSystemsWindow();
         break;

      case cmd_ShowFleets:
         ShowFleetsWindow();
         break;

		case cmd_RenameItem:
			if (mSelectedThingy) {	// ignore button click when nothing is selected
				if (mSelectedThingy->GetThingySubClassType() == thingyType_Fleet) {	// don't allow satellite fleets to be renamed
					if (((CFleet*)mSelectedThingy)->IsSatelliteFleet()) {
						DEBUG_OUT("Ignoring request to rename satellite fleet "<<mSelectedThingy, DEBUG_ERROR | DEBUG_USER);
						SysBeep(1);
						break;
					}
				}
				LStr255 s;
				mSelectedThingy->GetDescriptor(s);
				if ( UModalDialogs::AskForOneString(this, window_RenameItem, 100, s) ) {
				    // these characters all have special meaning and will cause problems if
				    // used in the name of a thingy
				    ReplaceIllegalCharacters(s, "*()@$#%/\t", '_');
					// tutorial, make sure they named it what we asked
                  #if TUTORIAL_SUPPORT
					if (Tutorial::TutorialIsActive()) {
						t = Tutorial::GetTutorial();
						if ( (t->GetPageNum() == tutorialPage_RenameColony) && 
							 (mSelectedThingy->GetPaneID() == tutorial_NewTerraStarID) ) {
							s = "New Terra";
							t->NextPage();
						}
					}
                  #endif //TUTORIAL_SUPPORT
					// end tutorial stuff
					mSelectedThingy->SetDescriptor(s);
					RebuildEventMessages();
					SwitchToButtonBar(mSelectedThingy->GetThingySubClassType());
				}
			}
            {
                LButton *theRenameButton = (LButton*) mWindow->FindPaneByID(-caption_ViewName);
                if (theRenameButton) {	// reset the button
                    theRenameButton->StopBroadcasting();
                    theRenameButton->SetValue(0);
                    theRenameButton->StartBroadcasting();
                }
            }
			break;

		case cmd_ZoomIn:
		case cmd_ZoomOut:
		case cmd_ZoomFill:
		case cmd_DisplayNone:
		case cmd_DisplayProduct:
		case cmd_DisplayTech:
		case cmd_DisplayDefense:
		case cmd_DisplayDanger:
		case cmd_DisplayGrowth:
		case cmd_DisplayShips:
		case cmd_DisplayResearch:
			mStarMap->ListenToMessage(inCommand, nil);
			break;

		case message_CellSelected:
			bCellSelected = true;	// this was a cell selected message, not a double-click
		case message_CellDoubleClicked:
        {
			CellInfoT *cellInfoP = (CellInfoT*)ioParam;
			if (mEventsWindow && (cellInfoP->tableID == table_Events)) {
				if (!CStarMapView::IsAwaitingClick()) {
					ASSERT(CNewTable::sActiveTable == mEventsTable); // if not, how did we get here?
					ThingMemInfoT info;
					if (cellInfoP->cell.row) {	// we selected nothing
						mNeedy->FetchItemAt(cellInfoP->cell.row, &info);
						AGalacticThingyUI *aThingy = ValidateThingyUI(info.thing);
						ASSERT(aThingy != NULL);	// thing wasn't valid
						if (aThingy) {
							aThingy->Select();	// select the appropriate item in the starmap
							if (!bCellSelected) {	// message was a double-click, not a select
								CMessage* msg = ValidateMessage(aThingy);
								ASSERT(msg != nil);				// item must be
								if (msg) {
									ASSERT(info.info.action == action_Message);	// a message object
									msg->PlayMessage();	// this will make messages play themselves
								} else {
									ASSERT(info.info.action != action_Message);	// we missed a message
								}
							}
						}
						if (bCellSelected) {	// the events list was selected, either through a
							CNewTable::sActiveTable = mEventsTable; //click or a nav keypress, so
						}						// make sure it ends up as the active list
					}
				} else {
					DEBUG_OUT("Cell Selected while StarMap awaiting click", DEBUG_ERROR | DEBUG_USER);
					SysBeep(1);
				}
			}
			break;
        }
        
		default:
			cmdHandled = LSingleDoc::ObeyCommand(inCommand, ioParam);
			break;
	}
	return cmdHandled;
}

Boolean	
GalacticaDoc::HandleKeyPress( const EventRecord& inKeyEvent ) {
	volatile UInt32 code = 0;
	code = (inKeyEvent.message & MacAPI::keyCodeMask) >> 8;
//	pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
	switch (code) {
    case 0x7A: // F1
    	mDrawShips = !mDrawShips;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_SHIPS, mDrawShips);
    	mWindow->Refresh();
    	return true;
    	break;
    case 0x78: // F2
    	mDrawNames = !mDrawNames;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_NAMES, mDrawNames);
    	mWindow->Refresh();
    	return true;
    	break;
    case 0x63: // F3
    	mDrawGrid = !mDrawGrid;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_GRIDLINES, mDrawGrid);
    	mWindow->Refresh();
    	return true;
    	break;
    case 0x76: // F4
    	mShowAllCourses = !mShowAllCourses;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_COURSES, mShowAllCourses);
    	mWindow->Refresh();
    	return true;
    	break;
    case 0x60: // F5
    	mDrawCourierCourses = !mDrawCourierCourses;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_COURIERS, mDrawCourierCourses);
    	mWindow->Refresh();
    	return true;
    	break;
    case 0x61: // F6
    	mDrawRangeCircles = !mDrawRangeCircles;
//    	config->setConfigBool(GALACTICA_PREF_SHOW_RANGES, mDrawRangeCircles);
    	mWindow->Refresh();
    	return true;
    	break;
	default:
		return LSingleDoc::HandleKeyPress(inKeyEvent);
	}
}

void
GalacticaDoc::FindCommandStatus(CommandT inCommand, Boolean &outEnabled, Boolean &outUsesMark,
								UInt16 &outMark, Str255 outName) {
	outMark = noMark;
	switch (inCommand) {

		// Return menu item status according to command messages.
		// Any that you don't handle will be passed to LApplication

		case cmd_EndTurn:
			outEnabled = !CStarMapView::IsAwaitingClick();
//			DEBUG_OUT("cmd_EndTurn is "<< ((outEnabled) ? "enabled" : "disabled") << ", awaiting click = " 
//			            << ((CStarMapView::IsAwaitingClick())?"true":"false"), DEBUG_IMPORTANT);
			outUsesMark = true;
			if ((mNumUnprocessedAutoShows>0) || (mNumUnprocessedGotos > 0))
				outMark = diamondMark;
			break;

		case cmd_ShowAllCourses:
			outEnabled = true;
			outUsesMark = true;
			if (mShowAllCourses)
				outMark = checkMark;
			break;

		case cmd_GotoCurr:
			outEnabled = (mSelectedThingy != nil);
			break;

		case cmd_GotoNext:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mNumUnprocessedGotos > 0);
			break;

		case cmd_ShowMessages:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mNumUnprocessedAutoShows > 0);
			break;

		case cmd_SendMessage:
			outEnabled = false;  // never send messages in a single player game
			break;

	  #ifdef DEBUG
		case 9101:		// goto a tutorial page
	  #endif
		case cmd_ShowHideEvents:
			outEnabled = true;
			break;

		case cmd_HoldMessages:
			outEnabled = true;
			outUsesMark = true;
			if (!mWantGameMessages) {
				outMark = checkMark;
			}
			break;

		case cmd_GotoEnemyMoves:
			outEnabled = true;
			outUsesMark = true;
			if (mGotoEnemyMoves) {
				outMark = checkMark;
			}
			break;

		case cmd_ComparePlayers:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mCompareWindow == NULL);
			break;

		case cmd_ShowSystems:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mSystemsWindow == NULL);
			break;

		case cmd_ShowFleets:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mFleetsWindow == NULL);
			break;

		case cmd_NewRendezvous:
		case cmd_GotoHome:
			outEnabled = !CStarMapView::IsAwaitingClick();
			break;

		case cmd_RenameItem:
			outEnabled = !CStarMapView::IsAwaitingClick() && (mSelectedThingy != NULL);
			break;

		default:
			LSingleDoc::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);
			break;
	}
}

Boolean
GalacticaDoc::AllowSubRemoval(LCommander* inSub) {
	if (inSub == mEventsWindow) {
		if (mEventsWindow == sEventsWindow) {
			sEventsWindow = NULL;
		}
		mEventsWereShown = false;
		mEventsWindow = NULL;	// we are closing the events window, clear the reference to it.
		mEventsTable = NULL;
		return true;
	} else if (inSub == mCompareWindow) {
		CKeyCmdAttach::EnableCmdKeys(); // disabled while compare window showing
		mCompareWindow = NULL;
		// begin tutorial stuff
      #if TUTORIAL_SUPPORT
		if (Tutorial::TutorialIsActive()) {
			Tutorial* t = Tutorial::GetTutorial();
			if (t->GetPageNum() == tutorialPage_CompPlayers) {
				t->NextPage();
			}
		}
      #endif //TUTORIAL_SUPPORT
		// end tutorial stuff
		return true;
	} else if (inSub == mSystemsWindow) {
		CKeyCmdAttach::EnableCmdKeys(); // disabled while star systems window showing
	    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
	    if (config) {
	    	Rect bounds;
	    	mSystemsWindow->GetGlobalBounds(bounds);
	    	long val = bounds.bottom - bounds.top;
	    	config->setConfigLong(GALACTICA_PREF_SYS_WIND_HEIGHT, val);
	    	val = bounds.left;
	    	config->setConfigLong(GALACTICA_PREF_SYS_WIND_XPOS, val);
	    	val = bounds.top;
	    	config->setConfigLong(GALACTICA_PREF_SYS_WIND_YPOS, val);
	    }
		mSystemsWindow = NULL;
		return true;
	} else if (inSub == mFleetsWindow) {
		CKeyCmdAttach::EnableCmdKeys(); // disabled while fleets window showing
	    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
	    if (config) {
	    	Rect bounds;
	    	mFleetsWindow->GetGlobalBounds(bounds);
	    	long val = bounds.bottom - bounds.top;
	    	config->setConfigLong(GALACTICA_PREF_FLEETS_WIND_HEIGHT, val);
	    	val = bounds.left;
	    	config->setConfigLong(GALACTICA_PREF_FLEETS_WIND_XPOS, val);
	    	val = bounds.top;
	    	config->setConfigLong(GALACTICA_PREF_FLEETS_WIND_YPOS, val);
	    }
		mFleetsWindow = NULL;
		return true;
	} else {
		return LSingleDoc::AllowSubRemoval(inSub);
	}
}


void
GalacticaDoc::ShowEventsWindow() {
 	if (mEventsWindow == NULL) {
		sStreamingDoc = this;  // some of the UI elements rely on sStreamingDoc to know what they should attach to
		mEventsWindow = LWindow::CreateWindow(window_EventReport, this);
		sStreamingDoc = NULL;
		ThrowIfNil_(mEventsWindow);	
		mEventsTable = (CEventTable*) mEventsWindow->FindPaneByID(table_Events);
		RGBColor white = {0xffff,0xffff,0xffff};		// setup colors for window
		RGBColor veryDarkGrey = {0x4444,0x4444,0x4444};
		mEventsWindow->SetForeAndBackColors(&white, &veryDarkGrey);
		mEventsTable->AddListener(mStarMap);
		Rect r;				// place the Event Report above the picture (top right of the screen)
		SDimension16 frameSize;
		Point p;
		mWindow->CalcPortFrameRect(r);
		mWindow->PortToGlobalPoint(topLeft(r));
		mWindow->PortToGlobalPoint(botRight(r));
		mEventsWindow->GetFrameSize(frameSize);
		p.v = r.top + 30;
		p.h = r.right - frameSize.width - 10;
		mEventsWindow->DoSetPosition(p);
	}
	ThrowIfNil_(mEventsTable);
	mEventsTable->InstallArray(mNeedy, false);
	SelectThingyInEventsWindow(mSelectedThingy);
	mEventsWindow->Show();
	mEventsWereShown = true;
	sEventsWindow = mEventsWindow;
}



/*----------------------------------------------------------------------------------------
MarkItemHandledInNeedyList() - Mark a specific item in the Needy list as handled

INPUT			index of the item to mark.
				Assumes mNeedy is a valid list. Invalid index entries are flagged
				in debug version but ignored otherwise. It it legal for item to
				already be flagged as handled.

SIDE EFFECTS	the handled flag in the info for that item in the needy list is set.

OUTPUT			none
----------------------------------------------------------------------------------------*/
void
GalacticaDoc::MarkItemHandledInNeedyList(ArrayIndexT inWhichItem) {
	ThingMemInfoT info;
	ASSERT(mNeedy != nil);
	ASSERT(inWhichItem <= mNeedy->GetCount());
	ASSERT(inWhichItem > 0);
	mNeedy->FetchItemAt(inWhichItem, &info);		// get the item, invalid index is ignored
	info.info.flags |= thingInfoFlag_Handled;
	mNeedy->AssignItemsAt(1, inWhichItem, &info);	// save the item, invalid index ignored
}


/*----------------------------------------------------------------------------------------
FindThingyInNeedyList() - Locate an *Unhandled* reference to the thingy in the list 
                          used for Event display.

	The Needy List holds all the events that occurred during the previous turn, and is
	used directly to display those events in the Events Report Window. Messages are the
	only items allowed to appear in the Needy list. Messages, however, refer to a particular
	Subject thingy, and we thing we are looking for in the list might be either the
	message itself, or the Subject of the message. Also we ignore any entries that are
	flagged as handled because we may have several references to the thingy in the Needy
	list and we want to eventually find them all.
	
	This function is primarily used by other functions such as SelectThingyInEventsWindow()
	to locate the item so they can select it.

INPUT			a ptr to a valid GalacticThingy
				a ptr to a variable of type ThingMemInfoT, to be filled with
					the Needy List entry for the found item.

SIDE EFFECTS	none

OUTPUT			returns the index of the found item in the mNeedy list, or LArray::index_Bad
				if the item wasn't found. outInfo is filled with the Needy list entry
				if one was found. If not, outInfo's contents are undefined.

NOTE			This gets called several time for the same item. A cache could save
				some time.
----------------------------------------------------------------------------------------*/
ArrayIndexT
GalacticaDoc::FindThingyInNeedyList(AGalacticThingy* inThingy, ThingMemInfoT *outInfo) {
	CMessage* msg;
	inThingy = ValidateThingy(inThingy);	// error checking on the input
	ASSERT(inThingy != nil);
	ASSERT(outInfo != nil);
	ASSERT(mNeedy != nil);
	if (mNeedy == nil) return LArray::index_Bad;
	if (inThingy == nil) return LArray::index_Bad;
	long numItems = mNeedy->GetCount();
	ArrayIndexT foundIdx = LArray::index_Bad;
	long i = 1;
	while (i<=numItems) {
		mNeedy->FetchItemAt(i, outInfo);
		if (!(outInfo->info.flags & thingInfoFlag_Handled)) {	// don't pay any attention to
			msg = ValidateMessage(outInfo->thing);				// items that are already handled
			ASSERT(msg != nil);
			if  ( (msg == inThingy)	// found it directly
				 || msg->IsSubject(inThingy) ) {	// found it as subject of a message
				foundIdx = i;
				break; // stop looking
			}
		}
		i++;
	}
	return foundIdx;
}

/*----------------------------------------------------------------------------------------
SelectThingyInEventsWindow() - Locate an *Unhandled* entry for the specified thingy and
			selects it in the events report window, if the window is available, and update
			the text in the Detail view.

INPUT			a ptr to a valid GalacticThingy, or NIL

SIDE EFFECTS	item is selected in the events window, but the EventsTable is prevented
				from broadcasting its usual cellSelected notice, which would call
				PlayMessage(). This is important because PlayMessage() needs to be able
				to use this call (indirectly at least).
				Also, ShowThingyEventText() is called so that the text of the message
				shown in the Event Report will appear overlaid on the item's picture in
				the Detail View. If inThingy is NIL, the Detail View text will be cleared,
				and the Event Report will be completely unchanged.

OUTPUT			none
----------------------------------------------------------------------------------------*/
void
GalacticaDoc::SelectThingyInEventsWindow(AGalacticThingy* inThingy) {
	CMessage* msg = nil;
//	Boolean bShown = false;
	if (inThingy && mNeedy) {	
		ThingMemInfoT info;
		ArrayIndexT idx = FindThingyInNeedyList(inThingy, &info);	// locate the item
		if (idx != LArray::index_Bad) {	// if the item was in the event report list, select it.
			msg = (CMessage*)info.thing;
			if (mEventsWindow && mEventsTable) {	// show selected thingy in the event list
				TableCellT cell;
				cell.col = 1;
				cell.row = idx;
				mEventsTable->StopBroadcasting();	// permitting broadcasts would have all
				mEventsTable->SelectCell(cell);		// kinds of undesirable side-effects
				mEventsTable->StartBroadcasting();	// since ObeyCommand() would think the
			}										// user had manually selected a cell
		}
	}
	ShowMessageEventText(msg);	// msg can be nil, if nothing found
}


/*----------------------------------------------------------------------------------------
ShowMessageEventText() - Put the appropriate text into the Detail view.

INPUT			a ptr to a valid CMessage thingy, or NIL

SIDE EFFECTS	text of the message as shown in the Event Report will appear overlaid 
				on the picture in the Detail View. If inMessage is NIL, the Detail View 
				text will be cleared.

OUTPUT			none
----------------------------------------------------------------------------------------*/
void
GalacticaDoc::ShowMessageEventText(CMessage* inMessage) {
	LStr255 s;
	ASSERT(ValidateMessage(inMessage) == inMessage);	// nil is a legal
	if (inMessage) {
		inMessage->GetDescriptor(s);	// put the message descriptor into the
		mEventText->SetDescriptor(s);	// event text
		mDimmerPict->Show();			// the dimmer darkens the picture underneath
		mEventText->Show();				// so that the text will show up better
	} else {
		mDimmerPict->Hide();
		mEventText->Hide();
	}
	mWindow->UpdatePort();	// еее not sure we want to do this, it causes flicker
}


void
GalacticaDoc::StartIdling() {
	LPeriodical::StartIdling();
	mIsIdling = true;
}

void
GalacticaDoc::StopIdling() {
	LPeriodical::StopIdling();
	mIsIdling = false;
}

void
GalacticaDoc::SpendTime(const EventRecord &) {
	// ====================== Repeated Constantly ============================

	UInt32 ticks = ::TickCount();
	if (mSelectedThingy) {		// if something is selected
		mSelectedThingy->UpdateSelectionMarker(ticks);
	}

	if (!mIsIdling) {	// stop here if we aren't idling
		return;
	}

	// ====================== Idle time processing only ============================
	
	if (CStarMapView::IsAwaitingClick() ) {	// don't do any further idle processing while tracking mouse
		return;
	}
	
}

void
GalacticaDoc::UserChangedSettings() {
	// when the user changes settings, do whatever is necessary to adapt to the new settings
	pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
	bool tempBool;
	if (config->getConfigBool(GALACTICA_PREF_PLAY_SOUND, tempBool)) {
		CSoundResourcePlayer::sPlaySound = tempBool;
	}
	if (config->getConfigBool(GALACTICA_PREF_PLAY_MUSIC, tempBool)) {
		CMidiMovieFilePlayer::sPlayMusic = tempBool;
	}
	if (config->getConfigBool(GALACTICA_PREF_FULL_SCREEN, tempBool)) {
 		Galactica::Globals::GetInstance().setFullScreenMode(tempBool);
		GalacticaApp* app = static_cast<GalacticaApp*>(LCommander::GetTopCommander());
 		app->AdjustAllGameWindows();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_SHIPS, tempBool)) {
 		SetDrawShips(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_COURSES, tempBool)) {
 		SetDrawAllCourses(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_NAMES, tempBool)) {
 		SetDrawNames(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_RANGES, tempBool)) {
 		SetDrawRangeCircles(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_COURIERS, tempBool)) {
 		SetDrawCourierCourses(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_GRIDLINES, tempBool)) {
 		SetDrawGrid(tempBool);
 		GetWindow()->Refresh();
	}
	if (config->getConfigBool(GALACTICA_PREF_SHOW_NEBULA, tempBool)) {
 		SetDrawStarmapNebulaBackground(tempBool);
 		GetWindow()->Refresh();
	}
	// make sure the default colony build levels are correct, ie: sum to 1000
	long tempGrowth, tempTech, tempShips;
	bool assigned = config->getConfigLong(GALACTICA_PREF_DEFAULT_GROWTH, tempGrowth);
	assigned &= config->getConfigLong(GALACTICA_PREF_DEFAULT_TECH, tempTech);
	assigned &= config->getConfigLong(GALACTICA_PREF_DEFAULT_SHIPS, tempShips);
    if (assigned) {
   		// make sure they sum to 1000
   		long sum = tempGrowth + tempTech + tempShips;
   		if (sum != 1000) {
   			// correct them if the didn't
   			long perSetting = (1000 - sum)/3;
   			long leftover = (1000 - sum)%3;
   			if (perSetting != 0) {
   				tempGrowth += perSetting;
   				tempTech += perSetting;
   				tempShips += perSetting;
   			}
   			if (leftover != 0) {
   				tempGrowth += leftover;
   			}
   			config->setConfigLong(GALACTICA_PREF_DEFAULT_GROWTH, tempGrowth);
   			config->setConfigLong(GALACTICA_PREF_DEFAULT_TECH, tempTech);
   			config->setConfigLong(GALACTICA_PREF_DEFAULT_SHIPS, tempShips);
   		}
   	}
	
}

void
GalacticaDoc::DoAESave(FSSpec& inFileSpec, OSType inFileType) {
	mIsSpecified = true;
	LStr255 s;
	mFile = new LFileStream(inFileSpec);
  #ifdef SINGLE_PLAYER_UNHOSTED						// ERZ, v1.2b9, unhosted single player games
	if (IsSinglePlayer()) {
		inFileType = type_SavedGameFile;		// this is a different type of file
	} else 
  #endif
	{
		inFileType = type_SavedTurnFile;
	}
	mFile->CreateNewDataFile(type_Creator, inFileType);
	GetDescriptor(s);
	mWindow->SetDescriptor(s);
	Galactica::Globals::GetInstance().getWindowMenu()->InsertWindow( mWindow );
	DoSave();
}


void
GalacticaDoc::Close() {
  #if TUTORIAL_SUPPORT
	if (Tutorial::TutorialIsActive()) {
		Tutorial::GetTutorial()->GotoPage(-1);
	}
  #endif //TUTORIAL_SUPPORT
	DEBUG_OUT("GameDoc::Close " << GetMyPlayerNum(), DEBUG_IMPORTANT | DEBUG_USER);
	if (sEventsWindow == mEventsWindow) {
		sEventsWindow = NULL;
	}
	LDocument::Close();
	CBalloonApp::sHelpLineDisplay = NULL;
}

void
GalacticaDoc::WindowActivated() {
	if (sEventsWindow != mEventsWindow) {	// don't bother unless this one different from old one
		if (sEventsWindow) {
			sEventsWindow->Hide();			// if there is an old events window, hide it
			sEventsWindow = NULL;
		}
		if (mEventsWindow && mEventsWereShown) {
			ShowEventsWindow();				// if have new window that was shown before, show again
		}
	}
	if (mShowMessagesPending) {	// another game window was in the front when this turn ended,
		ShowMessages();			// so ShowMessages() wasn't called then. Now that this game
		ShowNextNeedyThingy();	// window is active, we should go ahead and call show them.
	}
}



long
GalacticaDoc::GetSecondsRemainingInTurn() {
	if (mGameInfo.maxTimePerTurn) {		// first check to see if there is a time limit at all
		return mAutoEndTurnTimer.GetTimeRemaining();
	} else {
		return -1L;	// no time limit
	}
}


void
GalacticaDoc::RecalcHighestValues() {	// values calculated here are used by
	DEBUG_OUT("GameDoc::RecalcHighestValues " << GetMyPlayerNum(), DEBUG_IMPORTANT);
	int i, j;							//  AGalacticThingy::GetBrightness()
	AGalacticThingy* aThingy;
	for (i = displayMode_Product; i <= displayMode_Last; i++) {
		mHighest[i] = 0x80000000;
		mLowest[i]  = 0x7FFFFFFF;
	}
	for (i = 1; i <= mEverything.GetCount(); i++) {
		mEverything.FetchItemAt(i, aThingy);
		aThingy = ValidateThingy(aThingy);
		ASSERT(aThingy != nil);
		if (!aThingy)
			continue;
		if (aThingy->GetOwner()) {	// don't include unowned things in the caculations
			// 1.2b11d2, 6/9/99, don't include anything but stars in statistics
			if (aThingy->GetThingySubClassType() != thingyType_Star)	// don't get the following stats on
				continue;									// anything but stars
/*			if (aThingy->GetThingySubClassType() == thingyType_Ship) {	// don't get the following stats on
				CShip* ship = (CShip*)aThingy;
				if (ship->GetShipClass() == class_Scout) {	// 1.2b11d2, don't include scouts in strength
					continue;								// calculations
				}
			} */
			CStar* star = (CStar*) aThingy;
			long temp = star->GetTotalDefenseStrength();	// 1.2b11d2, include ships at planet in
															// star's defense strength
			mHighest[displayMode_Defense] = Max(mHighest[displayMode_Defense], temp);
			mLowest[displayMode_Defense] = Min(mLowest[displayMode_Defense], temp);
	//		temp = aThingy->GetDangerLevel();
	//		mHighest[displayMode_Danger] = Max(mHighest[displayMode_Danger], temp);
	//		mLowest[displayMode_Danger] = Min(mLowest[displayMode_Danger], temp);	
			temp = star->GetTechLevel();
			mHighest[displayMode_Tech] = Max(mHighest[displayMode_Tech], temp);
			mLowest[displayMode_Tech] = Min(mLowest[displayMode_Tech], temp);
			temp = star->GetProduction();
			mHighest[displayMode_Product] = Max(mHighest[displayMode_Product], temp);
			mLowest[displayMode_Product] = Min(mLowest[displayMode_Product], temp);
			for (j = spending_Growth; j <= spending_Last; j++) {
				mHighest[displayMode_Spendings+j] 
				  = Max(mHighest[displayMode_Spendings+j], star->GetSpending((ESpending)j));
				mLowest[displayMode_Spendings+j] 
				  = Min(mLowest[displayMode_Spendings+j], star->GetSpending((ESpending)j));
			}
		}
	}
}


void 
GalacticaDoc::ShowMessages() {
	ThingMemInfoT info;
	CMessage *msg;
	bool bDone;
	bool bWindAlreadyThere = false;
	bool bShowedMessage = false;
	UInt32 wakeupTicks = 0;	// no delay first time through
	DEBUG_OUT("GameDoc::ShowMessages " << GetMyPlayerNum(), DEBUG_IMPORTANT | DEBUG_MESSAGE);
	if (!mEventsWindow) {	// can't have a valid Events Table if Events Report Window is closed
 		mEventsTable = nil;
	} else {
		mEventsTable->InstallArray(nil, false);
		bWindAlreadyThere = true;
	}
	mNumUnprocessedAutoShows = 0;
	mNumUnprocessedGotos = 0;
	mShowMessagesPending = false;		// don't call ShowMessages() on window activation
	if (mNeedy) {	// nothing more to do here
		LArrayIterator needyIterator(*mNeedy);
		// 1st clear the junk out of the needy array
		while (needyIterator.Next(&info) ) {
			bool bRemove = false;
			if  (info.info.action != action_Message) {
				bRemove = true;							// not a message, dump it
				DEBUG_OUT("non-message item in Needy list", DEBUG_ERROR | DEBUG_MESSAGE);
			} else if (!(info.info.flags & thingInfoFlag_Handled)) {
				msg = ValidateMessage(info.thing);		// locate the message refered to
				if (msg && !FogOfWarOverride()) {
                	int me = GetMyPlayerNum();
                	AGalacticThingy* subject = msg->GetSubject();
                	if (subject && !subject->IsAllyOf(me) && (subject->GetVisibilityTo(me) == visibility_None)
                	  && (!msg->MessageIsAboutMe()) ) {
                	    bRemove = true;    // dump messages about things we can't see, unless we were involved
					    DEBUG_OUT("Subject not visible to me: " << info.thing, DEBUG_DETAIL | DEBUG_MESSAGE);
                	}
                }
		 		if (!msg) {								// no such message found, dump it
		 			bRemove = true;
					DEBUG_OUT("Invalid message object in Needy list", DEBUG_ERROR | DEBUG_MESSAGE);
		 		} else if (!msg->MessageIsToMe()) {
					DEBUG_OUT("Message is not to me: "<<info.thing, DEBUG_DETAIL | DEBUG_MESSAGE);
					bRemove = true;				// we aren't a legal recipient
		 		} else if (info.info.flags & thingInfoFlag_AutoShow) {
		 			ASSERT(msg->HasAutoShow());
					DEBUG_OUT("Valid autoplay found: "<<info.thing, DEBUG_DETAIL | DEBUG_MESSAGE);
					mNumUnprocessedAutoShows++;	// haven't shown some autoplay messages
				} else if (msg->MessageIsAboutMe()) {
					DEBUG_OUT("Unprocessed Goto found: "<<info.thing, DEBUG_DETAIL | DEBUG_MESSAGE);
					mNumUnprocessedGotos++;		// it's for us, mark that we have gotos
				} else {
					DEBUG_OUT("Foreign Goto found: "<<info.thing, DEBUG_DETAIL | DEBUG_MESSAGE);
					bRemove = true;				// remove non-autoshow events that are not addressed to us
	 			}
	 		} else {	// thing already handled, will happen when we reload Needy list from a saved game
				DEBUG_OUT(info.thing<<" already handled", DEBUG_DETAIL | DEBUG_MESSAGE);
	 		}
	  		if (bRemove) {
	 			DEBUG_OUT("Removing " << msg<< " from client Needy list", DEBUG_DETAIL | DEBUG_MESSAGE);
	 			ArrayIndexT which = needyIterator.GetCurrentIndex();
	 			mNeedy->RemoveItemsAt(1, which);
				if (msg && !msg->SendDeleteInfo()) {	// kill the message here because the host won't
	 				msg->Die();						// tell us to die next turn
					DEBUG_OUT("Killed " << msg << ", Deleting...", DEBUG_DETAIL | DEBUG_MESSAGE);
					delete msg;		// delete it immediately, to avoid having dangling refs.
				}
	 		}
		}
		// 2nd, set up the needy array
		if ((mNumUnprocessedAutoShows == 0) && (mNumUnprocessedGotos == 0)) {
			DEBUG_OUT("Deleting Needy Iterator", DEBUG_DETAIL | DEBUG_MESSAGE);
			delete mNeedyIterator;
			mNeedyIterator = nil;
		} else if (mNumUnprocessedGotos > 0) {		// have gotos, prepare the gameDoc's needy iterator
			DEBUG_OUT("Setting up Needy Iterator to start from 1st item", DEBUG_DETAIL | DEBUG_MESSAGE);
			if (mNeedyIterator == nil) {
	 			mNeedyIterator = new LArrayIterator(*mNeedy, 1);
	 		} else {
	 			mNeedyIterator->ResetTo(1);
	 		}
	 	}
		needyIterator.ResetTo(0);
		if (bWindAlreadyThere) {
			mEventsTable->InstallArray(mNeedy, false);
			mEventsTable->UpdatePort();	// only needed because we removed line below
	//		SelectThingyInEventsWindow(mSelectedThingy);
		}
		if (!mWantGameMessages || (mNumUnprocessedAutoShows==0)) // don't have messages or don't want
			goto EXIT;											 // them, nothing more to do here
		// 3rd, go through the needy array displaying the autoplay events
		DEBUG_OUT("Beginning message auto-play, "<<mNeedy->GetCount()<<" items in Needy list.", DEBUG_IMPORTANT | DEBUG_MESSAGE);
		while ( needyIterator.Next(&info) ) {
			bDone = !mWantGameMessages;			// in case user turns it off while we are looping
			if (bDone) {	// || mWaitMessages	// if user clicked on Later All button, stop message display
				break;
			}
			if (info.info.flags & thingInfoFlag_Handled) {		// don't display if already handled
				DEBUG_OUT("Skipping "<<(CMessage*)info.thing<<", already handled", DEBUG_DETAIL | DEBUG_MESSAGE);
		 		goto NEXT_ITEM;
		 	}
		 	if (!(info.info.flags & thingInfoFlag_AutoShow)) {	// only want autoplay events
				DEBUG_OUT("Skipping "<<(CMessage*)info.thing<<", not autoplay", DEBUG_DETAIL | DEBUG_MESSAGE);
		 		goto NEXT_ITEM;
		 	}
	 		msg = (CMessage*)info.thing;	// locate the message refered to
	 		ASSERT(ValidateMessage(msg));	// extreme sanity check
			if (!msg) {
				DEBUG_OUT("NIL Message in Needy thingys array", DEBUG_ERROR | DEBUG_MESSAGE);
				mNumUnprocessedAutoShows--;	// was counted as autoshow: now processed, displayed or not
				goto NEXT_ITEM;	// couldn't find it
			}
	 		if (!mGotoEnemyMoves && !(msg->MessageIsAboutMe() || msg->MessageConcernsEveryone()) ) {	// not about me, skip over it but leave it in list		
				DEBUG_OUT("Skipping "<<msg<<", of no concern to me", DEBUG_DETAIL | DEBUG_MESSAGE);
				mNumUnprocessedAutoShows--;	// was counted as autoshow: now processed, displayed or not
				msg->MessageHandled();
				goto NEXT_ITEM;
			}
            {
                MacAPI::HideCursor();
                UPlaybackDelay flasher(mSelectedThingy);
                bShowedMessage = true; // we actually played a message
                bDone = UDelay::UserAbortableDelayUntil(wakeupTicks, &flasher);// now we do the delay between messages
                MacAPI::MacShowCursor();
            }
			if (bDone) {	// user aborted
				break;
			}
			wakeupTicks = ::TickCount() + 240;	// start timer from before message display
			// begin tutorial stuff
          #if TUTORIAL_SUPPORT
			if (Tutorial::TutorialIsActive()) {
//				Tutorial* t = Tutorial::GetTutorial();
//				SInt16 pageNum = t->GetPageNum();
				// longer playback delay during tutorial
				wakeupTicks += 240;
			}
          #endif //TUTORIAL_SUPPORT
			// end tutorial stuff
			DEBUG_OUT("Playing "<<msg, DEBUG_DETAIL | DEBUG_MESSAGE);
			msg->PlayMessage();
			if (msg->HasModalWindow()) {
				// if the message displayed a modal window, thereby requiring the user
				// to hit a key to see the next event, don't delay any further before
				// displaying the next event.
				wakeupTicks = 0;
				DEBUG_OUT(msg<<" displayed a modal window, skipping normal delay", DEBUG_DETAIL | DEBUG_MESSAGE);
			}
			// begin tutorial stuff
          #if TUTORIAL_SUPPORT
			if (Tutorial::TutorialIsActive()) {
				Tutorial* t = Tutorial::GetTutorial();
				SInt16 pageNum = t->GetPageNum();
				if ( (pageNum == tutorialPage_NewColonyShip) ||
					 (pageNum == tutorialPage_NewSatellite) ||
					 (pageNum == tutorialPage_NewTraveler) ||
					 (pageNum == tutorialPage_EndTurnSix) ||				 
					 (pageNum == tutorialPage_NewCourier) ) {
					// we were waiting for them to respond to a message
					if (pageNum == tutorialPage_NewTraveler) {
						mGotoEnemyMoves = false;	// turn off show enemy moves
					}
					t->NextPage();
				}
			}
          #endif //TUTORIAL_SUPPORT
			// end tutorial stuff
			mWindow->UpdatePort();

		  NEXT_ITEM:
			bDone = true;	// if there is nothing left, we are done, otherwise, done will be reset above
		}
		if (bDone) {
			mNumUnprocessedAutoShows = 0;	// clear the messages pending flag
		}
		::FlushEvents(mDownMask + mUpMask, 0);	// get rid of any mouse click events
	}
  EXIT:
	if (mNumUnprocessedGotos > 0) {		// if we have gotos, pause before displaying them
		if (mWantGameMessages) {		// but don't pause if the user turned off Show Messages
			UPlaybackDelay flasher(mSelectedThingy);
			UDelay::UserAbortableDelayUntil(wakeupTicks, &flasher);
		}
	} else {	
		if (mOldSelectedThingy) {		// there are no gotos to be selected, so we can reselect
			if (ValidateThingyUI(mOldSelectedThingy)) {
				if (mWantGameMessages) {	// v2.0.2 we don't want to just flash past the last message
					UPlaybackDelay flasher(mSelectedThingy);
					UDelay::UserAbortableDelayUntil(wakeupTicks, &flasher);
				}
				mOldSelectedThingy->Select();	// the previously selected item
			} else {
			   if (!bShowedMessage) {
			      // v2.1b12 if no message shown, and nothing selected, select the starmap
			      SwitchToButtonBar(0);
			      SetSelectedThingy(NULL);
			   }
				DEBUG_OUT("mOldSelectedThingy was invalid at the end of ShowMessages.", DEBUG_ERROR | DEBUG_MESSAGE);
			}
		} else {
			if (!bShowedMessage) {
			   // v2.1b12 if no message shown, and nothing selected, select the starmap
			   SwitchToButtonBar(0);
			   SetSelectedThingy(NULL);
			}
	   }
	}
	mOldSelectedThingy = nil;
	// tutorial stuff
	// these are here to catch start of new turn where no events are shown
  #if TUTORIAL_SUPPORT
	if (Tutorial::TutorialIsActive()) {
		Tutorial* t = Tutorial::GetTutorial();
		SInt16 pageNum = t->GetPageNum();
		if (pageNum == tutorialPage_EndTurnTwo) {
			// we were waiting for them to end the turn. They did, and now they are getting
			// message playback
			// need to make sure the colony ship is selected
			AGalacticThingy* it = FindThingByID(tutorial_ColonyShipID);
			if (it) {
				it->AsThingyUI()->Select();
			}
			t->NextPage();
		}
	}
  #endif //TUTORIAL_SUPPORT
}

void
GalacticaDoc::ShowNextNeedyThingy(bool inSelectHomeIfNothing) {
	ThingMemInfoT info;
	CMessage *msg;
//	bool bWindShown = false;
	DEBUG_OUT("GameDoc::ShowNextNeedyThingy " << GetMyPlayerNum(), DEBUG_IMPORTANT | DEBUG_MESSAGE);
	SetUpdateCommandStatus(true);	// make sure the End Turn menu command is updated
	if (mNeedy == nil) {
		mNumUnprocessedGotos = 0;
		if (inSelectHomeIfNothing) {
		   ObeyCommand(cmd_GotoHome, 0);
		}
	}
	if (mNumUnprocessedGotos <= 0) {
		return;
	}
 	if (!mEventsWindow) {	// can't have a valid Events Table if Events Report Window is closed
 		mEventsTable = nil;
 	}
	if (mNeedyIterator->Current(&info)) {
	 	do {	// look for messages that don't autoshow, we will handle them here
	 		if (!(info.info.flags & thingInfoFlag_Handled)) {
	 			msg = ValidateMessage(info.thing);
	 			ASSERT(msg != nil);
				if (!msg) {
					DEBUG_OUT("Invalid Message in Needy thingys array", DEBUG_ERROR | DEBUG_MESSAGE);
					continue;	// couldn't find it
				}
				if (msg->HasAutoShow()) {
					DEBUG_OUT("Skipping "<<msg<<", autoshown", DEBUG_DETAIL | DEBUG_MESSAGE);
					DEBUG_OUT("Autoshow event "<<msg<<" that is not marked handled found in Needy list", DEBUG_IMPORTANT | DEBUG_MESSAGE);
					continue;	// skip ones that autoshow
				}
				DEBUG_OUT("Playing "<<LongTo4CharStr(msg->GetThingySubClassType())<<" "<<msg->GetID()<<" ["<<msg->GetOwner()<<"]", DEBUG_DETAIL | DEBUG_MESSAGE);
				if (mSelectedThingy && (msg->GetSubject() == mSelectedThingy)) {
					ThingyAttendedTo(msg);	// if the subject is already selected, the message won't
				}							// get marked as handled when the message is played, so
				msg->PlayMessage();			// we had to mark it manually.
              #if TUTORIAL_SUPPORT
				if (Tutorial::TutorialIsActive()) {
					Tutorial* t = Tutorial::GetTutorial();
					SInt16 pageNum = t->GetPageNum();
					if ( (pageNum == tutorialPage_EnemyMove) ||
						 (pageNum == tutorialPage_EndTurnFive) || 
						 (pageNum == tutorialPage_EndTurnSeven) || 
						 (pageNum == tutorialPage_HitTab) ||
						 (pageNum == tutorialPage_AnotherColony) ||
						 (pageNum == tutorialPage_EnemyMove2) ) {
						// we were waiting for them to go to next event
						if (pageNum == tutorialPage_EnemyMove) {
							// about to ask them to move ships, make sure zoom is reasonable
							float zoom = mStarMap->GetZoom();
							if ( (zoom < 1.9) || (zoom > 6.0)) {
								mStarMap->ZoomTo(4.0);
							}
						}
						t->NextPage();
					}
				}
              #endif //TUTORIAL_SUPPORT
				break;	// stop looping now
			}
	 	} while (mNeedyIterator->Next(&info));	// get the next item
 	}
 	do {
		if (!mNeedyIterator->Next(&info)) {	//have we reached the end of the list?
			DEBUG_OUT("Deleting Needy iterator, all events handled", DEBUG_IMPORTANT | DEBUG_MESSAGE);
	 		mNumUnprocessedGotos = 0;		// yes: nothing else needs our attention.
	 		delete mNeedyIterator;			// so delete the iterator
	 		mNeedyIterator = nil;
	 		break;							// don't look any more
	 	} 
	} while (info.info.flags & thingInfoFlag_Handled);
}


void
GalacticaDoc::DoPrint() {
}


// population,production capacity, average tech, highest tech
// lowest tech, ship power, average ship tech, number of ships, number of planets
void
GalacticaDoc::DoComparePlayers() {
	if (mCompareWindow) {	// do nothing if player comparision window already open
		return;			// Added ERZ, Sat 10/4/97, v1.2d7
	}
	AGalacticThingy	*aThingy;
	UInt16	MaxPlayers = mGameInfo.totalNumPlayers;	//changed line ERZ, Fri 7/12/96
	tSummaryP	Summary;
	long		ThingyType, Player, Tech, Stars, Ships, Power;	// added Power, ERZ, 9/16/97
	long		i;
	SPaneInfo	Info2;
	SViewInfo	VInfo;
	tSummaryRec	MaxValues, MinValues;	// ERZ 7/19/96 added MinValues
	RGBColor	Grey;
	LArray	*theSummary;
	CSummaryLine*		SummaryLine;

	Grey.red = 0xDFFF;
	Grey.blue = 0xDFFF;
	Grey.green = 0xDFFF;
	
	theSummary = new LArray(sizeof(Summary));
	
	// Set Null state for all Summary Records
	for(i=0;i<=MaxPlayers;i++) {
      std::string playerName;
      bool knownPlayer = GetPlayerNameAndStatus(i, playerName);
		Summary=(tSummaryP)NewPtr(sizeof(tSummaryRec));
		if(i==0) {
		   // unowned systems
			Summary->italicizeName = true;	// added line ERZ, Fri 7/12/96
		} else if (!knownPlayer) {
  		   // unassigned humans
   		Summary->italicizeName = true;
   		LoadStringResource(playerName, STRx_General, str_Unknown_);
		} else {
		   // computers and assigned humans
			Summary->italicizeName = false;	// added line ERZ, Fri 7/12/96
 		}
		std::strcpy(Summary->Name, playerName.c_str());
		Summary->Stars = 0;
		Summary->Population = 0;
		Summary->Production = 0;
		Summary->StarLow = 0;
		Summary->StarHigh = 0;
		Summary->StarAvg = 0;
		Summary->Ships = 0;
		Summary->Power = 0;
		Summary->ShipLow =  0;
		Summary->ShipHigh = 0;
		Summary->ShipAvg = 0;
		Summary->dead = false;
		theSummary->InsertItemsAt(1, i+1, &Summary);
	}
	
	// Iterate through list of everything
	LArrayIterator iterator(mEverything, LArrayIterator::from_Start); // Search list of all thingys created
	while (iterator.Next(&aThingy)) {
		Player = aThingy->GetOwner();
		if (Player > MaxPlayers)
			continue;	// probably a CMessage, so don't add it to the statistics ERZ 7/19/96
        if (aThingy->IsDead()) {
            continue;   // don't count dead things ERZ 4/9/2002, 2.1b6
        }
		ThingyType = aThingy->GetThingySubClassType();
		theSummary->FetchItemAt(Player+1, &Summary);
		switch (ThingyType) {
			case thingyType_Star:
            {
				CStar* tempStar = static_cast<CStar*>(aThingy);
				// Number of stars
				++(Summary->Stars);	// Inc star count

				// Total Population
				Summary->Population += tempStar->GetPopulation();

				// Total Production
				Summary->Production += tempStar->GetProduction();
/*				Setting = tempStar->GetSettingPtr(1);
				long x = Setting->GetBenefits();
				if (x > 0)
					Summary->Production += x;
				Setting = tempStar->GetSettingPtr(2);
				x = Setting->GetBenefits();
				if (x > 0)
					Summary->Production += x; */

				// Star tech statistics
				Tech = aThingy->GetTechLevel();			// Get Tech level of star
				if((Tech < Summary->StarLow) || (Summary->Stars == 1)) {	// Check to see if it is lowest
					Summary->StarLow = Tech;
				}
				if ((Tech > Summary->StarHigh) || (Summary->Stars == 1)) {	// Check to see if it is highest
					Summary->StarHigh = Tech;
				}
				Summary->StarAvg += Tech;

				break;
            }

			case thingyType_Ship:
				// Number of ships
				++(Summary->Ships);	// Inc ship count

				// Total Power
				Power = ((CShip*)aThingy)->GetPower();	// еее ERZ changes, added Power, 9/16/97
				Summary->Power += Power;

				Tech = aThingy->GetTechLevel();			// Get Tech level of ship

				// Ship tech statistics
				if((Tech < Summary->ShipLow) || (Summary->Ships == 1)) {	// Check to see if it is lowest
					Summary->ShipLow = Tech;
				}
				if ((Tech > Summary->ShipHigh) || (Summary->Ships == 1)) {	// Check to see if it is highest
					Summary->ShipHigh = Tech;
				}
				Summary->ShipAvg += Tech;

				break;
		}
	}
	
	// Null values
	MaxValues.Stars = 0;
	MaxValues.Population = 0;
	MaxValues.Production = 0;
	MaxValues.StarLow = 0;
	MaxValues.StarHigh = 0;
	MaxValues.StarAvg = 0;
	MaxValues.Ships = 0;
	MaxValues.Power = 0;
	MaxValues.ShipLow =  0;
	MaxValues.ShipHigh = 0;
	MaxValues.ShipAvg = 0;
	MinValues.Stars = 0x7FFFFFFF;
	MinValues.Population = 0x7FFFFFFF;
	MinValues.Production = 0x7FFFFFFF;
	MinValues.StarLow = 0x7FFFFFFF;
	MinValues.StarHigh = 0x7FFFFFFF;
	MinValues.StarAvg = 0x7FFFFFFF;
	MinValues.Ships = 0x7FFFFFFF;
	MinValues.Power = 0x7FFFFFFF;
	MinValues.ShipLow = 0x7FFFFFFF;
	MinValues.ShipHigh = 0x7FFFFFFF;
	MinValues.ShipAvg = 0x7FFFFFFF;
	// Calculate Averages
	theSummary->FetchItemAt(0+1, &Summary);
	Stars = Summary->Stars;
	if(Stars > 0) {	// Don't want to divide by zero now do we
		Summary->StarAvg = Summary->StarAvg / Stars;
	}
	Ships = Summary->Ships;
	if(Ships > 0) {	// Don't want to divide by zero now do we
		Summary->ShipAvg = Summary->ShipAvg / Ships;
	}
	for(i=1;i<=MaxPlayers;i++) {
		theSummary->FetchItemAt(i+1, &Summary);
		Summary->dead = ( (Summary->Stars <= 0) && (Summary->Ships <= 0) );
		if (Summary->dead)	// ignore dead people  еее ERZ 7/19/96
			continue;
		Stars = Summary->Stars;
		if(Stars > 0) {	// Don't want to divide by zero now do we
			Summary->StarAvg = Summary->StarAvg / Stars;
			if(Summary->Stars > MaxValues.Stars) {	//max
				MaxValues.Stars = Summary->Stars;
			}
			if(Summary->Stars < MinValues.Stars) {	// min
				MinValues.Stars = Summary->Stars;
			}			
			if(Summary->Population > MaxValues.Population) {
				MaxValues.Population = Summary->Population;
			}
			if(Summary->Population < MinValues.Population) {	// min
				MinValues.Population = Summary->Population;
			}			
			if(Summary->Production > MaxValues.Production) {
				MaxValues.Production = Summary->Production;
			}
			if(Summary->Production < MinValues.Production) {	// min
				MinValues.Production = Summary->Production;
			}			
			if(Summary->StarLow > MaxValues.StarLow) {
				MaxValues.StarLow = Summary->StarLow;
			}
			if(Summary->StarLow < MinValues.StarLow) {	// min
				MinValues.StarLow = Summary->StarLow;
			}			
			if(Summary->StarHigh > MaxValues.StarHigh) {
				MaxValues.StarHigh = Summary->StarHigh;
			}
			if(Summary->StarHigh < MinValues.StarHigh) {	// min
				MinValues.StarHigh = Summary->StarHigh;
			}			
			if(Summary->StarAvg > MaxValues.StarAvg) {
				MaxValues.StarAvg = Summary->StarAvg;
			}
			if(Summary->StarAvg < MinValues.StarAvg) {	// min
				MinValues.StarAvg = Summary->StarAvg;
			}			
		}
		Ships = Summary->Ships;
		if(Ships > 0) {	// Don't want to divide by zero now do we
			Summary->ShipAvg = Summary->ShipAvg / Ships;
			if(Summary->Ships > MaxValues.Ships) {
				MaxValues.Ships = Summary->Ships;
			}
			if(Summary->Ships < MinValues.Ships) {	// min
				MinValues.Ships = Summary->Ships;
			}			
			if(Summary->Power > MaxValues.Power) {
				MaxValues.Power = Summary->Power;
			}
			if(Summary->Power < MinValues.Power) {	// min
				MinValues.Power = Summary->Power;
			}			
			if(Summary->ShipLow > MaxValues.ShipLow) {
				MaxValues.ShipLow = Summary->ShipLow;
			}
			if(Summary->ShipLow < MinValues.ShipLow) {	// min
				MinValues.ShipLow = Summary->ShipLow;
			}			
			if(Summary->ShipHigh > MaxValues.ShipHigh) {
				MaxValues.ShipHigh = Summary->ShipHigh;
			}
			if(Summary->ShipHigh < MinValues.ShipHigh) {	// min
				MinValues.ShipHigh = Summary->ShipHigh;
			}			
			if(Summary->ShipAvg > MaxValues.ShipAvg) {
				MaxValues.ShipAvg = Summary->ShipAvg;
			}
			if(Summary->ShipAvg < MinValues.ShipAvg) {	// min
				MinValues.ShipAvg = Summary->ShipAvg;
			}			
		}
	}
	
	mCompareWindow = LWindow::CreateWindow(window_ComparePlayers, this);
	// begin tutorial stuff
  #if TUTORIAL_SUPPORT
	if (Tutorial::TutorialIsActive()) {
		Tutorial* t = Tutorial::GetTutorial();
		if (t->GetPageNum() == tutorialPage_DoCompPlayers) {
			t->NextPage();
		}
	}
  #endif //TUTORIAL_SUPPORT
	// end tutorial stuff
	CKeyCmdAttach::DisableCmdKeys(); // no keyboard shortcuts while compare window showing
	
	LView* theView = (LView*)mCompareWindow->FindPaneByID(1001);
	SDimension32 iSize;
	theView->GetImageSize(iSize);
	theView->ResizeImageTo(iSize.width, 16*(MaxPlayers+1), false);
	// set up listeners for the sort buttons
	for (int i = base_SortButtonPaneId; i < (base_SortButtonPaneId + num_SortCommands); i++) {
	    LControl* theControl = dynamic_cast<LControl*>( mCompareWindow->FindPaneByID(i) );
	    if (theControl) {
	        theControl->AddListener(&mControlListener);
	    }
	}
	// Create Panes in list
	Info2.paneID = 0;
	Info2.width = (589+46);
	Info2.height = 16;
	Info2.visible = TRUE;
	Info2.enabled = TRUE;
	Info2.bindings.left = FALSE;
	Info2.bindings.right = FALSE;
	Info2.bindings.top = FALSE;
	Info2.bindings.bottom = FALSE;
	Info2.left = 0;
	Info2.top = 0;
	Info2.userCon = 0;
	Info2.superView = theView;
	Info2.paneID = 1100;
	VInfo.imageSize.width = Info2.width;
	VInfo.imageSize.height = Info2.height;
	VInfo.scrollPos.h = 0;
	VInfo.scrollPos.v = 0;
	VInfo.scrollUnit.h = 0;
	VInfo.scrollUnit.v = 0;
	VInfo.reconcileOverhang = 0;
	
	for(i=0;i<=MaxPlayers;i++) {
		theSummary->FetchItemAt(i+1, &Summary);
		Info2.top = i * 16;
		SummaryLine = new CSummaryLine(Info2, VInfo);
		SummaryLine->FinishCreate();
		if (i > 0) {		// еее added player color, ERZ
			RGBColor* c = GetColor(i, false);
			SummaryLine->SetDotColor(*c);
		}
		if(i % 2) {
			SummaryLine->SetBackColor(Grey);
		}
		SummaryLine->SetSummary(*Summary, MaxValues, MinValues, i);	// еее added Min values ERZ
	}
		
	for(i=0;theSummary->FetchItemAt(i+1,&Summary);i++) {
		if(Summary != NULL) {
			DisposePtr((Ptr)Summary);
		}
	}
	
	delete theSummary;
}


void
GalacticaDoc::SortCompareWindowByColumn(int columnNum) {
}

// called by CSystemInfoLine in response to a double-click
void
GalacticaDoc::CloseSystemsWindow() {
    if (mSystemsWindow) {
        SPoint32 scrollPos;
	    LView* theView = static_cast<LView*>( mSystemsWindow->FindPaneByID(1001) );
        if (theView) {
            theView->GetScrollPosition(scrollPos);
            mSystemsScrollPos = scrollPos.v;
        }
        mSystemsWindow->DoClose();
        // DoClose will call AllowSubRemoval, which will cleanup the mSystemsWindow variable
        mSystemsList.clear();
    }
}

void
GalacticaDoc::ShowSystemsWindow() {
    mSystemsList.clear();
	LArray* everything = GetEverythingList();
	int last = everything->GetCount();
	int playerNum = GetMyPlayerNum();
	for (int i = 1; i <= last; i++) {
	    AGalacticThingy* it;
		everything->FetchItemAt(i, &it);
		long type = it->GetThingySubClassType();
		if (type != thingyType_Star) {
		   break;   // reached the end of the stars
		}
		if (it->GetOwner() == playerNum) {
		   // found another of our stars, add it to list
		   CStar* star = static_cast<CStar*>(it);
		   mSystemsList.insert(mSystemsList.end(), star);
		}
	}
    mSystemsWindow = LWindow::CreateWindow(window_StarSystems, this);
	CKeyCmdAttach::DisableCmdKeys(); // no keyboard shortcuts while systems window showing
	LView* theView = static_cast<LView*>( mSystemsWindow->FindPaneByID(1001) );
	SDimension32 iSize;
	theView->GetImageSize(iSize);
	theView->ResizeImageTo(iSize.width, 16 * mSystemsList.size(), false);
	theView->ScrollImageTo(0, mSystemsScrollPos, kDontRefresh);
	// set up listeners for the sort buttons
	for (int i = base_SortButtonPaneId; i < (base_SortButtonPaneId + num_SortCommands); i++) {
	    LControl* theControl = dynamic_cast<LControl*>( mSystemsWindow->FindPaneByID(i) );
	    if (theControl) {
	        theControl->AddListener(&mControlListener);
	    }
	}
    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
    if (config) {
    	Rect bounds;
    	mSystemsWindow->GetGlobalBounds(bounds);
    	long val = 0;
    	config->getConfigLong(GALACTICA_PREF_SYS_WIND_HEIGHT, val);
    	if (val > 0) {
    		bounds.bottom = bounds.top + val;
    	}	
    	val = 0;
    	config->getConfigLong(GALACTICA_PREF_SYS_WIND_XPOS, val);
    	if (val > 0) {
    		long width = bounds.right - bounds.left;
    		bounds.left = val;
    		bounds.right = bounds.left + width;
    	}
    	val = 0;
    	config->getConfigLong(GALACTICA_PREF_SYS_WIND_YPOS, val);
    	if (val > 0) {
    		long height = bounds.bottom - bounds.top;
    		bounds.top = val;
    		bounds.bottom = bounds.top + height;
    	}
    	mSystemsWindow->DoSetBounds(bounds);
    }
	SortSystemsWindowByColumn(mSystemsSortColumn);
	mSystemsWindow->Show();
}

struct SortSystemsByColumn {
    SortSystemsByColumn(int columnNum) : mColumnNum(columnNum) {}
    bool operator()(CStar* const& startStar, CStar* const& endStar) {
        bool result = false;
        switch(mColumnNum) {
        case 1:
            // tech level
            result = (startStar->GetTechLevel() > endStar->GetTechLevel());
            break;
        case 2:
            // population
            result = (startStar->GetPopulation() > endStar->GetPopulation());
            break;
        case 3:
            // production
            result = (startStar->GetProduction() > endStar->GetProduction());
            break;
        case 4:
            // building ship type
            {
                long hull1 = startStar->GetBuildHullType();
                long hull2 = endStar->GetBuildHullType();
                if (hull1 == class_Fighter) {
                   hull1 += startStar->GetTechLevel()/5;
                }
                if (hull2 == class_Fighter) {
                   hull2 += endStar->GetTechLevel()/5;
                }
                result = (hull1 > hull2);
            }
            break;
        case 5:
            // % complete
            result = (startStar->GetShipPercentComplete() > endStar->GetShipPercentComplete());
            break;
        case 6:
            // total system power
            result = (startStar->GetTotalDefenseStrength() > endStar->GetTotalDefenseStrength());
            break;
        case 7:
            // satellites power
            {
                long power1 = 0;
                long power2 = 0;
                CFleet* satFleet = startStar->GetSatelliteFleet();
                if (satFleet) {
                    power1 = ((satFleet->GetPower()*100) - satFleet->GetDamage()) / 100;
                }
                satFleet = endStar->GetSatelliteFleet();
                if (satFleet) {
                    power2 = ((satFleet->GetPower()*100) - satFleet->GetDamage()) / 100;
                }
                result = (power1 > power2);
            }
            break;
        case 8:
            // ships power
            result = (startStar->GetNonSatelliteShipStrength() > endStar->GetNonSatelliteShipStrength());
            break;
        default:
            // compare name (alphabetical order)
            result = (std::strcmp(startStar->GetName(), endStar->GetName()) < 0);
            break;
        }
        return result;
    }
    int mColumnNum;
};


void
GalacticaDoc::SortSystemsWindowByColumn(int columnNum) {
    // new sort order for the list
    SortSystemsByColumn myCompare(columnNum);
    std::sort(mSystemsList.begin(), mSystemsList.end(), myCompare);  
    // find the main view and wipe out all the old subpanes 
	LView* theView = static_cast<LView*>( mSystemsWindow->FindPaneByID(1001) );
    theView->DeleteAllSubPanes();    
	// Create Panes in list
	SPaneInfo	Info2;
	SViewInfo	VInfo;
	RGBColor	Grey;
	Grey.red = 0xDFFF;
	Grey.blue = 0xDFFF;
	Grey.green = 0xDFFF;
	Info2.paneID = 0;
	Info2.width = (589+46);
	Info2.height = 16;
	Info2.visible = TRUE;
	Info2.enabled = TRUE;
	Info2.bindings.left = FALSE;
	Info2.bindings.right = FALSE;
	Info2.bindings.top = FALSE;
	Info2.bindings.bottom = FALSE;
	Info2.left = 0;
	Info2.top = 0;
	Info2.userCon = 0;
	Info2.superView = theView;
	Info2.paneID = 1100;
	VInfo.imageSize.width = Info2.width;
	VInfo.imageSize.height = Info2.height;
	VInfo.scrollPos.h = 0;
	VInfo.scrollPos.v = 0;
	VInfo.scrollUnit.h = 0;
	VInfo.scrollUnit.v = 0;
	VInfo.reconcileOverhang = 0;
	for (int i = 0; i < mSystemsList.size(); i++) {
		Info2.top = i * 16;
		CSystemInfoLine* systemInfoLine = new CSystemInfoLine(Info2, VInfo);
		systemInfoLine->FinishCreate();
		if (i % 2) {
			systemInfoLine->SetBackColor(Grey);
		}
		systemInfoLine->SetStar(mSystemsList[i]);
	}
    // turn off all the other buttons
	for (int i = base_SortButtonPaneId; i < (base_SortButtonPaneId + num_SortCommands); i++) {
	    LControl* theControl = dynamic_cast<LControl*>( mSystemsWindow->FindPaneByID(i) );
	    if (theControl) {
	        theControl->StopBroadcasting(); // don't send a message for changed value
	        if ((i - base_SortButtonPaneId) == columnNum) {
	            theControl->SetValue(1);
	        } else {
	            theControl->SetValue(0);
	        }
//	        theControl->Refresh();
	        theControl->StartBroadcasting();
	    }
	}
	mSystemsSortColumn = columnNum; // save for next time we open window
    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
    if (config) {
    	config->setConfigLong(GALACTICA_PREF_SYS_WIND_SORTBY, columnNum);
    }
    mSystemsWindow->Refresh();
}

// called by CFleetInfoLine in response to a double-click
void
GalacticaDoc::CloseFleetsWindow() {
    if (mFleetsWindow) {
        SPoint32 scrollPos;
	    LView* theView = static_cast<LView*>( mFleetsWindow->FindPaneByID(1001) );
        if (theView) {
            theView->GetScrollPosition(scrollPos);
            mFleetsScrollPos = scrollPos.v;
        }
        mFleetsWindow->DoClose();
        // DoClose will call AllowSubRemoval, which will cleanup the mFleetsWindow variable
        mFleetsList.clear();
    }
}

void
GalacticaDoc::ShowFleetsWindow() {
    mFleetsList.clear();
	LArray* everything = GetEverythingList();
	int last = everything->GetCount();
	int playerNum = GetMyPlayerNum();
	for (int i = 1; i <= last; i++) {
	   AGalacticThingy* it;
		everything->FetchItemAt(i, &it);
		long type = it->GetThingySubClassType();
		if ( (type == thingyType_Ship) || (type == thingyType_Fleet)) {
       		if ((it->GetOwner() == playerNum) && !it->IsDead()) {
       		   // found another of our ships, add it to list
       		   CShip* ship = static_cast<CShip*>(it);
       		   if (ship->IsInSpace() || ship->IsAtStar() && (ship->GetShipClass() != class_Satellite)) {
       		      mFleetsList.insert(mFleetsList.end(), ship);
       		   }
       		}
       	}
	}
    mFleetsWindow = LWindow::CreateWindow(window_Fleets, this);
	CKeyCmdAttach::DisableCmdKeys(); // no keyboard shortcuts while systems window showing
	LView* theView = static_cast<LView*>( mFleetsWindow->FindPaneByID(1001) );
	SDimension32 iSize;
	theView->GetImageSize(iSize);
	theView->ResizeImageTo(iSize.width, 16 * mFleetsList.size(), kDontRefresh);
	theView->ScrollImageTo(0, mFleetsScrollPos, kDontRefresh);
	// set up listeners for the sort buttons
	for (int i = base_SortButtonPaneId; i < (base_SortButtonPaneId + num_SortCommands); i++) {
	    LControl* theControl = dynamic_cast<LControl*>( mFleetsWindow->FindPaneByID(i) );
	    if (theControl) {
	        theControl->AddListener(&mControlListener);
	    }
	}
    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
    if (config) {
    	Rect bounds;
    	mFleetsWindow->GetGlobalBounds(bounds);
    	long val = 0;
    	config->getConfigLong(GALACTICA_PREF_FLEETS_WIND_HEIGHT, val);
    	if (val > 0) {
    		bounds.bottom = bounds.top + val;
    	}	
    	val = 0;
    	config->getConfigLong(GALACTICA_PREF_FLEETS_WIND_XPOS, val);
    	if (val > 0) {
    		long width = bounds.right - bounds.left;
    		bounds.left = val;
    		bounds.right = bounds.left + width;
    	}
    	val = 0;
    	config->getConfigLong(GALACTICA_PREF_FLEETS_WIND_YPOS, val);
    	if (val > 0) {
    		long height = bounds.bottom - bounds.top;
    		bounds.top = val;
    		bounds.bottom = bounds.top + height;
    	}
    	mFleetsWindow->DoSetBounds(bounds);
    }
	SortFleetsWindowByColumn(mFleetsSortColumn);
	mFleetsWindow->Show();
}


struct SortFleetsByColumn {
    SortFleetsByColumn(int columnNum) : mColumnNum(columnNum) {}
    bool operator()(CShip* const& startShip, CShip* const& endShip) {
        bool result = false;
        int startNum = 0;
        int endNum = 0;
        switch (mColumnNum) {
        case 1:
            // compare tech level (highest first)
            result = (startShip->GetTechLevel() > endShip->GetTechLevel());
            break;
        case 2:
            // compare speed (highest first)
            result = (startShip->GetSpeed() > endShip->GetSpeed());
            break;
        case 3:
            // compare power (highest first)
            result = (startShip->GetPower() > endShip->GetPower());
            break;
        case 4:
            // compare ships in fleet (highest first)
            {
                if (startShip->GetThingySubClassType() == thingyType_Fleet) {
                    startNum = startShip->GetContentsCountForType(contents_Ships);
                }
                if (endShip->GetThingySubClassType() == thingyType_Fleet) {
                    endNum = endShip->GetContentsCountForType(contents_Ships);
                }
                result = startNum > endNum;
            }
            break;
        case 5:
            // compare damage (highest first)
            result = (startShip->GetDamagePercent() > endShip->GetDamagePercent());
            break;
        case 6:
            // compare colony y/n
            {
                if (startShip->GetThingySubClassType() == thingyType_Fleet) {
                    if (static_cast<CFleet*>(startShip)->HasShipClass(class_Colony)) {
                        startNum = 2;
                    }
                } else if (startShip->GetShipClass() == class_Colony) {
                    startNum = 1;
                }
                if (endShip->GetThingySubClassType() == thingyType_Fleet) {
                    if (static_cast<CFleet*>(endShip)->HasShipClass(class_Colony)) {
                        endNum = 2;
                    }
                } else if (endShip->GetShipClass() == class_Colony) {
                    endNum = 1;
                }
                result = startNum > endNum;
            }
            break;
        case 7:
            // compare destination
            {
                if (startShip->CoursePlotted()) {
                    startNum = 1;
                } else if (startShip->IsOnPatrol()) {
                    startNum = 2;
                }
                if (endShip->CoursePlotted()) {
                    endNum = 1;
                } else if (endShip->IsOnPatrol()) {
                    endNum = 2;
                }
                // both going to a named destination, compare them
                if ((startNum == 1) && (endNum == 1)) {
                    std::string startStr;
                    std::string endStr;
                    startShip->GetDestination().GetDescription(startStr);
                    endShip->GetDestination().GetDescription(endStr);
                    // compare destination name (alphabetical order)
                    result = (std::strcmp(startStr.c_str(), endStr.c_str()) < 0);                        
                } else {
                    result = startNum < endNum;
                }
            }
            break;
        default:
            // compare name (alphabetical order)
            result = (std::strcmp(startShip->GetName(), endShip->GetName()) < 0);
            break;
        }
        return result;
    }
    int mColumnNum;
};

void
GalacticaDoc::SortFleetsWindowByColumn(int columnNum) {
    // new sort order for the list
    std::sort(mFleetsList.begin(), mFleetsList.end(), SortFleetsByColumn(columnNum));  
    // find the main view and wipe out all the old subpanes 
	LView* theView = static_cast<LView*>( mFleetsWindow->FindPaneByID(1001) );
    theView->DeleteAllSubPanes();    
    // add the new subpanes
	// Create Panes in list
	SPaneInfo	Info2;
	SViewInfo	VInfo;
	RGBColor	Grey;
	Grey.red = 0xDFFF;
	Grey.blue = 0xDFFF;
	Grey.green = 0xDFFF;
	Info2.paneID = 0;
	Info2.width = (589+46);
	Info2.height = 16;
	Info2.visible = TRUE;
	Info2.enabled = TRUE;
	Info2.bindings.left = FALSE;
	Info2.bindings.right = FALSE;
	Info2.bindings.top = FALSE;
	Info2.bindings.bottom = FALSE;
	Info2.left = 0;
	Info2.top = 0;
	Info2.userCon = 0;
	Info2.superView = theView;
	Info2.paneID = 1100;
	VInfo.imageSize.width = Info2.width;
	VInfo.imageSize.height = Info2.height;
	VInfo.scrollPos.h = 0;
	VInfo.scrollPos.v = 0;
	VInfo.scrollUnit.h = 0;
	VInfo.scrollUnit.v = 0;
	VInfo.reconcileOverhang = 0;
	for (int i = 0; i < mFleetsList.size(); i++) {
		Info2.top = i * 16;
		CFleetInfoLine* infoLine = new CFleetInfoLine(Info2, VInfo);
		infoLine->FinishCreate();
		if (i % 2) {
			infoLine->SetBackColor(Grey);
		}
		infoLine->SetShip(mFleetsList[i]);
	}
    theView->Refresh();
    // turn off all the other buttons
	for (int i = base_SortButtonPaneId; i < (base_SortButtonPaneId + num_SortCommands); i++) {
	    LControl* theControl = dynamic_cast<LControl*>( mFleetsWindow->FindPaneByID(i) );
	    if (theControl) {
	        theControl->StopBroadcasting(); // don't send a message for changed value
	        if ((i - base_SortButtonPaneId) == columnNum) {
	            theControl->SetValue(1);
	        } else {
	            theControl->SetValue(0);
	        }
//	        theControl->Refresh();
	        theControl->StartBroadcasting();
	    }
	}
	mFleetsSortColumn = columnNum; // save for next time we open window
    pdg::ConfigManager* config = Galactica::Globals::GetInstance().getConfigManager();
    if (config) {
    	config->setConfigLong(GALACTICA_PREF_FLEETS_WIND_SORTBY, columnNum);
    }
    mFleetsWindow->Refresh();
}

void
GalacticaDoc::AdjustWindowSize() {	// adjust the window to match the state of the Full Screen item
    if (!mWindow) {
        return;
    }
	WindowPtr windP = mWindow->GetMacWindow();
	Rect strucRect = UWindows::GetWindowStructureRect(windP);
	GDHandle dominantDevice = UWindows::FindDominantDevice(strucRect);
    Rect screenRect;
    if (dominantDevice) {
        screenRect = (**dominantDevice).gdRect;
    }
	OSStatus err = MacAPI::GetAvailableWindowPositioningBounds(dominantDevice, &screenRect);
	bool fullScreen = Galactica::Globals::GetInstance().getFullScreenMode();
	if (err != noErr) {
		if (dominantDevice == MacAPI::GetMainDevice()) {
			screenRect.top += MacAPI::GetMBarHeight(); // don't overwrite menu bar on main device
	      #if !TARGET_OS_WIN32
		    if (!fullScreen && (UEnvironment::IsRunningOSX())) {  // On MacOS X we need to account for the dock
		        screenRect.bottom -= 60; // just guessing that 60 pixels is good
		    }
		  #endif
		}
	}
	GalacticaWindow* galWind = dynamic_cast<GalacticaWindow*>(mWindow);
	if (galWind) {
	    galWind->UseFullScreen(fullScreen);		// let the window know how to behave
	}
	if (fullScreen) {
		mWindow->DoSetBounds(screenRect);	// always resize to screen in full screen mode
	} else {				// otherwise, check to see if the window is within the screen because
		bool resize = ! ::MacPtInRect(topLeft(strucRect), &screenRect);	// we don't want to resize
		if (!resize) {													// it to the standard size
			resize = ! ::MacPtInRect(botRight(strucRect), &screenRect);	// if it already fits and we
	    }                                                               // aren't in full screen mode
		if (resize) {													
			mWindow->CalcStandardBoundsForScreen(screenRect, strucRect);
			mWindow->DoSetBounds(strucRect);
		}
	}
}

void
GalacticaDoc::ShowWindow(bool inPlayMessages) {
	if (mWindow) {
		AdjustWindowSize();
		Galactica::Globals::GetInstance().getWindowMenu()->InsertWindow( mWindow );
		mWindow->Show();
		LCommander::SwitchTarget(this);
		mStarMap->ZoomAllSubPanes(0);
		// now display the home planet and any messages 
		// v1.2fc4, tutorial, document takes over control of the tutorial once it is created
     #if TUTORIAL_SUPPORT
		if (Tutorial::TutorialIsActive()) {
			Tutorial::GetTutorial()->ReassignControlTo(this);
		}
     #endif //TUTORIAL_SUPPORT
		AGalacticThingyUI *aThingy = NULL;
		if (mSelectedThingy == NULL) {
			aThingy = static_cast<AGalacticThingyUI*>(FindThingByID(GetMyPlayerHomeID()));
		} else {
			aThingy = mSelectedThingy;	// force a refresh of selected thingy
			mSelectedThingy = NULL;		// when we show the window
		}
		aThingy = ValidateThingyUI(aThingy);
		if (aThingy) {
			aThingy->Select();
		} else {
			DEBUG_OUT("mSelectedThingy was invalid at time of window activation.", DEBUG_ERROR);
		    SetSelectedThingy(NULL);
		}
		bool oldWantMessages = mWantGameMessages;
		if (!inPlayMessages) { // suppress messages if the caller doesn't want them
			SetWantsMessages(false);
		}
		ShowMessages();
		ShowNextNeedyThingy();
		SetWantsMessages(oldWantMessages);
	}
}

void
GalacticaDoc::SetStatusMessage(int, const LStr255 &) { // inMessageNum, inExtra
	// еее override to show status messages
}

void
GalacticaDoc::UpdateTurnNumberDisplay() {
	LPane* turnNumPane = mWindow->FindPaneByID(caption_TurnNum);
	if (turnNumPane) {
		LStr255 s = mGameInfo.currTurn;
		LStr255 ts(STRx_General, str_Turn);
		ts += s;
		turnNumPane->SetDescriptor(ts);
	}
}


void
GalacticaDoc::RebuildEventMessages() {
	if (mNeedy) {
		CMessage* msg;
		ThingMemInfoT info;
		long numItems = mNeedy->GetCount();
		long i = 1;
		while (i<=numItems) {
			mNeedy->FetchItemAt(i, &info);
			msg = ValidateMessage(info.thing);
			ASSERT(msg != nil);
			msg->RebuildReportString();
			i++;
		}
		if (mEventsWindow) {
			mEventsWindow->Refresh();
		}
/*		if (mEventText) {			// this doesn't work because the message needs updating
			mEventText->Refresh();
		} */
	}
}

void
GalacticaDoc::MakeWindow() {
	DEBUG_OUT("GameDoc::MakeWindow " << GetMyPlayerNum(), DEBUG_IMPORTANT);
	CStarMapView *theStarMap;
#ifdef CHECK_REGISTRATION
	AddAttachment(new CCheckTimeUpAttach(this));
#endif
	sStreamingDoc = this;
	mWindow = LWindow::CreateWindow(window_StarMap, this);
	sStreamingDoc = nil;
	std::string s;
	FSSpec	fileSpec;			// Document name is same as its File
	if ((mFile != nil) && mIsSpecified) {
		mFile->GetSpecifier(fileSpec);
		char tmpstr[256];
		p2cstrcpy(tmpstr, fileSpec.name);
		s = tmpstr;
	} else {	// just use the title entered
	    char tmpstr[256];
	    p2cstrcpy(tmpstr, mGameInfo.gameTitle);
		s = tmpstr;
		if (!IsSinglePlayer()) {
    		s += " - ";
    		s += mPlayerName;
        }
	}
	if (s.size()>0) {
	    LStr255 s2 = s.c_str();
		mWindow->SetDescriptor(s2);			// make the window title reflect the saved turn filename
	}
	theStarMap = (CStarMapView*) mWindow->FindPaneByID(view_StarMap);
	((GalacticaWindow*)mWindow)->SetStarMap(theStarMap);
	theStarMap->SetSectorSize(mGameInfo.sectorSize);
	theStarMap->ZoomTo(4);	//start game with some zoom would look
	LPane*	helpLinePane = mWindow->FindPaneByID(caption_HelpLine);
	((GalacticaWindow*)mWindow)->SetHelpLinePane(helpLinePane);
	mDimmerPict = (LPicture*)mWindow->FindPaneByID(pict_Dimmer);
	ThrowIfNil_(mDimmerPict);
	mEventText = (CResCaption*)mWindow->FindPaneByID(caption_EventText);
	ThrowIfNil_(mEventText);
	mViewer = (CLayeredOffscreenView*) mWindow->FindPaneByID(layerView_Viewer);	// v1.2
	ASSERT(mViewer != nil);
// set the current active panel
	mButtonBar = (LPPobView*) mWindow->FindPaneByID(ppobview_ButtonBar);
	mPanel = (LPPobView*) mWindow->FindPaneByID(ppobview_Panel);
	mPanelCaption = (LCaption*) mWindow->FindPaneByID(caption_PanelName);
	mViewNameCaption = (LCaption*) mWindow->FindPaneByID(caption_ViewName);

	mEndTurnButton = (LButton*) mWindow->FindPaneByID(button_EndTurn);
	LCaption *timeCaption = (LCaption*) mWindow->FindPaneByID(caption_TimeDisplay);
	LButton *theRenameButton = (LButton*) mWindow->FindPaneByID(-caption_ViewName);
	LButton *theZoomInButton = (LButton*) mWindow->FindPaneByID(cmd_ZoomIn);
	LButton *theZoomOutButton = (LButton*) mWindow->FindPaneByID(cmd_ZoomOut);	
	LButton *theZoomFillButton = (LButton*) mWindow->FindPaneByID(cmd_ZoomFill);	
	LToggleButton *theDispOwnerButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayOwner);
	LToggleButton *theDispProdButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayProduct);
	LToggleButton *theDispTechButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayTech);
	LToggleButton *theDispDefnsButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayDefense);
	LToggleButton *theDispDangerButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayDanger);
	LToggleButton *theDispGrowthButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayGrowth);
	LToggleButton *theDispShipsButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayShips);
	LToggleButton *theDispResearchButton = (LToggleButton*) mWindow->FindPaneByID(cmd_DisplayResearch);
	mAutoEndTurnTimer.SetDisplayPane(timeCaption);
/*
// еее setup custom colors for the scroll bars
	LScroller	*theScroller;
	theScroller = (LScroller*) theWindow->FindPaneByID('SMsc');
	LStdControl *theScrollBar = (LStdControl*) theScroller->FindPaneByID(PaneIDT_HorizontalScrollBar);
	ControlHandle theControl = theScrollBar->GetMacControl();
	CCTabHandle theColorTable = (CCTabHandle) GetResource('cctb',128);
	DetachResource((Handle)theColorTable);
	SetControlColor(theControl, theColorTable);	
	theScrollBar = (LStdControl*) theScroller->FindPaneByID(PaneIDT_VerticalScrollBar);
	theControl = theScrollBar->GetMacControl();
	theColorTable = (CCTabHandle) GetResource('cctb',128);
	DetachResource((Handle)theColorTable);
	SetControlColor(theControl, theColorTable);
// end code for custom scroll bar colors
*/
	if (theStarMap != nil) { // make sure the starmap is ready to go
		theStarMap->Enable();
		if (theRenameButton != nil)
			theRenameButton->AddListener(theStarMap);
		if (theZoomInButton != nil)
			theZoomInButton->AddListener(theStarMap);
		if (theZoomOutButton != nil)
			theZoomOutButton->AddListener(theStarMap);
		if (theZoomFillButton != nil)
			theZoomFillButton->AddListener(theStarMap);
		if (theDispOwnerButton)
			theDispOwnerButton->AddListener(theStarMap);
		if (theDispProdButton)
			theDispProdButton->AddListener(theStarMap);
		if (theDispTechButton)
			theDispTechButton->AddListener(theStarMap);
		if (theDispDefnsButton)
			theDispDefnsButton->AddListener(theStarMap);
		if (theDispDangerButton)
			theDispDangerButton->AddListener(theStarMap);
		if (theDispGrowthButton)
			theDispGrowthButton->AddListener(theStarMap);
		if (theDispShipsButton)
			theDispShipsButton->AddListener(theStarMap);
		if (theDispResearchButton)
			theDispResearchButton->AddListener(theStarMap);
		ThrowIfNil_(mEndTurnButton);
		mEndTurnButton->AddListener(theStarMap);
	}
	mStarMap = theStarMap;
	UpdateTurnNumberDisplay();
}

void
GalacticaDoc::SwitchToButtonBar(long inThingyCode) {
	if (!mWindow->IsVisible())
		return;
	long theBarNum;
	Boolean bHasView = true;
	ResIDT layrID = Layr_ViewerBase;
	ResIDT idOffset = 0;
	switch (inThingyCode) {
		case thingyType_Star:
			theBarNum = 1;
			break;
		case thingyType_Ship:
			theBarNum = 2;
			break;
		case thingyType_Fleet:
			theBarNum = 3;
			break;
		case thingyType_Message:	// messages,
		case thingyType_DestructionMessage:	// destruction messages, do not have panels
			return;
		case thingyType_Rendezvous:	// rendezvous points...
			theBarNum = 4;
			bHasView = false;	// rendezvous pts use standard galaxy map view, not special pict
			break;
		case thingyType_StarLane:
		case thingyType_Wormhole:
		default:
			theBarNum = 0;	// display Galaxy map and empty panels
			break;
	}
	// swap to the appropriate button bar
	if (mButtonBar) {
		sStreamingDoc = this;
		mButtonBar->SetPPob(view_BaseButtonBar + theBarNum);
		sStreamingDoc = nil;
	}
	std::string titleStr;
	LoadStringResource(titleStr, STRx_ViewNames, theBarNum+1);
	// Display the appropriate picture in the viewer for the selected item
	if (bHasView) {
		layrID += (theBarNum * LayrID_ButtonBarOffset);	// get the item's special picture
	}
	if (theBarNum) {	// for anything other than the Galaxy Map, add item name and owner to viewer caption
		idOffset = mSelectedThingy->GetViewLayrResIDOffset();
		LStr255 s;
		mSelectedThingy->GetDescriptor(s);
		char tmpstr[256];
		p2cstrcpy(tmpstr, s);
		int myPlayerNum = GetMyPlayerNum();
		if (mSelectedThingy->IsAllyOf(myPlayerNum) || mSelectedThingy->GetVisibilityTo(myPlayerNum) >= visibility_Class) {
		    titleStr += tmpstr;
		}
		long owner = mSelectedThingy->GetOwner();
		if (owner) {	// don't display unknown name
			if (mSelectedThingy->IsAllyOf(myPlayerNum) || mSelectedThingy->GetVisibilityTo(myPlayerNum) > visibility_None) {
				titleStr += " е ";
				std::string s2;
				GetPlayerName(owner, s2);
				titleStr += s2;
			}
		}
	}
	if (mViewer) {
		layrID += idOffset;				// use the specific image if available
		mViewer->SetLayrResID(layrID);	// load the image layers
	}
	if (mViewNameCaption) {
	    LStr255 s = titleStr.c_str();
		mViewNameCaption->SetDescriptor(s);
    }
}

void
GalacticaDoc::TimeIsUp() {	// from CTimed, called by CTimer when the turn time limit expires
	DEBUG_OUT("GameDoc::TimeIsUp " << GetMyPlayerNum(), DEBUG_IMPORTANT);
}

void
GalacticaDoc::StopAllMouseTracking() {
	CMouseTracker* theTracker = mStarMap->GetMouseTracker();
	if (theTracker) {
		theTracker->Hide(true);				// stop it from repeating as well
		mStarMap->SetMouseTracker(nil);		// remove it from the starmap
		CStarMapView::ClickReceived();		// let the starmap know that it doesn't need to wait for a click anymore
		delete theTracker;
	}
}

void
GalacticaDoc::SetSelectedThingy(AGalacticThingyUI* inThingy) {
//	static long sOldPos;	// 1.2b8d5, maintain previous item's position
	long type = thingyType_Message;	// use this as default for seeing if we want to call UpdatePanel()
	ASSERT(ValidateThingy(mSelectedThingy) == mSelectedThingy);	// nil is a legal value
	ASSERT(ValidateThingy(inThingy) == inThingy);				// for both of these
	mSelectedThingy = ValidateThingyUI(mSelectedThingy);	// don't let this error cause a crash
	inThingy = ValidateThingyUI(inThingy);
	if (mSelectedThingy != inThingy) {
		CBalloonApp::sHelpPane = nil;	// clear cached Balloon since object changed state
		if (mSelectedThingy) {
//			mStarMap->GetSubPanes().SwapItems(LArray::index_Last, sOldPos);	// return old selected item to previous position
			mSelectedThingy->EraseSelectionMarker();
			mSelectedThingy->Refresh();
		}
		GalacticaSharedUI::SetSelectedThingy(inThingy);
		SelectThingyInEventsWindow(inThingy);
		if (inThingy) {
		    if (inThingy->GetThingySubClassType() != thingyType_Rendezvous) {   // 2.1b3, don't ever put rendezvous points in front
    			long oldPos = mStarMap->GetSubPanes().FetchIndexOf(inThingy);	// 1.2b8d5, find selected item in super's list
    			mStarMap->GetSubPanes().SwapItems(LArray::index_Last, oldPos);	// put selected item in front
			}
			inThingy->DrawSelectionMarker();
			inThingy->Refresh();
			Waypoint wp = inThingy->GetPosition();
			if (!(wp.IsNull() || wp.IsNowhere())) {	// don't scroll to nil position objects
				mStarMap->ScrollToThingy(inThingy);
			}
			ThingyAttendedTo(inThingy);	// remove it from the needy list
			type = inThingy->GetThingySubClassType();
			SwitchToButtonBar(type);
			// begin tutorial stuff
          #if TUTORIAL_SUPPORT
			if (Tutorial::TutorialIsActive()) {
				Tutorial* t = Tutorial::GetTutorial();
				if ( (inThingy->GetPaneID() == tutorial_HomeStarID) && 
					 ((t->GetPageNum() == tutorialPage_SelectHome) ||
					  (t->GetPageNum() == tutorialPage_SelectHome2)) ) {
					t->NextPage();
				}
			}
          #endif //TUTORIAL_SUPPORT
			// end tutorial stuff
		} else if (mWindow) {
			SwitchToButtonBar(0);
		}
		if (mWindow) {
			CBoxView *activePanel = GetActivePanel();
			if ( !IS_ANY_MESSAGE_TYPE(type) && (type!=thingyType_Rendezvous) && activePanel) {	// don't update panel for messages or rendezvous points
				activePanel->UpdatePanel(mSelectedThingy);		// еее problems with mSelected != thing in panel?
			}
		}
	}
}

void
GalacticaDoc::AddMessageToNeedyList(CMessage* inMsg) {
	inMsg = ValidateMessage(inMsg);
	ASSERT_STR(inMsg != nil, "Attempting to add invalid thingy to needy list");
    if (!inMsg) {
        return; // abort if we have an invalid message
    }
	long type = inMsg->GetThingySubClassType();
	ASSERT_STR( IS_ANY_MESSAGE_TYPE(type), "Added "<<inMsg<<" to needy list!" );
	if (mNeedy==nil) {
		mNeedy = new LArray(sizeof(ThingMemInfoT));	// construct an array if needed
	}
	ThingMemInfoT info;
	info.info.thingID = inMsg->GetID();
	info.info.thingType = type;
	info.info.action = action_Message;
	info.thing = inMsg;
	if (inMsg->HasAutoShow()) {
		info.info.flags = thingInfoFlag_AutoShow;	// flag it as having autoshow so we
	} else {										// don't have to check it later
		info.info.flags = thingInfoFlag_None;	// no flags set
	}
	mNeedy->InsertItemsAt(1, LArray::index_Last, &info);	// move item to the needy list
}


/*----------------------------------------------------------------------------------------
YieldTime() - Lets this game yield time to other applications, etc. Automatically yeilds
				more time when app is in background so forground apps will be more responsive

SIDE EFFECTS	May call WaitNextEvent()
----------------------------------------------------------------------------------------*/

extern UInt32 gFGNextEventCheck;	// these are defined in Galactica.cp
extern UInt32 gFGBusyWorkTicks;	

void
GalacticaDoc::YieldTime() {
	GalacticaApp* app = (GalacticaApp*) LCommander::GetTopCommander();
	EventRecord macEvent;
	Boolean	gotEvent;
	long wait;
	short mask;
	if (app->IsOnDuty()) {		// if we are the foreground app, this should allow
		// us to catch application switches, and redraw the screen, but not too 
		if (::TickCount() < gFGNextEventCheck) {	// often, because we're busy
			return;
		}
		gFGNextEventCheck = ::TickCount() + gFGBusyWorkTicks;	
		wait = 0;
		mask = osMask + keyDownMask + mouseDown + updateMask;
	} else {	// when we are the background app, give up time whenever called
		wait = 1;
		mask = osMask + updateMask;
	}
	// only accepting update events to keep screen looking pretty
	gotEvent = ::WaitNextEvent(mask, &macEvent, wait, nil);
  #if SEND_DEBUGGING_TEXT_TO_SCREEN
	if (!SIOUXHandleOneEvent(&macEvent)) {	// can SIOUX handle the event?
		if (gotEvent) {
			app->DispatchEvent(macEvent);	// dispatch the update event
		}
	}
  #else
	if (gotEvent) {
		app->DispatchEvent(macEvent);	// dispatch the update event
	}
  #endif
}



/*----------------------------------------------------------------------------------------
ThingyAttendedTo() - Locate the first *Unhandled* reference to the thingy in the Needy  
                     List and mark it as Handled, refreshing the Events Table if needed

INPUT			a ptr to a valid GalacticThingy

SIDE EFFECTS	the mNeedy list might have an entry marked as handled, and the specified
				cell in the Events report window may be redrawn, which will make the item
				text for the changed enty appear dimmer.

OUTPUT			none.
----------------------------------------------------------------------------------------*/
void
GalacticaDoc::ThingyAttendedTo(AGalacticThingy* inSatisfiedThingy) {
	if (mNeedy==nil) {	// if there are no needy things, don't have to worry about this one
		return;
	}
	ThingMemInfoT info;
#ifdef DEBUG 	
	if (ValidateThingy(inSatisfiedThingy) == nil) {	// еее debugging
		DEBUG_OUT("Invalid Object passed to ThingyAttendedTo()", DEBUG_ERROR);
	}
#endif
	inSatisfiedThingy = ValidateThingy(inSatisfiedThingy);
	if (inSatisfiedThingy) {
		ArrayIndexT idx = FindThingyInNeedyList(inSatisfiedThingy, &info);
		if (idx != LArray::index_Bad) {
	 		info.info.flags |= thingInfoFlag_Handled;	// mark it as handled
	 		mNeedy->AssignItemsAt(1, idx, &info);
			if (info.info.flags & thingInfoFlag_AutoShow) {
				mNumUnprocessedAutoShows--;	// this one has been handled
			} else {
				mNumUnprocessedGotos--;		// one less thing to show
				inSatisfiedThingy->SetWantsAttention(false);
			}
			if (mEventsTable) {				// redraw the Events Table because an item changed
				mEventsTable->Refresh();	// еее this should really be a RefreshCell() call
			}								// еее but no such method exists in CNewTable...yet
 		}
	}
}

RGBColor*
GalacticaDoc::GetColor(int inOwner, Boolean inBrighter) {
	inOwner = GetColorIndex(inOwner, false);
	if (inBrighter)
		return &mSelectedColorArray[inOwner];
	else
		return &mColorArray[inOwner];
}

// Added 970630 JRW
SInt32 GalacticaDoc::GetColorIndex(int inOwner, Boolean) {	// inSelected
   int myPlayerNum = GetMyPlayerNum();
	if ((myPlayerNum > 0) && (myPlayerNum <= MAX_PLAYERS_CONNECTED)) {
		if (inOwner == myPlayerNum)
			inOwner = 1;	// color will always be used for the player
		else if (inOwner == 1) 
			inOwner = myPlayerNum;	// еее for now, just use the color at mPlayerNum for player 1
	}
	// еее eventually, there should be a way to map players #s to color sets
	// еее so color set 2 could represent players 4, 5 and 8; while other colors were assigned to
	// еее still other players 
	if (inOwner < 0) inOwner = 0;
	if (inOwner >= kNumUniquePlayerColors) inOwner = kNumUniquePlayerColors-1;
	return(inOwner);
}

void
GalacticaDoc::SetPanelCaption(LStr255 &s) {
	mPanelCaption->SetDescriptor(s);
}


