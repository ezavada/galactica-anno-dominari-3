// ===========================================================================// CFileStream.h//// std::FILE based implementation of LFileStream.h from PowerPlant 2.2//// (c) 2005, Sacred Tree Software & Ed Zavada// ===========================================================================////	A wrapper class for a file with a data fork. No resource fork support////	This class does not provide many functions for manipulating files, add//  them as needed#ifndef CFILESTREAM_H_INCLUDED#define CFILESTREAM_H_INCLUDED#include <LStream.h>#include <cstdio>#include <string>// prevent conflicts with Win32 API#undef CreateFile#undef DeleteFile// ---------------------------------------------------------------------------class	CFileStream : public LStream {public:        enum {        privileges_ReadOnly             = 0,        privileges_ReadWrite            = 1    };        enum {        fileSuccess         = 0,   // the operation succeeded        fileExistsErr       = -1,  // the file couldn't be created because it already exists        filePrivilegeErr    = -2,  // the file couldn't be opened/written because the privileges weren't obtainable        fileNotFoundErr     = -3,  // the file couldn't be opened/deleted because it doesn't exist        fileNotOpenErr      = -4,  // the file couldn't be read/written because it hasn't been opened        fileSystemErr       = -5   // the operation failed because of an underlying OS error, check errno    };        enum {        attrib_Creator,        attrib_Type,        attrib_CreationDate,        attrib_ModificationDate,        attrib_IsFolder,        attrib_IsSymbolicLink,        attrib_IsInvisible,        attrib_DrawLocation,        attrib_Permissions    };	CFileStream();		// unix style path, plus name	CFileStream(const char* inPath, const char* inName);		// unix style full path plus name	CFileStream(const char* inPathName);    const char*         GetName() { return mName.c_str(); }    const char*         GetPath() { return mPath.c_str(); }    const char*         GetPathName() { return mPathName.c_str(); }    const char*         GetFileType() { return mType.c_str(); }    void                SetName(const char* inName);    void                SetPath(const char* inPath);    void                SetPathName(const char* inPathName);    	virtual				~CFileStream();	virtual ExceptionCode   CreateFile(); 	virtual ExceptionCode   OpenFile(int inPrivileges = privileges_ReadOnly);		virtual bool        FileExists();	virtual void		CloseFile();		virtual void        FlushFile();		virtual ExceptionCode   DeleteFile();		virtual ExceptionCode   SetFileAttribute(int attribKey, const char* attribValue);    virtual const char*     GetFileAttribute(int attribKey, char* buffer, long bufferSize);    	virtual void		SetMarker(SInt32 inOffset, EStreamFrom inFromWhere);	virtual SInt32		GetMarker() const;	virtual void		SetLength(SInt32 inLength);	virtual SInt32		GetLength() const;	virtual ExceptionCode   PutBytes(const void* inBuffer, SInt32& ioByteCount);	virtual ExceptionCode   GetBytes(void* outBuffer, SInt32& ioByteCount);protected:	std::string mName;	std::string mPath;	std::string mPathName;	std::string mType;	std::string mNativePathName;	int   mPrivs;	std::FILE* mFilePtr;private:    // Copy and Assignment not allowed	CFileStream( const CFileStream& ) {}	CFileStream& operator= (const CFileStream&) { return *this; }};#endif // CFILESTREAM_H_INCLUDED